──:CompUnit+{StrByDump}
  └─:Block :annotations({"named" => {}, "slurpy" => [], "positional" => [], "optional" => []})
    ╟─bind ::(Str)
    ║ ├○ .src :decl(static) ::(Str)
    ║ └◙ SVal "\n#\"foo\"  # type str\n\n#42     # ERROR NYI\n\n#λx.x    # type t0 -> t0\n\n#λx.λ_.x   # type t0 -> NQPMu -> t0\n\n#λ_.\"foo\"    # type: NQPMu -> str\n\n#(λx.x) \"foo\"    # type: t5 where t5 = str\n\n#(\"foo\" \"bar\")   # Type Error: cannot apply str to str\n\n#(\"foo\" λx.x)   # Type Error: cannot apply str to Void -> t0 where t0 = t5 -> t5\n\n((λx.x) λx.x)   # type: t5 where t5 = Void -> t0; t0 = t6 -> t6\n\n#(δ (# Combinators:\n#    #(M λu.u u)                  # self-application\n#    #(K λx.λ_.x)                 # (make) a constant function\n#    (I λx.x)                    # identity\n#   )\n#    I \"foo\"\n#)\n\n" ::(Str)
    ╟─bind ::(Array)
    ║ ├○ .λinfo :decl(static) ::(Array)
    ║ └─list ::(Array)
    ║   ├─list ::(Array)
    ║   │ ├◙ SVal "x" ::(Str)
    ║   │ ├◙ IVal 324 ::(Int)
    ║   │ ├◙ IVal 4 ::(Int)
    ║   │ └◙ SVal "" ::(Str)
    ║   └─list ::(Array)
    ║     ├◙ SVal "x" ::(Str)
    ║     ├◙ IVal 330 ::(Int)
    ║     ├◙ IVal 4 ::(Int)
    ║     └◙ SVal "" ::(Str)
    ╟─bind ::(Void -> Str) :annotations({"constraints" => (NQPMu, Type object)})
    ║ ├○ &banner :decl(static) ::(Void -> Str)
    ║ └─:Block "&banner" ::(Void -> Str) :annotations({"named" => {}, "slurpy" => [], "positional" => [], "optional" => []})
    ║   ╙◙ SVal "This is L v0.0.1" ::(Str)
    ╟─bind ::(t11 -> Str) :annotations({"constraints" => "t11 = Str"})
    ║ ├○ &strLit :decl(static) ::(t11 -> Str)
    ║ └─:Block "&strLit" ::(t11 -> Str) :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical s :decl(param))], "optional" => [], "constraints" => "t11 = Str"})
    ║   ╟○ s :decl(param) ::(t11) :annotations({"positional_index" => 0})
    ║   ╟○ foo :decl(var) ::(t12)
    ║   ╙─concat ::(Str)
    ║     ├◙ SVal "\"" ::(Str)
    ║     └─concat ::(Str)
    ║       ├─escape ::(Str)
    ║       │ └○ s ::(t11)
    ║       └◙ SVal "\"" ::(Str)
    ╟─bind ::((t14 × t15) -> Array) :annotations({"constraints" => "t14 = Array  &  t15 = Int  &  t20 = Int  &  t22 = (Bool + t20)  &  t23 = t24  &  t25 = Int  &  t27 = Bool"})
    ║ ├○ &sublist :decl(static) ::((t14 × t15) -> Array)
    ║ └─:Block "&sublist" ::((t14 × t15) -> Array) :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical list :decl(param)), QAST::Var(lexical from :decl(param))], "optional" => [], "constraints" => "t14 = Array  &  t15 = Int  &  t20 = Int  &  t22 = (Bool + t20)  &  t23 = t24  &  t25 = Int  &  t27 = Bool"})
    ║   ╟○ list :decl(param) ::(t14) :annotations({"positional_index" => 0})
    ║   ╟○ from :decl(param) ::(t15) :annotations({"positional_index" => 1})
    ║   ╟─bind ::(Int)
    ║   ║ ├○ n :decl(var) ::(Int)
    ║   ║ └─elems ::(Int)
    ║   ║   └○ list ::(t14)
    ║   ╟─bind ::(Int)
    ║   ║ ├○ count :decl(var) ::(Int)
    ║   ║ └○ n ::(Int)
    ║   ╟─bind ::(Int)
    ║   ║ ├○ to :decl(var) ::(Int)
    ║   ║ └─add_i ::(Int)
    ║   ║   ├○ from ::(t15)
    ║   ║   └○ count ::(Int)
    ║   ╟─bind ::(Array)
    ║   ║ ├○ out :decl(var) ::(Array)
    ║   ║ └─list ::(Array)
    ║   ╟─if ::(t22)
    ║   ║ ├─isgt_i ::(Bool)
    ║   ║ │ ├○ to ::(Int)
    ║   ║ │ └○ n ::(Int)
    ║   ║ └─bind ::(Int)
    ║   ║   ├○ to ::(Int)
    ║   ║   └○ n ::(Int)
    ║   ╟─while ::(t27)
    ║   ║ ├─islt_i ::(Bool)
    ║   ║ │ ├○ from ::(t15)
    ║   ║ │ └○ to ::(Int)
    ║   ║ └─:Stmts ::(Int)
    ║   ║   ├─push ::(Void)
    ║   ║   │ ├○ out ::(Array)
    ║   ║   │ └─atpos ::(t23)
    ║   ║   │   ├○ list ::(t14)
    ║   ║   │   └○ from ::(t15)
    ║   ║   └─bind ::(Int)
    ║   ║     ├○ from ::(t15)
    ║   ║     └─add_i ::(Int)
    ║   ║       ├○ from ::(t15)
    ║   ║       └◙ IVal 1 ::(Int)
    ║   ╙○ out ::(Array)
    ╟─bind ::(t29 -> t36) :annotations({"constraints" => "t29 = t35  &  t29 = (Void -> t33)  &  t29 = (Bool + Int + Num + Str + Array + (t31 -> t32))  &  t33 = t34  &  t36 = (t34 + t35)"})
    ║ ├○ &force :decl(static) ::(t29 -> t36)
    ║ └─:Block "&force" ::(t29 -> t36) :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical x :decl(param))], "optional" => [], "constraints" => "t29 = t35  &  t29 = (Void -> t33)  &  t29 = (Bool + Int + Num + Str + Array + (t31 -> t32))  &  t33 = t34  &  t36 = (t34 + t35)"})
    ║   ╟○ x :decl(param) ::(t29) :annotations({"positional_index" => 0})
    ║   ╟─bind ::(Str)
    ║   ║ ├○ foo :decl(var) ::(Str)
    ║   ║ └◙ SVal "bar" ::(Str)
    ║   ╙─if ::(t36)
    ║     ├─isinvokable ::(Bool)
    ║     │ └○ x ::(t29)
    ║     ├─call x ::(t33)
    ║     └○ x ::(t29)
    ╟─bind ::((t38 × t39 × t40 × t41) -> t56) :annotations({"constraints" => "t29 = t41  &  t36 = t49  &  t36 = t53  &  t38 = Array  &  t38 = (Bool + Int + Num + Str + Array + (t43 -> t44))  &  t39 = Str  &  t40 = (t47 -> t48)  &  t42 = Str  &  t42 = t45  &  t46 = Str  &  t48 = t50  &  t49 = t51  &  t52 = t54  &  t52 = (t50 + t51)  &  t53 = t55  &  t56 = (t54 + t55)"})
    ║ ├○ &ifTag :decl(static) ::((t38 × t39 × t40 × t41) -> t56)
    ║ └─:Block "&ifTag" ::((t38 × t39 × t40 × t41) -> t56) :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical subject :decl(param)), QAST::Var(lexical tag :decl(param)), QAST::Var(lexical then :decl(param)), QAST::Var(lexical else :decl(param))], "optional" => [], "constraints" => "t29 = t41  &  t36 = t49  &  t36 = t53  &  t38 = Array  &  t38 = (Bool + Int + Num + Str + Array + (t43 -> t44))  &  t39 = Str  &  t40 = (t47 -> t48)  &  t42 = Str  &  t42 = t45  &  t46 = Str  &  t48 = t50  &  t49 = t51  &  t52 = t54  &  t52 = (t50 + t51)  &  t53 = t55  &  t56 = (t54 + t55)"})
    ║   ╟○ subject :decl(param) ::(t38) :annotations({"positional_index" => 0})
    ║   ╟○ tag :decl(param) ::(t39) :annotations({"positional_index" => 1})
    ║   ╟○ then :decl(param) ::(t40) :annotations({"positional_index" => 2})
    ║   ╟○ else :decl(param) ::(t41) :annotations({"positional_index" => 3})
    ║   ╟○ tagAndId :decl(var) ::(t42)
    ║   ╙─if ::(t56)
    ║     ├─islist ::(Bool)
    ║     │ └○ subject ::(t38)
    ║     ├─:Stmts ::(t52)
    ║     │ ├─bind ::(t45)
    ║     │ │ ├○ tagAndId ::(t42)
    ║     │ │ └─atpos ::(t45)
    ║     │ │   ├○ subject ::(t38)
    ║     │ │   └◙ IVal 0 ::(Int)
    ║     │ └─if ::(t52)
    ║     │   ├─iseq_s ::(Bool)
    ║     │   │ ├○ tag ::(t39)
    ║     │   │ └─substr ::(t46)
    ║     │   │   ├○ tagAndId ::(t42)
    ║     │   │   ├◙ IVal 0 ::(Int)
    ║     │   │   └◙ IVal 1 ::(Int)
    ║     │   ├─call then ::(t48)
    ║     │   │ └─atpos ::(t47)
    ║     │   │   ├─radix ::(Array)
    ║     │   │   │ ├◙ IVal 10 ::(Int)
    ║     │   │   │ ├○ tagAndId ::(t42)
    ║     │   │   │ ├◙ IVal 1 ::(Int)
    ║     │   │   │ └◙ IVal 0 ::(Int)
    ║     │   │   └◙ IVal 0 ::(Int)
    ║     │   └─call &force ::(t49) :annotations({"forced" => QAST::Var(lexical else)})
    ║     │     └○ else ::(t41)
    ║     └─call &force ::(t53) :annotations({"forced" => QAST::Var(lexical else)})
    ║       └○ else ::(t41)
    ╟─bind ::((t58 × t59 × t60) -> t65) :annotations({"constraints" => "t29 = Str  &  t29 = t59  &  t36 = t63  &  t36 = t64  &  t38 = t58  &  t39 = t59  &  t40 = (t61 -> t62)  &  t41 = (Void -> Void)  &  t56 = t65  &  t58 = Array  &  t60 = Int  &  t63 = Str  &  t64 = Str"})
    ║ ├○ &->#n :decl(static) ::((t58 × t59 × t60) -> t65)
    ║ └─:Block "&->#n" ::((t58 × t59 × t60) -> t65) :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical subject :decl(param)), QAST::Var(lexical tag :decl(param)), QAST::Var(lexical index :decl(param))], "optional" => [], "constraints" => "t29 = Str  &  t29 = t59  &  t36 = t63  &  t36 = t64  &  t38 = t58  &  t39 = t59  &  t40 = (t61 -> t62)  &  t41 = (Void -> Void)  &  t56 = t65  &  t58 = Array  &  t60 = Int  &  t63 = Str  &  t64 = Str"})
    ║   ╟○ subject :decl(param) ::(t58) :annotations({"positional_index" => 0})
    ║   ╟○ tag :decl(param) ::(t59) :annotations({"positional_index" => 1})
    ║   ╟○ index :decl(param) ::(t60) :annotations({"positional_index" => 2})
    ║   ╙─call &ifTag ::(t65) :annotations({"inlined" => "&->#n"})
    ║     ├○ subject ::(t58)
    ║     ├○ tag ::(t59)
    ║     ├─:Block ::(t61 -> t62) :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical _ :decl(param))], "optional" => [], "constraints" => "t58 = Array  &  t60 = Int"})
    ║     │ ╟○ _ :decl(param) ::(t61) :annotations({"positional_index" => 0})
    ║     │ ╙─atpos ::(t62)
    ║     │   ├○ subject ::(t58)
    ║     │   └○ index ::(t60)
    ║     └─:Block ::(Void -> Void) :annotations({"named" => {}, "slurpy" => [], "positional" => [], "optional" => [], "constraints" => "t29 = Str  &  t29 = t59  &  t36 = t63  &  t36 = t64  &  t63 = Str  &  t64 = Str"})
    ║       ╙─die ::(Void)
    ║         └─concat ::(Str) :returns(str)
    ║           ├◙ SVal "ERROR: " ::(Str)
    ║           └─call &force ::(t64) :annotations({"forced" => QAST::Op(concat)})
    ║             └─concat ::(Str) :returns(str)
    ║               ├◙ SVal "no such tag: " ::(Str)
    ║               └─call &force ::(t63) :annotations({"forced" => QAST::Var(lexical tag)})
    ║                 └○ tag ::(t59)
    ╟─bind ::((t67 × t68) -> t117) :annotations({"constraints" => "t11 = t67  &  t14 = t67  &  t15 = Int  &  t29 = t67  &  t29 = t68  &  t29 = t84  &  t29 = t88  &  t29 = t103  &  t36 = t69  &  t36 = t96  &  t36 = t97  &  t36 = t98  &  t36 = t99  &  t36 = t104  &  t38 = t67  &  t39 = Str  &  t40 = (t72 -> t84)  &  t41 = t113  &  t56 = t114  &  t66 = ((t92 × Str) -> t100)  &  t67 = t69  &  t67 = t70  &  t67 = t110  &  t67 = t111  &  t67 = (Bool + Int + Num + Str + Array + (t108 -> t109))  &  t71 = Str  &  t71 = t115  &  t72 = Int  &  t74 = Array  &  t76 = Array  &  t78 = Str  &  t80 = Int  &  t82 = Int  &  t84 = Str  &  t86 = Str  &  t86 = Array  &  t86 = t105  &  t88 = Str  &  t90 = Int  &  t90 = Str  &  t93 = Str  &  t95 = (Bool + t93)  &  t96 = Str  &  t97 = Str  &  t98 = Str  &  t99 = Str  &  t100 = t102  &  t101 = Str  &  t103 = (t101 + t102)  &  t104 = Str  &  t106 = Str  &  t107 = Bool  &  t112 = (Void -> Str)  &  t113 = (t111 + t112)  &  t114 = t116  &  t117 = (t115 + t116)"})
    ║ ├○ &strOut :decl(static) ::((t67 × t68) -> t117)
    ║ └─:Block "&strOut" ::((t67 × t68) -> t117) :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical v :decl(param)), QAST::Var(lexical indent :decl(param))], "optional" => [], "constraints" => "t11 = t67  &  t14 = t67  &  t15 = Int  &  t29 = t67  &  t29 = t68  &  t29 = t84  &  t29 = t88  &  t29 = t103  &  t36 = t69  &  t36 = t96  &  t36 = t97  &  t36 = t98  &  t36 = t99  &  t36 = t104  &  t38 = t67  &  t39 = Str  &  t40 = (t72 -> t84)  &  t41 = t113  &  t56 = t114  &  t66 = ((t92 × Str) -> t100)  &  t67 = t69  &  t67 = t70  &  t67 = t110  &  t67 = t111  &  t67 = (Bool + Int + Num + Str + Array + (t108 -> t109))  &  t71 = Str  &  t71 = t115  &  t72 = Int  &  t74 = Array  &  t76 = Array  &  t78 = Str  &  t80 = Int  &  t82 = Int  &  t84 = Str  &  t86 = Str  &  t86 = Array  &  t86 = t105  &  t88 = Str  &  t90 = Int  &  t90 = Str  &  t93 = Str  &  t95 = (Bool + t93)  &  t96 = Str  &  t97 = Str  &  t98 = Str  &  t99 = Str  &  t100 = t102  &  t101 = Str  &  t103 = (t101 + t102)  &  t104 = Str  &  t106 = Str  &  t107 = Bool  &  t112 = (Void -> Str)  &  t113 = (t111 + t112)  &  t114 = t116  &  t117 = (t115 + t116)"})
    ║   ╟○ v :decl(param) ::(t67) :annotations({"positional_index" => 0})
    ║   ╟○ indent :decl(param) ::(t68) :annotations({"positional_index" => 1})
    ║   ╟─bind ::(t69)
    ║   ║ ├○ v ::(t67)
    ║   ║ └─call &force ::(t69) :annotations({"forced" => QAST::Var(lexical v)})
    ║   ║   └○ v ::(t67)
    ║   ╙─if ::(t117)
    ║     ├─isstr ::(Bool)
    ║     │ └○ v ::(t67)
    ║     ├─call &strLit ::(t71)
    ║     │ └○ v ::(t67)
    ║     └─call &ifTag ::(t114)
    ║       ├○ v ::(t67)
    ║       ├◙ SVal "λ" ::(Str)
    ║       ├─:Block ::(t72 -> t84) :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical id :decl(param))], "optional" => [], "constraints" => "t14 = t67  &  t15 = Int  &  t29 = t68  &  t29 = t84  &  t29 = t88  &  t29 = t103  &  t36 = t96  &  t36 = t97  &  t36 = t98  &  t36 = t99  &  t36 = t104  &  t66 = ((t92 × Str) -> t100)  &  t72 = Int  &  t74 = Array  &  t76 = Array  &  t78 = Str  &  t80 = Int  &  t82 = Int  &  t84 = Str  &  t86 = Str  &  t86 = Array  &  t86 = t105  &  t88 = Str  &  t90 = Int  &  t90 = Str  &  t93 = Str  &  t95 = (Bool + t93)  &  t96 = Str  &  t97 = Str  &  t98 = Str  &  t99 = Str  &  t100 = t102  &  t101 = Str  &  t103 = (t101 + t102)  &  t104 = Str  &  t106 = Str  &  t107 = Bool"})
    ║       │ ╟○ id :decl(param) ::(t72) :annotations({"positional_index" => 0})
    ║       │ ╟─bind ::(t74)
    ║       │ ║ ├○ fvars :decl(var) ::(t74)
    ║       │ ║ └─call &sublist ::(t74)
    ║       │ ║   ├○ v ::(t67)
    ║       │ ║   └◙ IVal 2 ::(Int)
    ║       │ ╟─bind ::(t76)
    ║       │ ║ ├○ info :decl(var) ::(t76)
    ║       │ ║ └─atpos ::(t76)
    ║       │ ║   ├○ .λinfo ::(Array)
    ║       │ ║   └○ id ::(t72)
    ║       │ ╟─bind ::(Array)
    ║       │ ║ ├○ fvn2dBI :decl(var) ::(Array)
    ║       │ ║ └─split ::(Array)
    ║       │ ║   ├◙ SVal " " ::(Str)
    ║       │ ║   └─atpos ::(t78)
    ║       │ ║     ├○ info ::(t76)
    ║       │ ║     └◙ IVal 3 ::(Int)
    ║       │ ╟─bind ::(t80)
    ║       │ ║ ├○ from :decl(var) ::(t80)
    ║       │ ║ └─atpos ::(t80)
    ║       │ ║   ├○ info ::(t76)
    ║       │ ║   └◙ IVal 1 ::(Int)
    ║       │ ╟─bind ::(t82)
    ║       │ ║ ├○ length :decl(var) ::(t82)
    ║       │ ║ └─atpos ::(t82)
    ║       │ ║   ├○ info ::(t76)
    ║       │ ║   └◙ IVal 2 ::(Int)
    ║       │ ╟─bind ::(t84)
    ║       │ ║ ├○ src :decl(var) ::(t84)
    ║       │ ║ └─substr ::(t84)
    ║       │ ║   ├○ .src ::(Str)
    ║       │ ║   ├○ from ::(t80)
    ║       │ ║   └○ length ::(t82)
    ║       │ ╟─bind ::(Int)
    ║       │ ║ ├○ i :decl(var) ::(Int)
    ║       │ ║ └◙ IVal 0 ::(Int)
    ║       │ ╟─for ::(t107)
    ║       │ ║ ├○ fvn2dBI ::(Array)
    ║       │ ║ └─:Block ::(t86 -> Str) :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical pair :decl(param))], "optional" => [], "constraints" => "t29 = t68  &  t29 = t84  &  t29 = t88  &  t29 = t103  &  t36 = t96  &  t36 = t97  &  t36 = t98  &  t36 = t99  &  t36 = t104  &  t66 = ((t92 × Str) -> t100)  &  t74 = Array  &  t84 = Str  &  t86 = Str  &  t86 = Array  &  t88 = Str  &  t90 = Int  &  t90 = Str  &  t93 = Str  &  t95 = (Bool + t93)  &  t96 = Str  &  t97 = Str  &  t98 = Str  &  t99 = Str  &  t100 = t102  &  t101 = Str  &  t103 = (t101 + t102)  &  t104 = Str"})
    ║       │ ║   ╟○ pair :decl(param) ::(t86) :annotations({"positional_index" => 0})
    ║       │ ║   ╟─bind ::(Array)
    ║       │ ║   ║ ├○ pair ::(t86)
    ║       │ ║   ║ └─split ::(Array)
    ║       │ ║   ║   ├◙ SVal "." ::(Str)
    ║       │ ║   ║   └○ pair ::(t86)
    ║       │ ║   ╟─bind ::(t88)
    ║       │ ║   ║ ├○ name :decl(var) ::(t88)
    ║       │ ║   ║ └─atpos ::(t88)
    ║       │ ║   ║   ├○ pair ::(t86)
    ║       │ ║   ║   └◙ IVal 0 ::(Int)
    ║       │ ║   ╟─bind ::(t90)
    ║       │ ║   ║ ├○ dBI :decl(var) ::(t90)
    ║       │ ║   ║ └─atpos ::(t90)
    ║       │ ║   ║   ├○ pair ::(t86)
    ║       │ ║   ║   └◙ IVal 1 ::(Int)
    ║       │ ║   ╟─bind ::(t92)
    ║       │ ║   ║ ├○ val :decl(var) ::(t92)
    ║       │ ║   ║ └─atpos ::(t92)
    ║       │ ║   ║   ├○ fvars ::(t74)
    ║       │ ║   ║   └○ i ::(Int)
    ║       │ ║   ╟─bind ::(Int)
    ║       │ ║   ║ ├○ i ::(Int)
    ║       │ ║   ║ └─add_i ::(Int)
    ║       │ ║   ║   ├○ i ::(Int)
    ║       │ ║   ║   └◙ IVal 1 ::(Int)
    ║       │ ║   ╟─if ::(t95)
    ║       │ ║   ║ ├─not_i ::(Int)
    ║       │ ║   ║ │ └○ dBI ::(t90)
    ║       │ ║   ║ └─bind ::(Str)
    ║       │ ║   ║   ├○ dBI ::(t90)
    ║       │ ║   ║   └◙ SVal "∞" ::(Str)
    ║       │ ║   ╙─bind ::(Str)
    ║       │ ║     ├○ src ::(t84)
    ║       │ ║     └─concat ::(Str) :returns(str)
    ║       │ ║       ├─concat ::(Str) :returns(str)
    ║       │ ║       │ ├─concat ::(Str) :returns(str)
    ║       │ ║       │ │ ├─concat ::(Str) :returns(str)
    ║       │ ║       │ │ │ ├─concat ::(Str) :returns(str)
    ║       │ ║       │ │ │ │ ├─concat ::(Str) :returns(str)
    ║       │ ║       │ │ │ │ │ ├─call &force ::(t96) :annotations({"forced" => QAST::Var(lexical src)})
    ║       │ ║       │ │ │ │ │ │ └○ src ::(t84)
    ║       │ ║       │ │ │ │ │ └◙ SVal "\n" ::(Str)
    ║       │ ║       │ │ │ │ └─call &force ::(t97) :annotations({"forced" => QAST::Var(lexical indent)})
    ║       │ ║       │ │ │ │   └○ indent ::(t68)
    ║       │ ║       │ │ │ └◙ SVal "# where " ::(Str)
    ║       │ ║       │ │ └─call &force ::(t98) :annotations({"forced" => QAST::Var(lexical name)})
    ║       │ ║       │ │   └○ name ::(t88)
    ║       │ ║       │ └◙ SVal " = " ::(Str)
    ║       │ ║       └─call &force ::(t104) :annotations({"forced" => QAST::Op(if)})
    ║       │ ║         └─if ::(t103)
    ║       │ ║           ├─iseq_s ::(Bool)
    ║       │ ║           │ ├○ name ::(t88)
    ║       │ ║           │ └◙ SVal "self" ::(Str)
    ║       │ ║           ├◙ SVal "..." ::(Str)
    ║       │ ║           └─call &strOut ::(t100)
    ║       │ ║             ├○ val ::(t92)
    ║       │ ║             └─concat ::(Str) :returns(str)
    ║       │ ║               ├─call &force ::(t99) :annotations({"forced" => QAST::Var(lexical indent)})
    ║       │ ║               │ └○ indent ::(t68)
    ║       │ ║               └◙ SVal "#           " ::(Str)
    ║       │ ╙○ src ::(t84)
    ║       └─if ::(t113)
    ║         ├─isint ::(Bool)
    ║         │ └○ v ::(t67)
    ║         ├○ v ::(t67)
    ║         └─:Block ::(Void -> Str) :annotations({"named" => {}, "slurpy" => [], "positional" => [], "optional" => [], "delayed" => "simple", "constraints" => "t67 = t110"})
    ║           ╙─reprname ::(Str)
    ║             └○ v ::(t67)
    ╟─bind ::(t119 -> Void -> t125) :annotations({"constraints" => "t119 = (Void -> t122)  &  t121 = t122  &  t121 = t123  &  t122 = t124  &  t125 = (t123 + t124)"})
    ║ ├○ &delayMemo :decl(static) ::(t119 -> Void -> t125)
    ║ └─:Block "&delayMemo" ::(t119 -> Void -> t125) :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical x :decl(param))], "optional" => [], "constraints" => "t119 = (Void -> t122)  &  t121 = t122  &  t121 = t123  &  t122 = t124  &  t125 = (t123 + t124)"})
    ║   ╟○ x :decl(param) ::(t119) :annotations({"positional_index" => 0})
    ║   ╟─bind ::(Int)
    ║   ║ ├○ wasRun :decl(var) ::(Int)
    ║   ║ └◙ IVal 0 ::(Int)
    ║   ╟○ result :decl(var) ::(t121)
    ║   ╙─:Block ::(Void -> t125) :annotations({"named" => {}, "slurpy" => [], "positional" => [], "optional" => [], "constraints" => "t119 = (Void -> t122)  &  t121 = t122  &  t121 = t123  &  t122 = t124  &  t125 = (t123 + t124)"})
    ║     ╙─if ::(t125)
    ║       ├○ wasRun ::(Int)
    ║       ├○ result ::(t121)
    ║       └─:Stmts ::(t122)
    ║         ├─bind ::(Int)
    ║         │ ├○ wasRun ::(Int)
    ║         │ └◙ IVal 1 ::(Int)
    ║         └─bind ::(t122)
    ║           ├○ result ::(t121)
    ║           └─call x ::(t122)
    ╟─bind
    ║ ├○ &say :decl(static) ::(t126)
    ║ └─:Block "&say" :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical v :decl(param))], "optional" => []})
    ║   ╟○ v :decl(param) ::(t127) :annotations({"positional_index" => 0})
    ║   ╟─bind ::(t128)
    ║   ║ ├○ v ::(t127)
    ║   ║ └─call &force ::(t128) :annotations({"forced" => QAST::Var(lexical v)})
    ║   ║   └○ v ::(t127)
    ║   ╙─say
    ║     └─if ::(t133)
    ║       ├─isstr ::(Bool)
    ║       │ └○ v ::(t127)
    ║       ├○ v ::(t127)
    ║       └─call &strOut ::(t130)
    ║         ├○ v ::(t127)
    ║         └◙ SVal "" ::(Str)
    ╟─bind
    ║ ├○ &apply1 :decl(static)
    ║ └─:Block "&apply1"
    ║   ╟○ f :decl(param) :annotations({"positional_index" => 0})
    ║   ╟○ a1 :decl(param) :annotations({"positional_index" => 1})
    ║   ╟○ result :decl(var)
    ║   ╟─bind
    ║   ║ ├○ f
    ║   ║ └─call &force :annotations({"forced" => QAST::Var(lexical f)})
    ║   ║   └○ f
    ║   ╟─bind
    ║   ║ ├○ result
    ║   ║ └─call
    ║   ║   ├─defor
    ║   ║   │ ├─call &ifTag ::(t65) :annotations({"inlined" => "&->#n"})
    ║   ║   │ │ ├○ f
    ║   ║   │ │ ├◙ SVal "λ"
    ║   ║   │ │ ├─:Block ::(t61 -> t62) :annotations({"named" => {}, "slurpy" => [], "positional" => [QAST::Var(lexical _ :decl(param))], "optional" => [], "constraints" => "t58 = Array  &  t60 = Int"})
    ║   ║   │ │ │ ╟○ _ :decl(param) ::(t61) :annotations({"positional_index" => 0})
    ║   ║   │ │ │ ╙─atpos ::(t62)
    ║   ║   │ │ │   ├○ f
    ║   ║   │ │ │   └◙ IVal 1
    ║   ║   │ │ └─:Block ::(Void -> Void) :annotations({"named" => {}, "slurpy" => [], "positional" => [], "optional" => [], "constraints" => "t29 = Str  &  t29 = t59  &  t36 = t63  &  t36 = t64  &  t63 = Str  &  t64 = Str"})
    ║   ║   │ │   ╙─die ::(Void)
    ║   ║   │ │     └─concat ::(Str) :returns(str)
    ║   ║   │ │       ├◙ SVal "ERROR: " ::(Str)
    ║   ║   │ │       └─call &force ::(t64) :annotations({"forced" => QAST::Op(concat)})
    ║   ║   │ │         └─concat ::(Str) :returns(str)
    ║   ║   │ │           ├◙ SVal "no such tag: " ::(Str)
    ║   ║   │ │           └─call &force ::(t63) :annotations({"forced" => QAST::Var(lexical tag)})
    ║   ║   │ │             └◙ SVal "λ"
    ║   ║   │ └─die
    ║   ║   │   └─concat :returns(str)
    ║   ║   │     ├─concat :returns(str)
    ║   ║   │     │ ├─concat :returns(str)
    ║   ║   │     │ │ ├◙ SVal "ERROR: cannot apply "
    ║   ║   │     │ │ └─call &force :annotations({"forced" => QAST::Op(call &strOut)})
    ║   ║   │     │ │   └─call &strOut
    ║   ║   │     │ │     ├○ f
    ║   ║   │     │ │     └◙ SVal ""
    ║   ║   │     │ └◙ SVal " to "
    ║   ║   │     └─call &force :annotations({"forced" => QAST::Op(call &strOut)})
    ║   ║   │       └─call &strOut
    ║   ║   │         ├○ a1
    ║   ║   │         └◙ SVal ""
    ║   ║   └○ a1
    ║   ╙─call &force :annotations({"forced" => QAST::Var(lexical result)})
    ║     └○ result
    ╟─bind
    ║ ├○ .qastSize :decl(static)
    ║ └◙ NVal 383
    ╟─bind
    ║ ├○ .blockCount :decl(static)
    ║ └◙ NVal 21
    ╟─bind
    ║ ├○ .listCount :decl(static)
    ║ └◙ NVal 6
    ╟─bind
    ║ ├○ .ivalCount :decl(static)
    ║ └◙ NVal 23
    ╟─bind
    ║ ├○ .svalCount :decl(static)
    ║ └◙ NVal 30
    ╟─bind
    ║ ├○ .svalSize :decl(static)
    ║ └◙ NVal 697
    ╙─:Block :blocktype(immediate)
      ╟○ local mainResult :decl(var)
      ╟─bind
      ║ ├○ local mainResult
      ║ └─call &strOut
      ║   ├─call &apply1 :annotations({"FV" => {}})  ««"(λx.x) λx.x"
      ║   │ ├─list :annotations({"parent" => QAST::Op(call &apply1), "infoIdx" => 0, "FV" => {}})  ««"λx.x"
      ║   │ │ ├◙ SVal "λ0"
      ║   │ │ └─:Block  ««"x"
      ║   │ │   ╟○ x :decl(param)
      ║   │ │   ╙○ x :annotations({"parent" => QAST::Op(list), "bound_at" => QAST::Op(list), "deBruijnIdx" => 1, "FV" => {"x" => [QAST::Var(lexical x)]}})
      ║   │ └─call &delayMemo :annotations({"delayed" => "memo"})  ««"λx.x"
      ║   │   └─:Block :annotations({"delayed" => "simple"})
      ║   │     ╙─list :annotations({"parent" => QAST::Op(call &apply1), "infoIdx" => 1, "FV" => {}})  ««"λx.x"
      ║   │       ├◙ SVal "λ1"
      ║   │       └─:Block  ««"x"
      ║   │         ╟○ x :decl(param)
      ║   │         ╙○ x :annotations({"parent" => QAST::Op(list), "bound_at" => QAST::Op(list), "deBruijnIdx" => 1, "FV" => {"x" => [QAST::Var(lexical x)]}})
      ║   └◙ SVal ""
      ╙○ local mainResult