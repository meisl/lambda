## (Yet another) λ calculator...

Recently I came across Shriram Krishnamurthi's lectures on YouTube [TODO: ref].
The course is called "Introduction to Programming Languages"
and he's written a textbook for it, "Programming Languages: Application and Interpretation" which can be downloaded for free [TODO: ref].

While watching - and he's great teacher! - I said to myself: "Well, I should *really*
write my own programming language, eventually".

[TODO: not a new thought ... always wanted to do that ... well, ok, not so special I guess...]

[TODO: the course is using Racket [TODO: ref], 
which is derived from Scheme, 
which is derived from LISP,
which very closely resembles λ calculus]

[TODO: Then I watched the "Lambda lecture" in the series, 
where Krishnamurthi gives a glance of how (principally) *anything* except pure λ calculus can be dispensed with.

I thought: "Well, sure; have heard all this before - but still, it's fascinating! Still and again. I *must* really try it out myself, sometime..."
]

So well, I grabbed the good old "Dragon Book" [TODO: ref].
And once again, while reading, I said to myself: "It's all not that hard, really. Why the hell haven't I written
my own programming language yet?!".
Which, of course, I've been saying to myself ever since I first read it...

BTW: YouTube also has videos of the old 80's lectures of ... and ... on which the Dragon
Book is based.

Then I pulled out Graham Hutton's "Programming in Haskell" [TODO: ref, YouTube again],
only to reach - shortly thereafter - for 
"Lambda-Calculus and Combinators - an Introduction" by Hindley & Seldin [TODO: ref].

So, finally, I'm giving it a try now. 

[TODO: why use Perl6?]

[TODO: link to Lambda-Intro.md, "covering pure λ with β/η-reduction and α-conversion]
