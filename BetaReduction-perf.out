---------- run perl6-m ----------
1..5
# CurryStats: ( 3p,     85f,  0o,  178+5i)
#    30 (  1):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#     9 (  1):          VarT => ( 0p,      9f,  0o,    1+ 0i :(Str -> TTerm))
#     2 (  2):             K => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu)),           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu))
#     0 ( 13):             I => ( 0p,      0f,  0o,    1+ 0i :(Mu -> Mu)),         #true => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),        #false => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),           _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),          _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),       Str-eq? => ( 0p,      0f,  0o,    1+ 0i :(Str -> Mu)),           nil => ( 0p,      0f,  0o,    1+ 0i TList:(Callable -> Mu)),          cons => ( 0p,      0f,  0o,    1+ 0i :(Mu -> TList -> Mu)),          AppT => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)),          LamT => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)),      Term-eq? => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool)),  Term->source => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> Str))
ok 1 - (x x) reduces to itself (sanity check)
ok 2 - ((λx.x) x) reduces to x (sanity check)
ok 3 - $bigTerm.lambda is (λf1.(λf2.(λf3.(λf4.(λf5.((λy.(λ_.y)) ((λg.(λh.((λy.(λ_.y)) (g h)))) ((λg.(λh.((λy.(λ_.y)) (g h)))) (λk.(((λk.(((λk.(((λk.(((λk.(((λx.x) k) f1)) k) f2)) k) f3)) k) f4)) k) f5))))))))))
ok 4 - $expectedTerm.lambda is (λf1.(λf2.(λf3.(λf4.(λf5.(λ_.(λh.(λ_.(λ_.(((((h f1) f2) f3) f4) f5))))))))))
# CurryStats: ( 3p,    615f,  1o,  263+5i)
#   112 (  1):  Term->source => ( 0p,    112f,  0o,    1+ 0i :(TTerm -> Str))
#    59 (  1):             I => ( 0p,     59f,  0o,    1+ 0i :(Mu -> Mu))
#    31 (  1):          LamT => ( 0p,     31f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    30 (  1):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    24 (  1):          AppT => ( 0p,     24f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#    17 (  1):           _if => ( 0p,     17f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu))
#    14 (  1):          VarT => ( 0p,     14f,  0o,    1+ 0i :(Str -> TTerm))
#    12 (  1):        #false => ( 0p,     12f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#     7 (  1):         #true => ( 0p,      7f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#     5 (  2):             K => ( 0p,      5f,  0o,    1+ 0i :(Mu -> Mu)),           nil => ( 0p,      5f,  0o,    1+ 0i TList:(Callable -> Mu))
#     2 (  2):           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu)),          cons => ( 0p,      2f,  0o,    1+ 0i :(Mu -> TList -> Mu))
#     1 (  2):       Str-eq? => ( 0p,      1f,  0o,    1+ 0i :(Str -> Mu)),      Term-eq? => ( 0p,      1f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#     0 (  2):          _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu))
# 13.2 sec consumed for β-reduction
ok 5 - $bigTerm reduces to (λf1.(λf2.(λf3.(λf4.(λf5.(λ_.(λh.(λ_.(λ_.(((((h f1) f2) f3) f4) f5))))))))))
# CurryStats: (29p,  12415f, 19o, 2097+5i)
#  1441 (  1):           _if => ( 0p,   1441f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu))
#   891 (  1):        #false => ( 0p,    891f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   712 (  1):         #true => ( 0p,    712f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   157 (  1):           nil => ( 0p,    157f,  0o,    1+ 0i TList:(Callable -> Mu))
#   141 (  1):  Term->source => ( 0p,    141f,  0o,    1+ 0i :(TTerm -> Str))
#   132 (  1):          LamT => ( 0p,    132f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#   112 (  1):          cons => ( 0p,    112f,  0o,    1+ 0i :(Mu -> TList -> Mu))
#   107 (  1):             K => ( 0p,    107f,  0o,    1+ 0i :(Mu -> Mu))
#    96 (  1):             I => ( 0p,     96f,  0o,    1+ 0i :(Mu -> Mu))
#    40 (  1):          AppT => (16p,     40f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    30 (  2):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),      Term-eq? => ( 0p,     30f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#    26 (  1):          _and => ( 0p,     26f,  0o,    1+ 0i :(TBool -> TBool -> Mu))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#    16 (  1):       Str-eq? => ( 0p,     16f,  0o,    1+ 0i :(Str -> Mu))
#    14 (  1):          VarT => ( 0p,     14f,  0o,    1+ 0i :(Str -> TTerm))
#     2 (  1):           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu))
#     0 (  1):           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu))

Output completed (42 sec consumed) - Normal Termination





---------- run perl6-m ----------
1..5
# CurryStats: ( 3p,     85f,  0o,  178+5i)
#    30 (  1):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#     9 (  1):          VarT => ( 0p,      9f,  0o,    1+ 0i :(Str -> TTerm))
#     2 (  2):             K => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu)),           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu))
#     0 ( 13):             I => ( 0p,      0f,  0o,    1+ 0i :(Mu -> Mu)),         #true => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),        #false => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),           _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),          _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),       Str-eq? => ( 0p,      0f,  0o,    1+ 0i :(Str -> Mu)),           nil => ( 0p,      0f,  0o,    1+ 0i TList:(Callable -> Mu)),          cons => ( 0p,      0f,  0o,    1+ 0i :(Mu -> TList -> Mu)),          AppT => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)),          LamT => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)),      Term-eq? => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool)),  Term->source => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> Str))
ok 1 - (x x) reduces to itself (sanity check)
ok 2 - ((λx.x) x) reduces to x (sanity check)
ok 3 - $bigTerm.lambda is (λf1.(λf2.(λf3.(λf4.(λf5.((λy.(λ_.y)) ((λg.(λh.((λy.(λ_.y)) (g h)))) ((λg.(λh.((λy.(λ_.y)) (g h)))) (λk.(((λk.(((λk.(((λk.(((λk.(((λx.x) k) f1)) k) f2)) k) f3)) k) f4)) k) f5))))))))))
ok 4 - $expectedTerm.lambda is (λf1.(λf2.(λf3.(λf4.(λf5.(λ_.(λh.(λ_.(λ_.(((((h f1) f2) f3) f4) f5))))))))))
# CurryStats: ( 3p,    612f,  1o,  262+5i)
#   112 (  1):  Term->source => ( 0p,    112f,  0o,    1+ 0i :(TTerm -> Str))
#    59 (  1):             I => ( 0p,     59f,  0o,    1+ 0i :(Mu -> Mu))
#    31 (  1):          LamT => ( 0p,     31f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    30 (  1):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    24 (  1):          AppT => ( 0p,     24f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#    16 (  1):           _if => ( 0p,     16f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu))
#    14 (  1):          VarT => ( 0p,     14f,  0o,    1+ 0i :(Str -> TTerm))
#    12 (  1):        #false => ( 0p,     12f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#     7 (  1):         #true => ( 0p,      7f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#     5 (  1):           nil => ( 0p,      5f,  0o,    1+ 0i TList:(Callable -> Mu))
#     4 (  1):             K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu))
#     2 (  2):           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu)),          cons => ( 0p,      2f,  0o,    1+ 0i :(Mu -> TList -> Mu))
#     1 (  2):       Str-eq? => ( 0p,      1f,  0o,    1+ 0i :(Str -> Mu)),      Term-eq? => ( 0p,      1f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#     0 (  2):          _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu))
# 13.2 sec consumed for β-reduction
ok 5 - $bigTerm reduces to (λf1.(λf2.(λf3.(λf4.(λf5.(λ_.(λh.(λ_.(λ_.(((((h f1) f2) f3) f4) f5))))))))))
# CurryStats: (29p,  12376f, 19o, 2084+5i)
#  1428 (  1):           _if => ( 0p,   1428f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu))
#   891 (  1):        #false => ( 0p,    891f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   712 (  1):         #true => ( 0p,    712f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   475 (  2):         π1->1 => ( 0p,    475f,  0o,    0+ 0i :(Mu -> Mu)),    VarT->name => ( 0p,    475f,  0o,    0+ 0i :(TTerm -> Mu))
#   430 (  1):        if-nil => ( 0p,    430f,  0o,    1+ 0i :(TList -> Callable -> Callable -> Mu))
#   328 (  1):      Mu -> Mu => ( 0p,    328f,  0o,    1+ 0i :(Mu -> Mu))
#   255 (  1):        exists => ( 0p,    255f,  0o,    2+ 0i :(Callable -> TList -> Mu))
#   224 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,    224f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   175 (  1):   free-under? => ( 0p,    175f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm -> Mu))
#   174 (  1): free-vars-internal => ( 1p,    174f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList))
#   157 (  1):           nil => ( 0p,    157f,  0o,    1+ 0i TList:(Callable -> Mu))
#   148 (  1):          Some => ( 0p,    148f,  0o,    1+ 0i :(Mu -> Mu))
#   147 (  1):  betaContract => ( 0p,    147f,  0o,    2+ 0i :(TTerm -> Mu))
#   145 (  1):         π2->1 => ( 0p,    145f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   141 (  1):  Term->source => ( 0p,    141f,  0o,    1+ 0i :(TTerm -> Str))
#   132 (  2):          LamT => ( 0p,    132f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)), Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,    132f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   122 (  4):         π3->1 => ( 0p,    122f,  0o,    1+ 0i :(Mu -> Mu -> Mu -> Mu)),           not => ( 0p,    122f,  0o,    1+ 0i :(TBool -> Mu)),          nil? => ( 0p,    122f,  0o,    1+ 0i :(TList -> Mu)),     subst-seq => ( 0p,    122f,  0o,    1+ 0i :(TTerm -> TList -> Mu))
#   118 (  1):         π2->2 => ( 0p,    118f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   112 (  1):          cons => ( 0p,    112f,  0o,    1+ 0i :(Mu -> TList -> Mu))
#   105 (  1): Mu -> Mu -> Mu => ( 0p,    105f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   104 (  1):          None => ( 0p,    104f,  0o,    1+ 0i TMaybe:(Mu -> Mu -> Mu))
#   103 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,    103f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    96 (  1):             I => ( 0p,     96f,  0o,    1+ 0i :(Mu -> Mu))
#    94 (  1):             K => ( 0p,     94f,  0o,    1+ 0i :(Mu -> Mu))
#    93 (  1):      Mu -> Mu => ( 0p,     93f,  0o,    1+ 0i :(Mu -> Mu))
#    88 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     88f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    83 (  2):       ConstT? => ( 0p,     83f,  0o,    0+ 0i :(TTerm -> Mu)),         VarT? => ( 0p,     83f,  0o,    0+ 0i :(TTerm -> Mu))
#    74 (  2):         None? => ( 0p,     74f,  0o,    1+ 0i :(TMaybe -> Mu)), Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     74f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    67 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     67f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    62 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     62f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    57 (  3):     foldr-rec => ( 0p,     57f,  0o,    1+ 0i :(Callable -> Mu -> TList -> Mu)),     Pair->fst => ( 0p,     57f,  0o,    1+ 0i :(TPair -> Mu)), Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     57f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    52 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     52f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    50 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    40 (  1):          AppT => (16p,     40f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    30 (  2):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),      Term-eq? => ( 0p,     30f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#    26 (  1):          _and => ( 0p,     26f,  0o,    1+ 0i :(TBool -> TBool -> Mu))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#    16 (  1):       Str-eq? => ( 0p,     16f,  0o,    1+ 0i :(Str -> Mu))
#    14 (  1):          VarT => ( 0p,     14f,  0o,    1+ 0i :(Str -> TTerm))
#     2 (  1):           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu))
#     0 (  1):           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu))

Output completed (43 sec consumed) - Normal Termination




---------- run perl6-m ----------
1..5
# CurryStats: ( 3p,     85f,  0o,  178+5i)
#    30 (  1):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#     9 (  1):          VarT => ( 0p,      9f,  0o,    1+ 0i :(Str -> TTerm))
#     2 (  2):             K => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu)),           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu))
#     0 ( 13):             I => ( 0p,      0f,  0o,    1+ 0i :(Mu -> Mu)),         #true => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),        #false => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),           _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),          _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),       Str-eq? => ( 0p,      0f,  0o,    1+ 0i :(Str -> Mu)),           nil => ( 0p,      0f,  0o,    1+ 0i TList:(Callable -> Mu)),          cons => ( 0p,      0f,  0o,    1+ 0i :(Mu -> TList -> Mu)),          AppT => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)),          LamT => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)),      Term-eq? => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool)),  Term->source => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> Str))
ok 1 - (x x) reduces to itself (sanity check)
ok 2 - ((λx.x) x) reduces to x (sanity check)
ok 3 - $bigTerm.lambda is (λf1.(λf2.(λf3.(λf4.(λf5.((λy.(λ_.y)) ((λg.(λh.((λy.(λ_.y)) (g h)))) ((λg.(λh.((λy.(λ_.y)) (g h)))) (λk.(((λk.(((λk.(((λk.(((λk.(((λx.x) k) f1)) k) f2)) k) f3)) k) f4)) k) f5))))))))))
ok 4 - $expectedTerm.lambda is (λf1.(λf2.(λf3.(λf4.(λf5.(λ_.(λh.(λ_.(λ_.(((((h f1) f2) f3) f4) f5))))))))))
# CurryStats: ( 3p,    610f,  1o,  261+5i)
#   112 (  1):  Term->source => ( 0p,    112f,  0o,    1+ 0i :(TTerm -> Str))
#    59 (  1):             I => ( 0p,     59f,  0o,    1+ 0i :(Mu -> Mu))
#    31 (  1):          LamT => ( 0p,     31f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    30 (  1):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    24 (  1):          AppT => ( 0p,     24f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#    15 (  1):           _if => ( 0p,     15f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu))
#    14 (  1):          VarT => ( 0p,     14f,  0o,    1+ 0i :(Str -> TTerm))
#    12 (  1):        #false => ( 0p,     12f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#     7 (  1):         #true => ( 0p,      7f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#     5 (  1):           nil => ( 0p,      5f,  0o,    1+ 0i TList:(Callable -> Mu))
#     4 (  1):             K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu))
#     2 (  2):           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu)),          cons => ( 0p,      2f,  0o,    1+ 0i :(Mu -> TList -> Mu))
#     1 (  2):       Str-eq? => ( 0p,      1f,  0o,    1+ 0i :(Str -> Mu)),      Term-eq? => ( 0p,      1f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#     0 (  2):          _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu))
# 12.2 sec consumed for β-reduction
ok 5 - $bigTerm reduces to (λf1.(λf2.(λf3.(λf4.(λf5.(λ_.(λh.(λ_.(λ_.(((((h f1) f2) f3) f4) f5))))))))))
# CurryStats: (29p,  11892f, 19o, 1884+5i)
#  1186 (  1):           _if => ( 0p,   1186f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu))
#   891 (  1):        #false => ( 0p,    891f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   712 (  1):         #true => ( 0p,    712f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   475 (  2):         π1->1 => ( 0p,    475f,  0o,    0+ 0i :(Mu -> Mu)),    VarT->name => ( 0p,    475f,  0o,    0+ 0i :(TTerm -> Mu))
#   430 (  1):        if-nil => ( 0p,    430f,  0o,    1+ 0i :(TList -> Callable -> Callable -> Mu))
#   328 (  1):      Mu -> Mu => ( 0p,    328f,  0o,    1+ 0i :(Mu -> Mu))
#   255 (  1):        exists => ( 0p,    255f,  0o,    2+ 0i :(Callable -> TList -> Mu))
#   224 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,    224f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   175 (  1):   free-under? => ( 0p,    175f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm -> Mu))
#   174 (  1): free-vars-internal => ( 1p,    174f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList))
#   157 (  1):           nil => ( 0p,    157f,  0o,    1+ 0i TList:(Callable -> Mu))
#   148 (  1):          Some => ( 0p,    148f,  0o,    1+ 0i :(Mu -> Mu))
#   147 (  1):  betaContract => ( 0p,    147f,  0o,    2+ 0i :(TTerm -> Mu))
#   145 (  1):         π2->1 => ( 0p,    145f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   141 (  1):  Term->source => ( 0p,    141f,  0o,    1+ 0i :(TTerm -> Str))
#   132 (  2):          LamT => ( 0p,    132f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)), Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,    132f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   122 (  4):         π3->1 => ( 0p,    122f,  0o,    1+ 0i :(Mu -> Mu -> Mu -> Mu)),           not => ( 0p,    122f,  0o,    1+ 0i :(TBool -> Mu)),          nil? => ( 0p,    122f,  0o,    1+ 0i :(TList -> Mu)),     subst-seq => ( 0p,    122f,  0o,    1+ 0i :(TTerm -> TList -> Mu))
#   118 (  1):         π2->2 => ( 0p,    118f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   112 (  1):          cons => ( 0p,    112f,  0o,    1+ 0i :(Mu -> TList -> Mu))
#   105 (  1): Mu -> Mu -> Mu => ( 0p,    105f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   104 (  1):          None => ( 0p,    104f,  0o,    1+ 0i TMaybe:(Mu -> Mu -> Mu))
#   103 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,    103f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    96 (  1):             I => ( 0p,     96f,  0o,    1+ 0i :(Mu -> Mu))
#    94 (  1):             K => ( 0p,     94f,  0o,    1+ 0i :(Mu -> Mu))
#    88 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     88f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    83 (  2):       ConstT? => ( 0p,     83f,  0o,    0+ 0i :(TTerm -> Mu)),         VarT? => ( 0p,     83f,  0o,    0+ 0i :(TTerm -> Mu))
#    74 (  2):         None? => ( 0p,     74f,  0o,    1+ 0i :(TMaybe -> Mu)), Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     74f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    67 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     67f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    62 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     62f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    57 (  3):     foldr-rec => ( 0p,     57f,  0o,    1+ 0i :(Callable -> Mu -> TList -> Mu)),     Pair->fst => ( 0p,     57f,  0o,    1+ 0i :(TPair -> Mu)), Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     57f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    52 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     52f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    51 (  1):      Mu -> Mu => ( 0p,     51f,  0o,    1+ 0i :(Mu -> Mu))
#    50 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    40 (  1):          AppT => (16p,     40f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    30 (  2):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),      Term-eq? => ( 0p,     30f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#    26 (  1):          _and => ( 0p,     26f,  0o,    1+ 0i :(TBool -> TBool -> Mu))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#    16 (  1):       Str-eq? => ( 0p,     16f,  0o,    1+ 0i :(Str -> Mu))
#    14 (  1):          VarT => ( 0p,     14f,  0o,    1+ 0i :(Str -> TTerm))
#     2 (  1):           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu))
#     0 (  1):           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu))

Output completed (41 sec consumed) - Normal Termination




---------- run perl6-m ----------
1..5
# CurryStats: ( 3p,     85f,  0o,  178+5i)
#    30 (  1):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#     9 (  1):          VarT => ( 0p,      9f,  0o,    1+ 0i :(Str -> TTerm))
#     2 (  2):             K => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu)),           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu))
#     0 ( 13):             I => ( 0p,      0f,  0o,    1+ 0i :(Mu -> Mu)),         #true => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),        #false => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),           _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),          _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),       Str-eq? => ( 0p,      0f,  0o,    1+ 0i :(Str -> Mu)),           nil => ( 0p,      0f,  0o,    1+ 0i TList:(Callable -> Mu)),          cons => ( 0p,      0f,  0o,    1+ 0i :(Mu -> TList -> Mu)),          AppT => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)),          LamT => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)),      Term-eq? => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool)),  Term->source => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> Str))
ok 1 - (x x) reduces to itself (sanity check)
ok 2 - ((λx.x) x) reduces to x (sanity check)
ok 3 - $bigTerm.lambda is (λf1.(λf2.(λf3.(λf4.(λf5.((λy.(λ_.y)) ((λg.(λh.((λy.(λ_.y)) (g h)))) ((λg.(λh.((λy.(λ_.y)) (g h)))) (λk.(((λk.(((λk.(((λk.(((λk.(((λx.x) k) f1)) k) f2)) k) f3)) k) f4)) k) f5))))))))))
ok 4 - $expectedTerm.lambda is (λf1.(λf2.(λf3.(λf4.(λf5.(λ_.(λh.(λ_.(λ_.(((((h f1) f2) f3) f4) f5))))))))))
# CurryStats: ( 3p,    600f,  1o,  258+5i)
#   112 (  1):  Term->source => ( 0p,    112f,  0o,    1+ 0i :(TTerm -> Str))
#    59 (  1):             I => ( 0p,     59f,  0o,    1+ 0i :(Mu -> Mu))
#    31 (  1):          LamT => ( 0p,     31f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    30 (  1):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    24 (  1):          AppT => ( 0p,     24f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#    14 (  1):          VarT => ( 0p,     14f,  0o,    1+ 0i :(Str -> TTerm))
#    12 (  1):        #false => ( 0p,     12f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#     8 (  1):           _if => ( 0p,      8f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu))
#     7 (  1):         #true => ( 0p,      7f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#     5 (  1):           nil => ( 0p,      5f,  0o,    1+ 0i TList:(Callable -> Mu))
#     4 (  1):             K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu))
#     2 (  3):           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu)),       Str-eq? => ( 0p,      2f,  0o,    1+ 0i :(Str -> Mu)),          cons => ( 0p,      2f,  0o,    1+ 0i :(Mu -> TList -> Mu))
#     1 (  1):      Term-eq? => ( 0p,      1f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#     0 (  2):          _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu)),           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu))
# 11 sec consumed for β-reduction
ok 5 - $bigTerm reduces to (λf1.(λf2.(λf3.(λf4.(λf5.(λ_.(λh.(λ_.(λ_.(((((h f1) f2) f3) f4) f5))))))))))
# CurryStats: (29p,  11150f, 19o, 1572+5i)
#   891 (  1):        #false => ( 0p,    891f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   756 (  1):           _if => ( 0p,    756f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu))
#   712 (  1):         #true => ( 0p,    712f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   475 (  2):         π1->1 => ( 0p,    475f,  0o,    0+ 0i :(Mu -> Mu)),    VarT->name => ( 0p,    475f,  0o,    0+ 0i :(TTerm -> Mu))
#   430 (  1):        if-nil => ( 0p,    430f,  0o,    1+ 0i :(TList -> Callable -> Callable -> Mu))
#   328 (  1):      Mu -> Mu => ( 0p,    328f,  0o,    1+ 0i :(Mu -> Mu))
#   255 (  1):        exists => ( 0p,    255f,  0o,    2+ 0i :(Callable -> TList -> Mu))
#   224 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,    224f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   175 (  1):   free-under? => ( 0p,    175f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm -> Mu))
#   174 (  1): free-vars-internal => ( 1p,    174f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList))
#   157 (  1):           nil => ( 0p,    157f,  0o,    1+ 0i TList:(Callable -> Mu))
#   148 (  1):          Some => ( 0p,    148f,  0o,    1+ 0i :(Mu -> Mu))
#   147 (  1):  betaContract => ( 0p,    147f,  0o,    2+ 0i :(TTerm -> Mu))
#   145 (  1):         π2->1 => ( 0p,    145f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   141 (  1):  Term->source => ( 0p,    141f,  0o,    1+ 0i :(TTerm -> Str))
#   132 (  2):          LamT => ( 0p,    132f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)), Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,    132f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   122 (  4):         π3->1 => ( 0p,    122f,  0o,    1+ 0i :(Mu -> Mu -> Mu -> Mu)),           not => ( 0p,    122f,  0o,    1+ 0i :(TBool -> Mu)),          nil? => ( 0p,    122f,  0o,    1+ 0i :(TList -> Mu)),     subst-seq => ( 0p,    122f,  0o,    1+ 0i :(TTerm -> TList -> Mu))
#   118 (  1):         π2->2 => ( 0p,    118f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   112 (  1):          cons => ( 0p,    112f,  0o,    1+ 0i :(Mu -> TList -> Mu))
#   105 (  1): Mu -> Mu -> Mu => ( 0p,    105f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   104 (  1):          None => ( 0p,    104f,  0o,    1+ 0i TMaybe:(Mu -> Mu -> Mu))
#   103 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,    103f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    96 (  1):             I => ( 0p,     96f,  0o,    1+ 0i :(Mu -> Mu))
#    94 (  1):             K => ( 0p,     94f,  0o,    1+ 0i :(Mu -> Mu))
#    88 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     88f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    83 (  2):       ConstT? => ( 0p,     83f,  0o,    0+ 0i :(TTerm -> Mu)),         VarT? => ( 0p,     83f,  0o,    0+ 0i :(TTerm -> Mu))
#    74 (  2):         None? => ( 0p,     74f,  0o,    1+ 0i :(TMaybe -> Mu)), Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     74f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    67 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     67f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    62 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     62f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    57 (  3):     foldr-rec => ( 0p,     57f,  0o,    1+ 0i :(Callable -> Mu -> TList -> Mu)),     Pair->fst => ( 0p,     57f,  0o,    1+ 0i :(TPair -> Mu)), Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     57f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    52 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     52f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    51 (  1):      Mu -> Mu => ( 0p,     51f,  0o,    1+ 0i :(Mu -> Mu))
#    50 (  1): Callable -> Callable -> Callable -> Callable -> Mu => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    40 (  1):          AppT => (16p,     40f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    30 (  2):             B => ( 1p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),      Term-eq? => ( 0p,     30f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#    29 (  1):       Str-eq? => ( 0p,     29f,  0o,    1+ 0i :(Str -> Mu))
#    26 (  1):          _and => ( 0p,     26f,  0o,    1+ 0i :(TBool -> TBool -> Mu))
#    21 (  1):             Y => ( 0p,     21f,  0o,    2+ 0i :(Callable -> Mu))
#    14 (  1):          VarT => ( 0p,     14f,  0o,    1+ 0i :(Str -> TTerm))
#     2 (  1):           K^2 => ( 0p,      2f,  0o,    1+ 0i :(Mu -> Mu))
#     0 (  1):           _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> Mu))

Output completed (40 sec consumed) - Normal Termination



