---------- run perl6-m ----------
1..5
# CurryStats: ( 2p,     73f,  0o,  170+6i)
#    31 (  1):                           B => ( 1p,     31f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    22 (  1):                           Y => ( 0p,     22f,  0o,    2+ 0i :(Callable -> Mu))
#     8 (  1):                        VarT => ( 0p,      8f,  0o,    1+ 0i :(Str -> TTerm))
#     4 (  2):                           K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      K^2 => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu))
#     1 (  2):                      findFP => ( 0p,      1f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),
#                           findFP-inMaybe => ( 0p,      1f,  0o,    1+ 0i :(Callable -> Mu))
#     0 ( 28):                           I => ( 0p,      0f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),
#                                      _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                      nil => ( 0p,      0f,  0o,    1+ 0i TList:(Mu -> Mu -> Mu)),
#                                      not => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool)),
#                                     AppT => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm)),
#                                     LamT => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm)),
#                                     _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                     caar => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                     cons => ( 0p,      0f,  0o,    1+ 0i :(Mu -> TList -> TList)),
#                                    #true => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),
#                                    free? => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    subst => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> Str -> TTerm)),
#                                   #false => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),
#                                   B(1/2) => ( 0p,      0f,  0o,    0+ 0i :(Callable -> Mu)),
#                                  Str-eq? => ( 0p,      0f,  0o,    1+ 0i :(Str -> Str -> TBool)),
#                                 Term-eq? => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool)),
#                                 map-iter => ( 0p,      0f,  0o,    0+ 1i :(Callable -> Mu -> Mu)),
#                                subst-seq => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TList -> TMaybe)),
#                               BBSomeAppT => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                               betaReduce => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                              subst-first => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TList -> Mu)),
#                             Term->source => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> Str)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 0i :(TTerm -> TList)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 1i :(TTerm -> TList)),
#                         subst-first_VarT => ( 0p,      0f,  0o,    1+ 0i :(Str -> TList -> Mu)),
#                         subst-with-alpha => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TList -> TTerm -> Mu)),
#                   free-varNames-internal => ( 1p,      0f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList))
ok 1 - (x x) reduces to itself (sanity check)
ok 2 - ((λx.x) x) reduces to x (sanity check)
ok 3 - $bigTerm.lambda is (λf1.(λf2.(λf3.(λf4.(λf5.((λy.(λ_.y)) ((λg.(λh.((λy.(λ_.y)) (g h)))) ((λg.(λh.((λy.(λ_.y)) (g h)))) (λk.(((λk.(((λk.(((λk.(((λk.(((λx.x) k) f1)) k) f2)) k) f3)) k) f4)) k) f5))))))))))
ok 4 - $expectedTerm.lambda is (λf1.(λf2.(λf3.(λf4.(λf5.(λ_.(λh.(λ_.(λ_.(((((h f1) f2) f3) f4) f5))))))))))
# CurryStats: ( 2p,    392f,  0o,  235+6i)
#    81 (  1):                Term->source => ( 0p,     81f,  0o,    1+ 0i :(TTerm -> Str))
#    31 (  2):                           B => ( 1p,     31f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),
#                                     LamT => ( 0p,     31f,  0o,    1+ 0i :(Str -> TTerm -> TTerm))
#    28 (  1):                           I => ( 0p,     28f,  0o,    1+ 0i :(Mu -> Mu))
#    24 (  1):                        AppT => ( 0p,     24f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    22 (  1):                           Y => ( 0p,     22f,  0o,    2+ 0i :(Callable -> Mu))
#    13 (  1):                        VarT => ( 0p,     13f,  0o,    1+ 0i :(Str -> TTerm))
#     5 (  1):                         nil => ( 0p,      5f,  0o,    1+ 0i TList:(Mu -> Mu -> Mu))
#     4 (  3):                           K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      K^2 => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu)),
#                                   #false => ( 0p,      4f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#     2 (  4):                        cons => ( 0p,      2f,  0o,    1+ 0i :(Mu -> TList -> TList)),
#                                  Str-eq? => ( 0p,      2f,  0o,    1+ 0i :(Str -> Str -> TBool)),
#                                subst-seq => ( 0p,      2f,  0o,    1+ 0i :(TTerm -> TList -> TMaybe)),
#                               betaReduce => ( 0p,      2f,  0o,    0+ 1i :(Mu -> Mu))
#     1 (  6):                       #true => ( 0p,      1f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),
#                                    subst => ( 0p,      1f,  0o,    1+ 0i :(TTerm -> TTerm -> Str -> TTerm)),
#                                   findFP => ( 0p,      1f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),
#                                 Term-eq? => ( 0p,      1f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool)),
#                            free-varNames => ( 0p,      1f,  0o,    0+ 1i :(TTerm -> TList)),
#                           findFP-inMaybe => ( 0p,      1f,  0o,    1+ 0i :(Callable -> Mu))
#     0 ( 14):                         _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),
#                                      _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                      not => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool)),
#                                     _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                     caar => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    free? => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                   B(1/2) => ( 0p,      0f,  0o,    0+ 0i :(Callable -> Mu)),
#                                 map-iter => ( 0p,      0f,  0o,    0+ 1i :(Callable -> Mu -> Mu)),
#                               BBSomeAppT => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                              subst-first => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TList -> Mu)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 0i :(TTerm -> TList)),
#                         subst-first_VarT => ( 0p,      0f,  0o,    1+ 0i :(Str -> TList -> Mu)),
#                         subst-with-alpha => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TList -> TTerm -> Mu)),
#                   free-varNames-internal => ( 1p,      0f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList))
# 5 sec consumed for β-reduction
ok 5 - $bigTerm reduces to (λf1.(λf2.(λf3.(λf4.(λf5.(λ_.(λh.(λ_.(λ_.(((((h f1) f2) f3) f4) f5))))))))))
# CurryStats: ( 2p,   4537f,  0o,  636+6i)
#   455 (  1):                      #false => ( 0p,    455f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   374 (  1):                     Str-eq? => ( 0p,    374f,  0o,    1+ 0i :(Str -> Str -> TBool))
#   255 (  1):                      exists => ( 0p,    255f,  0o,    2+ 0i :(Callable -> TList -> Mu))
#   175 (  1):             freeName-under? => ( 0p,    175f,  0o,    1+ 0i :(Str -> Str -> TTerm -> TBool))
#   174 (  1):      free-varNames-internal => ( 1p,    174f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList))
#   157 (  1):                         nil => ( 0p,    157f,  0o,    1+ 0i TList:(Mu -> Mu -> Mu))
#   148 (  1):                        Some => ( 0p,    148f,  0o,    1+ 0i :(Mu -> Mu))
#   147 (  1):                betaContract => ( 0p,    147f,  0o,    2+ 0i :(TTerm -> TMaybe))
#   132 (  1):                        LamT => ( 0p,    132f,  0o,    1+ 0i :(Str -> TTerm -> TTerm))
#   122 (  1):                   subst-seq => ( 0p,    122f,  0o,    1+ 0i :(TTerm -> TList -> TMaybe))
#   119 (  1):                       #true => ( 0p,    119f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   112 (  1):                        cons => ( 0p,    112f,  0o,    1+ 0i :(Mu -> TList -> TList))
#   101 (  1):                Term->source => ( 0p,    101f,  0o,    1+ 0i :(TTerm -> Str))
#    88 (  1):                        None => ( 0p,     88f,  0o,    1+ 0i TMaybe:(Mu -> Mu -> Mu))
#    75 (  1):                    K1#false => ( 0p,     75f,  0o,    1+ 0i :(Mu -> Mu))
#    57 (  3):                       π2->1 => ( 0p,     57f,  0o,    1+ 0i :(Mu -> Mu -> Mu)),
#                                Pair->fst => ( 0p,     57f,  0o,    1+ 0i :(TPair -> Mu)),
#                                foldr-rec => ( 0p,     57f,  0o,    1+ 0i :(Callable -> Mu -> TList -> Mu))
#    56 (  1):                        AppT => ( 0p,     56f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    50 (  1):                   <<TTerm>> => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    35 (  1):                           I => ( 0p,     35f,  0o,    1+ 0i :(Mu -> Mu))
#    31 (  1):                           B => ( 1p,     31f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    22 (  1):                           Y => ( 0p,     22f,  0o,    2+ 0i :(Callable -> Mu))
#    21 (  1):                    Term-eq? => ( 0p,     21f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#    13 (  3):                        VarT => ( 0p,     13f,  0o,    1+ 0i :(Str -> TTerm)),
#                                    subst => ( 0p,     13f,  0o,    1+ 0i :(TTerm -> TTerm -> Str -> TTerm)),
#                            free-varNames => ( 0p,     13f,  0o,    0+ 1i :(TTerm -> TList))
#     4 (  2):                           K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      K^2 => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu))
#     3 (  1):                  betaReduce => ( 0p,      3f,  0o,    0+ 1i :(Mu -> Mu))
#     1 (  2):                      findFP => ( 0p,      1f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),
#                           findFP-inMaybe => ( 0p,      1f,  0o,    1+ 0i :(Callable -> Mu))
#     0 ( 13):                         _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),
#                                      _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                      not => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool)),
#                                     _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                     caar => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    free? => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                   B(1/2) => ( 0p,      0f,  0o,    0+ 0i :(Callable -> Mu)),
#                                 map-iter => ( 0p,      0f,  0o,    0+ 1i :(Callable -> Mu -> Mu)),
#                               BBSomeAppT => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                              subst-first => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TList -> Mu)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 0i :(TTerm -> TList)),
#                         subst-first_VarT => ( 0p,      0f,  0o,    1+ 0i :(Str -> TList -> Mu)),
#                         subst-with-alpha => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TList -> TTerm -> Mu))

Output completed (32 sec consumed) - Normal Termination