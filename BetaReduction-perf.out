---------- run perl6-m ----------
1..7
# CurryStats: ( 1p,    266f,  0o,  363+5i)
#    87 (  1):                        LamT => ( 0p,     87f,  0o,    1+ 0i :(Str -> TTerm -> TTerm))
#    86 (  1):                        AppT => ( 0p,     86f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#    30 (  1):                           B => ( 0p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    25 (  1):                           Y => ( 0p,     25f,  0o,    2+ 0i :(Callable -> Mu))
#    22 (  1):                        VarT => ( 0p,     22f,  0o,    1+ 0i :(Str -> TTerm))
#     4 (  2):                           K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      K^2 => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu))
#     1 (  2):                      findFP => ( 0p,      1f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),
#                           findFP-inMaybe => ( 0p,      1f,  0o,    1+ 0i :(Callable -> Mu))
#     0 ( 25):                           I => ( 0p,      0f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),
#                                      _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                      nil => ( 0p,      0f,  0o,    1+ 0i TList:(Mu -> Mu -> Mu)),
#                                      not => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool)),
#                                     _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                     caar => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                     cons => ( 0p,      0f,  0o,    1+ 0i :(Mu -> TList -> TList)),
#                                    #true => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),
#                                    free? => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    subst => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TMaybe)),
#                                   #false => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),
#                                  Str-eq? => ( 0p,      0f,  0o,    1+ 0i :(Str -> Str -> TBool)),
#                                 Term-eq? => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool)),
#                                 map-iter => ( 0p,      0f,  0o,    0+ 1i :(Callable -> Mu -> Mu)),
#                                subst-seq => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TList -> TMaybe)),
#                               betaReduce => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                             Term->source => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> Str)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 0i :(TTerm -> TList)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 1i :(TTerm -> TList)),
#                       findFP-inMaybe_dbg => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                    findFP-inMaybe_dbgXXX => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                    subst-par-alpha_Maybe => ( 0p,      0f,  0o,    1+ 0i :(TList -> TTerm -> TMaybe)),
#                   free-varNames-internal => ( 1p,      0f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList)),
#                   subst-par-alpha_direct => ( 0p,      0f,  0o,    1+ 0i :(TList -> TTerm -> TTerm))
# (λf.λa.λb.f b a) (B (C cons) (C cons nil))  =  (λf.λa.λb.f b a) ((λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)))
# λa.λb.cons a (cons b nil)  =  λa.λb.(λf1.λf2.λ_.λh.h f1 f2) a ((λf1.λf2.λ_.λh.h f1 f2) b (λh.λ_.h))
# 8.09 = 6.28 + 1.81 sec (78% + 22%) consumed for beta-reduction
ok 1 - (λf.λa.λb.f b a) (B (C cons) (C cons nil))  =_β*  λa.λb.cons a (cons b nil)  [NO alpha-conv needed]
# (C (B (C cons) (C cons nil)))  =  (λf.λx.λy.f y x) ((λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)))
# λx.λy.cons x (cons y nil)  =  λx.λy.(λf1.λf2.λ_.λh.h f1 f2) x ((λf1.λf2.λ_.λh.h f1 f2) y (λh.λ_.h))
# 9.14 = 7.05 + 2.09 sec (77% + 23%) consumed for beta-reduction
ok 2 - (C (B (C cons) (C cons nil)))  =_β*  λx.λy.cons x (cons y nil)  [DOES need alpha-conv]
# 0.00 = 0.00 + 0.00 sec (0% + 0%) consumed for beta-reduction
ok 3 - (x x)  =_β*  (x x)  (sanity check)
# 0.11 = 0.09 + 0.02 sec (86% + 14%) consumed for beta-reduction
ok 4 - (λx.x) x  =_β*  x  (sanity check)
# 0.27 sec consumed for big-term construction
ok 5 - $bigTerm.lambda is λf1.λf2.λf3.λf4.λf5.(λy.λ_.y) ((λg.λh.(λy.λ_.y) (g h)) ((λg.λh.(λy.λ_.y) (g h)) (λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5)))
ok 6 - $expectedTerm.lambda is λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.h f1 f2 f3 f4 f5
# CurryStats: ( 1p,  17102f,  0o, 2026+5i)
#  1629 (  1):                      exists => ( 0p,   1629f,  0o,    2+ 0i :(Callable -> TList -> Mu))
#  1235 (  1):                     Str-eq? => ( 0p,   1235f,  0o,    1+ 0i :(Str -> Str -> TBool))
#  1225 (  1):                      #false => ( 0p,   1225f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#  1196 (  1):      free-varNames-internal => ( 1p,   1196f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList))
#   945 (  1):                       #true => ( 0p,    945f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   720 (  1):                        cons => ( 0p,    720f,  0o,    1+ 0i :(Mu -> TList -> TList))
#   632 (  1):                         nil => ( 0p,    632f,  0o,    1+ 0i TList:(Mu -> Mu -> Mu))
#   363 (  2):                       π2->2 => ( 0p,    363f,  0o,    1+ 0i :(Mu -> Mu -> Mu)),
#                                Pair->snd => ( 0p,    363f,  0o,    1+ 0i :(TPair -> Mu))
#   344 (  1):                        Some => ( 0p,    344f,  0o,    1+ 0i :(Mu -> Mu))
#   301 (  1):                        Pair => ( 0p,    301f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   294 (  1):                        None => ( 0p,    294f,  0o,    1+ 0i TMaybe:(Mu -> Mu -> Mu))
#   273 (  1):                betaContract => ( 0p,    273f,  0o,    2+ 0i :(TTerm -> Mu))
#   264 (  1):       subst-par-alpha_Maybe => ( 0p,    264f,  0o,    1+ 0i :(TList -> TTerm -> TMaybe))
#   263 (  2):                        LamT => ( 0p,    263f,  0o,    1+ 0i :(Str -> TTerm -> TTerm)),
#                 Term->srcLesser-internal => ( 0p,    263f,  0o,    1+ 0i :(TTerm -> TPair))
#   231 (  2):                       π2->1 => ( 0p,    231f,  0o,    1+ 0i :(Mu -> Mu -> Mu)),
#                                Pair->fst => ( 0p,    231f,  0o,    1+ 0i :(TPair -> Mu))
#   206 (  1):               <<Aka+TTerm>> => ( 0p,    206f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   204 (  1):                        AppT => ( 0p,    204f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#   154 (  1):               free-varNames => ( 0p,    154f,  0o,    0+ 1i :(TTerm -> TList))
#   149 (  1):                       first => ( 0p,    149f,  0o,    1+ 0i :(Callable -> TList -> Mu))
#   136 (  1):               <<Aka+TTerm>> => ( 0p,    136f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   130 (  1):               <<Aka+TTerm>> => ( 0p,    130f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   106 (  1):               <<Aka+TTerm>> => ( 0p,    106f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   104 (  1):               <<Aka+TTerm>> => ( 0p,    104f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    96 (  1):               <<Aka+TTerm>> => ( 0p,     96f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    94 (  3):                   <<TTerm>> => ( 0p,     94f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                                <<TTerm>> => ( 0p,     94f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                            <<Aka+TTerm>> => ( 0p,     94f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    93 (  1):                   foldr-rec => ( 0p,     93f,  0o,    1+ 0i :(Callable -> Mu -> TList -> Mu))
#    92 (  2):                       foldr => ( 0p,     92f,  0o,    0+ 0i name:(Callable -> Mu -> TList -> Mu)),
#                                   filter => ( 0p,     92f,  0o,    1+ 0i :(Callable -> TList -> TList))
#    86 (  2):                   <<TTerm>> => ( 0p,     86f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                                <<TTerm>> => ( 0p,     86f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    74 (  1):               <<Aka+TTerm>> => ( 0p,     74f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    55 (  1):               <<Aka+TTerm>> => ( 0p,     55f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    54 (  1):                   <<TTerm>> => ( 0p,     54f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    53 (  1):               <<Aka+TTerm>> => ( 0p,     53f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    50 (  3):                   <<TTerm>> => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                                <<TTerm>> => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                            <<Aka+TTerm>> => ( 0p,     50f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    38 (  1):                    Term-eq? => ( 0p,     38f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#    37 (  1):             subst-par-alpha => ( 0p,     37f,  0o,    0+ 0i name:(TList -> TTerm -> TMaybe))
#    30 (  1):                           B => ( 0p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    26 (  1):                           Y => ( 0p,     26f,  0o,    2+ 0i :(Callable -> Mu))
#    24 (  1):                        VarT => ( 0p,     24f,  0o,    1+ 0i :(Str -> TTerm))
#     8 (  1):                  betaReduce => ( 0p,      8f,  0o,    0+ 1i :(Mu -> Mu))
#     5 (  1):                           I => ( 0p,      5f,  0o,    1+ 0i :(Mu -> Mu))
#     4 (  2):                           K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      K^2 => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu))
#     2 (  2):                      findFP => ( 0p,      2f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),
#                           findFP-inMaybe => ( 0p,      2f,  0o,    1+ 0i :(Callable -> Mu))
#     0 ( 14):                         _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),
#                                      _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                      not => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool)),
#                                     _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                     caar => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    free? => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    subst => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TMaybe)),
#                                 map-iter => ( 0p,      0f,  0o,    0+ 1i :(Callable -> Mu -> Mu)),
#                                subst-seq => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TList -> TMaybe)),
#                             Term->source => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> Str)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 0i :(TTerm -> TList)),
#                       findFP-inMaybe_dbg => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                    findFP-inMaybe_dbgXXX => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                   subst-par-alpha_direct => ( 0p,      0f,  0o,    1+ 0i :(TList -> TTerm -> TTerm))
# 5.56 = 5.55 + 0.02 sec (100% + 0%) consumed for beta-reduction
ok 7 - λf1.λf2.λf3.λf4.λf5.(λy.λ_.y) ((λg.λh.(λy.λ_.y) (g h)) ((λg.λh.(λy.λ_.y) (g h)) (λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5)))  =_β*  λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.h f1 f2 f3 f4 f5  
# CurryStats: ( 1p,  21715f,  0o, 2551+5i)
#  2081 (  1):                      exists => ( 0p,   2081f,  0o,    2+ 0i :(Callable -> TList -> Mu))
#  1616 (  1):                      #false => ( 0p,   1616f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#  1594 (  1):                     Str-eq? => ( 0p,   1594f,  0o,    1+ 0i :(Str -> Str -> TBool))
#  1474 (  1):      free-varNames-internal => ( 1p,   1474f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList))
#  1122 (  1):                       #true => ( 0p,   1122f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   866 (  1):                        cons => ( 0p,    866f,  0o,    1+ 0i :(Mu -> TList -> TList))
#   784 (  1):                         nil => ( 0p,    784f,  0o,    1+ 0i TList:(Mu -> Mu -> Mu))
#   502 (  1):                        Some => ( 0p,    502f,  0o,    1+ 0i :(Mu -> Mu))
#   456 (  2):                       π2->2 => ( 0p,    456f,  0o,    1+ 0i :(Mu -> Mu -> Mu)),
#                                Pair->snd => ( 0p,    456f,  0o,    1+ 0i :(TPair -> Mu))
#   435 (  1):                betaContract => ( 0p,    435f,  0o,    2+ 0i :(TTerm -> Mu))
#   389 (  1):                        Pair => ( 0p,    389f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   365 (  1):                        None => ( 0p,    365f,  0o,    1+ 0i TMaybe:(Mu -> Mu -> Mu))
#   364 (  1):                        LamT => ( 0p,    364f,  0o,    1+ 0i :(Str -> TTerm -> TTerm))
#   339 (  1):    Term->srcLesser-internal => ( 0p,    339f,  0o,    1+ 0i :(TTerm -> TPair))
#   310 (  1):       subst-par-alpha_Maybe => ( 0p,    310f,  0o,    1+ 0i :(TList -> TTerm -> TMaybe))
#   282 (  2):                       π2->1 => ( 0p,    282f,  0o,    1+ 0i :(Mu -> Mu -> Mu)),
#                                Pair->fst => ( 0p,    282f,  0o,    1+ 0i :(TPair -> Mu))
#   236 (  1):                        AppT => ( 0p,    236f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#   227 (  1):               <<Aka+TTerm>> => ( 0p,    227f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   175 (  1):                       first => ( 0p,    175f,  0o,    1+ 0i :(Callable -> TList -> Mu))
#   173 (  1):               free-varNames => ( 0p,    173f,  0o,    0+ 1i :(TTerm -> TList))
#   150 (  1):               <<Aka+TTerm>> => ( 0p,    150f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   148 (  1):               <<Aka+TTerm>> => ( 0p,    148f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   125 (  1):               <<Aka+TTerm>> => ( 0p,    125f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   112 (  1):               <<Aka+TTerm>> => ( 0p,    112f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   109 (  1):               <<Aka+TTerm>> => ( 0p,    109f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   107 (  1):                   foldr-rec => ( 0p,    107f,  0o,    1+ 0i :(Callable -> Mu -> TList -> Mu))
#   106 (  2):                       foldr => ( 0p,    106f,  0o,    0+ 0i name:(Callable -> Mu -> TList -> Mu)),
#                                   filter => ( 0p,    106f,  0o,    1+ 0i :(Callable -> TList -> TList))
#   101 (  1):               <<Aka+TTerm>> => ( 0p,    101f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    94 (  2):                   <<TTerm>> => ( 0p,     94f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                                <<TTerm>> => ( 0p,     94f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    86 (  2):                   <<TTerm>> => ( 0p,     86f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                                <<TTerm>> => ( 0p,     86f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    74 (  1):               <<Aka+TTerm>> => ( 0p,     74f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    65 (  1):               <<Aka+TTerm>> => ( 0p,     65f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    58 (  1):                    Term-eq? => ( 0p,     58f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#    55 (  1):               <<Aka+TTerm>> => ( 0p,     55f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    54 (  1):                   <<TTerm>> => ( 0p,     54f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    53 (  1):               <<Aka+TTerm>> => ( 0p,     53f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    50 (  3):                   <<TTerm>> => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                                <<TTerm>> => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                            <<Aka+TTerm>> => ( 0p,     50f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    49 (  1):             subst-par-alpha => ( 0p,     49f,  0o,    0+ 0i name:(TList -> TTerm -> TMaybe))
#    30 (  1):                           B => ( 0p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    26 (  1):                           Y => ( 0p,     26f,  0o,    2+ 0i :(Callable -> Mu))
#    24 (  1):                        VarT => ( 0p,     24f,  0o,    1+ 0i :(Str -> TTerm))
#    10 (  1):                  betaReduce => ( 0p,     10f,  0o,    0+ 1i :(Mu -> Mu))
#     6 (  1):                           I => ( 0p,      6f,  0o,    1+ 0i :(Mu -> Mu))
#     4 (  2):                           K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      K^2 => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu))
#     2 (  2):                      findFP => ( 0p,      2f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),
#                           findFP-inMaybe => ( 0p,      2f,  0o,    1+ 0i :(Callable -> Mu))
#     0 ( 14):                         _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),
#                                      _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                      not => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool)),
#                                     _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                     caar => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    free? => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    subst => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TMaybe)),
#                                 map-iter => ( 0p,      0f,  0o,    0+ 1i :(Callable -> Mu -> Mu)),
#                                subst-seq => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TList -> TMaybe)),
#                             Term->source => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> Str)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 0i :(TTerm -> TList)),
#                       findFP-inMaybe_dbg => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                    findFP-inMaybe_dbgXXX => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                   subst-par-alpha_direct => ( 0p,      0f,  0o,    1+ 0i :(TList -> TTerm -> TTerm))

Output completed (1 min 12 sec consumed) - Normal Termination