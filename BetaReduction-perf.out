---------- run perl6-m ----------
1..7
# CurryStats: ( 0p,      0f,  0o,    0+0i)

# (λf.λa.λb.f b a) (B (C cons) (C cons nil))  =  (λf.λa.λb.f b a) ((λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)))
#     =_β0   (λf.λa.λb.f b a) ((λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)))
#     =_β1   λa.λb.(λx.(λx.λy.(λf1.λf2.λ_.λh.h f1 f2) y x) ((λy.(λf1.λf2.λ_.λh.h f1 f2) y (λh.λ_.h)) x)) b a
>>>bindings>>> [(Pair "y" (VarT "a"))]  ++  [(Pair "x" (VarT "b"))]
>>>rest-args>> (cons (VarT "a") nil)  ~>  nil
>>>old body>>> (λx.λy.(λf1.λf2.λ_.λh.h f1 f2) y x) ((λy.(λf1.λf2.λ_.λh.h f1 f2) y (λh.λ_.h)) x)
>>>ct'd body>> λy.λ_.λh.h y (λ_.λh.h x (λh.λ_.h))
>>>inner body> λ_.λh.h y (λ_.λh.h x (λh.λ_.h))
>>>result>>>>> λ_.λh.h a (λ_.λh.h b (λh.λ_.h))
#     =_β2   λa.λb.(λy.λ_.λh.h y (λ_.λh.h b (λh.λ_.h))) a
#     =_β3   λa.λb.λ_.λh.h a (λ_.λh.h b (λh.λ_.h))
#     (3 steps)
# λa.λb.cons a (cons b nil)  =  λa.λb.(λf1.λf2.λ_.λh.h f1 f2) a ((λf1.λf2.λ_.λh.h f1 f2) b (λh.λ_.h))
#     =_β0   λa.λb.(λf1.λf2.λ_.λh.h f1 f2) a ((λf1.λf2.λ_.λh.h f1 f2) b (λh.λ_.h))
#     =_β1   λa.λb.λ_.λh.h a (λ_.λh.h b (λh.λ_.h))
#     (1 steps)
# 6.09 = 5.02 + 1.08 sec (82% + 18%) consumed for beta-reduction
ok 1 - (λf.λa.λb.f b a) (B (C cons) (C cons nil))  =_β*  λa.λb.cons a (cons b nil)  [NO alpha-conv needed]
# (C (B (C cons) (C cons nil)))  =  (λf.λx.λy.f y x) ((λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)))
#     =_β0   (λf.λx.λy.f y x) ((λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)))
#     =_β1   λx.λy.(λx.(λx.λy.(λf1.λf2.λ_.λh.h f1 f2) y x) ((λy.(λf1.λf2.λ_.λh.h f1 f2) y (λh.λ_.h)) x)) y x
>>>bindings>>> [(Pair "y" (VarT "x"))]  ++  [(Pair "x" (VarT "y"))]
>>>rest-args>> (cons (VarT "x") nil)  ~>  nil
>>>old body>>> (λx.λy.(λf1.λf2.λ_.λh.h f1 f2) y x) ((λy.(λf1.λf2.λ_.λh.h f1 f2) y (λh.λ_.h)) x)
>>>ct'd body>> λy.λ_.λh.h y (λ_.λh.h x (λh.λ_.h))
>>>inner body> λ_.λh.h y (λ_.λh.h x (λh.λ_.h))
>>>result>>>>> λ_.λh.h x (λ_.λh.h y (λh.λ_.h))
#     =_β2   λx.λy.(λα1.λ_.λh.h α1 (λ_.λh.h y (λh.λ_.h))) x
#     =_β3   λx.λy.λ_.λh.h x (λ_.λh.h y (λh.λ_.h))
#     (3 steps)
# λx.λy.cons x (cons y nil)  =  λx.λy.(λf1.λf2.λ_.λh.h f1 f2) x ((λf1.λf2.λ_.λh.h f1 f2) y (λh.λ_.h))
#     =_β0   λx.λy.(λf1.λf2.λ_.λh.h f1 f2) x ((λf1.λf2.λ_.λh.h f1 f2) y (λh.λ_.h))
#     =_β1   λx.λy.λ_.λh.h x (λ_.λh.h y (λh.λ_.h))
#     (1 steps)
# 6.59 = 5.42 + 1.17 sec (82% + 18%) consumed for beta-reduction
ok 2 - (C (B (C cons) (C cons nil)))  =_β*  λx.λy.cons x (cons y nil)  [DOES need alpha-conv]
#     =_β0   (x x)
#     (0 steps)
#     =_β0   (x x)
#     (0 steps)
# 0.11 = 0.05 + 0.06 sec (43% + 57%) consumed for beta-reduction
ok 3 - (x x)  =_β*  (x x)  (sanity check)
#     =_β0   (λx.x) x
#     =_β1   x
#     (1 steps)
#     =_β0   x
#     (0 steps)
# 0.17 = 0.14 + 0.03 sec (82% + 18%) consumed for beta-reduction
ok 4 - (λx.x) x  =_β*  x  (sanity check)
# 0.22 sec consumed for big-term construction
ok 5 - $bigTerm.lambda is λf1.λf2.λf3.λf4.λf5.(λy.λ_.y) ((λg.λh.(λy.λ_.y) (g h)) ((λg.λh.(λy.λ_.y) (g h)) (λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5)))
ok 6 - $expectedTerm.lambda is λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.h f1 f2 f3 f4 f5
# CurryStats: ( 0p,   8749f,  0o,  612+0i)
#   691 (  1):                     #false => ( 0p,    691f,  0o,    0+ 0i TBool:(Mu -> Mu -> Mu))
#   585 (  1):          not-free-varName? => ( 0p,    585f,  0o,    0+ 0i :(Str -> TTerm -> TBool))
#   459 (  1):                    Str-eq? => ( 0p,    459f,  0o,    0+ 0i :(Str -> Str -> TBool))
#   358 (  1):                    Str-ne? => ( 0p,    358f,  0o,    0+ 0i :(Str -> Str -> TBool))
#   293 (  1):                      #true => ( 0p,    293f,  0o,    0+ 0i TBool:(Mu -> Mu -> Mu))
#   288 (  2):                      π2->2 => ( 0p,    288f,  0o,    0+ 0i :(Mu -> Mu -> Mu)),
#                               Pair->snd => ( 0p,    288f,  0o,    0+ 0i :(TPair -> Mu))
#   266 (  1):              free-varName? => ( 0p,    266f,  0o,    0+ 0i :(Str -> TTerm -> TBool))
#   264 (  1):                       None => ( 0p,    264f,  0o,    0+ 0i TMaybe:(Mu -> Mu -> Mu))
#   242 (  1):         betaContract_multi => ( 0p,    242f,  0o,    0+ 0i :(TTerm -> Mu))
#   228 (  1):              <<Aka+TTerm>> => ( 0p,    228f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   213 (  1):                        nil => ( 0p,    213f,  0o,    0+ 0i TList:(Mu -> Mu -> Mu))
#   210 (  1):                       Pair => ( 0p,    210f,  0o,    0+ 0i :(Mu -> Mu -> Mu))
#   186 (  1):     subst-par-alpha_direct => ( 0p,    186f,  0o,    0+ 0i :(TList -> TTerm -> TTerm))
#   180 (  1):                       cons => ( 0p,    180f,  0o,    0+ 0i :(Mu -> TList -> TList))
#   160 (  1):   Term->srcLesser-internal => ( 0p,    160f,  0o,    0+ 0i :(TTerm -> TPair))
#   146 (  2):                      π2->1 => ( 0p,    146f,  0o,    0+ 0i :(Mu -> Mu -> Mu)),
#                               Pair->fst => ( 0p,    146f,  0o,    0+ 0i :(TPair -> Mu))
#   145 (  2):                      first => ( 0p,    145f,  0o,    0+ 0i :(Callable -> TList -> Mu)),
#                                  exists => ( 0p,    145f,  0o,    0+ 0i :(Callable -> TList -> TBool))
#   113 (  1):      except-substs_noDupes => ( 0p,    113f,  0o,    0+ 0i :(Mu -> TList -> Mu))
#   112 (  1):              <<Aka+TTerm>> => ( 0p,    112f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   110 (  1):              <<Aka+TTerm>> => ( 0p,    110f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   105 (  1):               collect-args => ( 0p,    105f,  0o,    0+ 0i :(Mu -> Mu -> TTerm -> TList -> TTerm -> Mu))
#    88 (  1):                       Some => ( 0p,     88f,  0o,    0+ 0i :(Mu -> Mu))
#    87 (  1):                     K1None => ( 0p,     87f,  0o,    0+ 0i :(Mu -> Mu))
#    72 (  3):                       LamT => ( 0p,     72f,  0o,    0+ 0i :(Str -> TTerm -> TTerm)),
#                           <<Aka+TTerm>> => ( 0p,     72f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                           <<Aka+TTerm>> => ( 0p,     72f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    68 (  1):              <<Aka+TTerm>> => ( 0p,     68f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    66 (  1): filter-substs-and-contract => ( 0p,     66f,  0o,    0+ 0i :(Mu -> TList -> Mu))
#    62 (  1):                       AppT => ( 0p,     62f,  0o,    0+ 0i :(TTerm -> TTerm -> TTerm))
#    61 (  1):   collect-args-and-lambdas => ( 0p,     61f,  0o,    0+ 0i :(Mu -> Mu -> TTerm -> TList -> TTerm -> Mu))
#    56 (  1):              <<Aka+TTerm>> => ( 0p,     56f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    55 (  1):              <<Aka+TTerm>> => ( 0p,     55f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    52 (  1):              <<Aka+TTerm>> => ( 0p,     52f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    43 (  1):                  <<TTerm>> => ( 0p,     43f,  0o,    0+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    41 (  1):            collect-lambdas => ( 0p,     41f,  0o,    0+ 0i :(Mu -> TList -> TTerm -> TList -> Mu))
#    15 (  1):                      foldl => ( 0p,     15f,  0o,    0+ 0i :(Callable -> Mu -> TList -> Mu))
#     2 (  1):                      foldr => ( 0p,      2f,  0o,    0+ 0i name:(Callable -> Mu -> TList -> Mu))
#     1 (  1):                       VarT => ( 0p,      1f,  0o,    0+ 0i :(Str -> TTerm))
#     =_β0   λf1.λf2.λf3.λf4.λf5.(λy.λ_.y) ((λg.λh.(λy.λ_.y) (g h)) ((λg.λh.(λy.λ_.y) (g h)) (λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5)))
#     =_β1   λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.(λh.λ_.(λk.k f1 f2 f3 f4 f5) h) h
#     =_β2   λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.h f1 f2 f3 f4 f5
#     (2 steps)
#     =_β0   λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.h f1 f2 f3 f4 f5
#     (0 steps)
# 3.05 = 2.78 + 0.27 sec (91% + 9%) consumed for beta-reduction
ok 7 - λf1.λf2.λf3.λf4.λf5.(λy.λ_.y) ((λg.λh.(λy.λ_.y) (g h)) ((λg.λh.(λy.λ_.y) (g h)) (λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5)))  =_β*  λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.h f1 f2 f3 f4 f5  
# CurryStats: ( 0p,  10211f,  0o,  758+0i)
#   791 (  1):                     #false => ( 0p,    791f,  0o,    0+ 0i TBool:(Mu -> Mu -> Mu))
#   624 (  1):          not-free-varName? => ( 0p,    624f,  0o,    0+ 0i :(Str -> TTerm -> TBool))
#   520 (  1):                    Str-eq? => ( 0p,    520f,  0o,    0+ 0i :(Str -> Str -> TBool))
#   378 (  1):                    Str-ne? => ( 0p,    378f,  0o,    0+ 0i :(Str -> Str -> TBool))
#   346 (  1):                       None => ( 0p,    346f,  0o,    0+ 0i TMaybe:(Mu -> Mu -> Mu))
#   318 (  1):         betaContract_multi => ( 0p,    318f,  0o,    0+ 0i :(TTerm -> Mu))
#   309 (  1):                      #true => ( 0p,    309f,  0o,    0+ 0i TBool:(Mu -> Mu -> Mu))
#   308 (  2):                      π2->2 => ( 0p,    308f,  0o,    0+ 0i :(Mu -> Mu -> Mu)),
#                               Pair->snd => ( 0p,    308f,  0o,    0+ 0i :(TPair -> Mu))
#   302 (  1):              free-varName? => ( 0p,    302f,  0o,    0+ 0i :(Str -> TTerm -> TBool))
#   268 (  1):                        nil => ( 0p,    268f,  0o,    0+ 0i TList:(Mu -> Mu -> Mu))
#   243 (  1):     subst-par-alpha_direct => ( 0p,    243f,  0o,    0+ 0i :(TList -> TTerm -> TTerm))
#   241 (  1):              <<Aka+TTerm>> => ( 0p,    241f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   225 (  1):                       Pair => ( 0p,    225f,  0o,    0+ 0i :(Mu -> Mu -> Mu))
#   222 (  1):                       cons => ( 0p,    222f,  0o,    0+ 0i :(Mu -> TList -> TList))
#   201 (  1):                      first => ( 0p,    201f,  0o,    0+ 0i :(Callable -> TList -> Mu))
#   180 (  2):                      π2->1 => ( 0p,    180f,  0o,    0+ 0i :(Mu -> Mu -> Mu)),
#                               Pair->fst => ( 0p,    180f,  0o,    0+ 0i :(TPair -> Mu))
#   161 (  1):                     exists => ( 0p,    161f,  0o,    0+ 0i :(Callable -> TList -> TBool))
#   160 (  1):   Term->srcLesser-internal => ( 0p,    160f,  0o,    0+ 0i :(TTerm -> TPair))
#   139 (  1):               collect-args => ( 0p,    139f,  0o,    0+ 0i :(Mu -> Mu -> TTerm -> TList -> TTerm -> Mu))
#   128 (  1):                       Some => ( 0p,    128f,  0o,    0+ 0i :(Mu -> Mu))
#   121 (  1):              <<Aka+TTerm>> => ( 0p,    121f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   117 (  1):      except-substs_noDupes => ( 0p,    117f,  0o,    0+ 0i :(Mu -> TList -> Mu))
#   114 (  1):                     K1None => ( 0p,    114f,  0o,    0+ 0i :(Mu -> Mu))
#   112 (  1):              <<Aka+TTerm>> => ( 0p,    112f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    94 (  1):                       LamT => ( 0p,     94f,  0o,    0+ 0i :(Str -> TTerm -> TTerm))
#    89 (  1):                       AppT => ( 0p,     89f,  0o,    0+ 0i :(TTerm -> TTerm -> TTerm))
#    88 (  1): filter-substs-and-contract => ( 0p,     88f,  0o,    0+ 0i :(Mu -> TList -> Mu))
#    83 (  1):              <<Aka+TTerm>> => ( 0p,     83f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    78 (  1):   collect-args-and-lambdas => ( 0p,     78f,  0o,    0+ 0i :(Mu -> Mu -> TTerm -> TList -> TTerm -> Mu))
#    73 (  1):              <<Aka+TTerm>> => ( 0p,     73f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    69 (  1):              <<Aka+TTerm>> => ( 0p,     69f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    66 (  1):              <<Aka+TTerm>> => ( 0p,     66f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    55 (  1):              <<Aka+TTerm>> => ( 0p,     55f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    53 (  1):            collect-lambdas => ( 0p,     53f,  0o,    0+ 0i :(Mu -> TList -> TTerm -> TList -> Mu))
#    52 (  1):              <<Aka+TTerm>> => ( 0p,     52f,  0o,    0+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    43 (  1):                  <<TTerm>> => ( 0p,     43f,  0o,    0+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    26 (  1):                      foldl => ( 0p,     26f,  0o,    0+ 0i :(Callable -> Mu -> TList -> Mu))
#     2 (  1):                      foldr => ( 0p,      2f,  0o,    0+ 0i name:(Callable -> Mu -> TList -> Mu))
#     1 (  1):                       VarT => ( 0p,      1f,  0o,    0+ 0i :(Str -> TTerm))

Output completed (1 min 1 sec consumed) - Normal Termination