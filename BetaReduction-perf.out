---------- run perl6-m ----------
1..7
# CurryStats: ( 1p,    401f,  0o,  503+5i)
#   178 (  1):                        AppT => ( 0p,    178f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#   118 (  1):                        LamT => ( 0p,    118f,  0o,    1+ 0i :(Str -> TTerm -> TTerm))
#    30 (  2):                           B => ( 0p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),
#                                        Y => ( 0p,     30f,  0o,    2+ 0i :(Callable -> Mu))
#    29 (  1):                        VarT => ( 0p,     29f,  0o,    1+ 0i :(Str -> TTerm))
#     4 (  2):                           K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      K^2 => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu))
#     1 (  2):                      findFP => ( 0p,      1f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),
#                           findFP-inMaybe => ( 0p,      1f,  0o,    1+ 0i :(Callable -> Mu))
#     0 ( 27):                           I => ( 0p,      0f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),
#                                      _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                      nil => ( 0p,      0f,  0o,    1+ 0i TList:(Mu -> Mu -> Mu)),
#                                      not => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool)),
#                                     _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                     caar => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                     cons => ( 0p,      0f,  0o,    1+ 0i :(Mu -> TList -> TList)),
#                                    #true => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),
#                                    free? => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    subst => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TMaybe)),
#                                   #false => ( 0p,      0f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu)),
#                                  Str-eq? => ( 0p,      0f,  0o,    1+ 0i :(Str -> Str -> TBool)),
#                                 Term-eq? => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool)),
#                                 map-iter => ( 0p,      0f,  0o,    0+ 1i :(Callable -> Mu -> Mu)),
#                                subst-seq => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TList -> TMaybe)),
#                               betaReduce => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                             Term->source => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> Str)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 0i :(TTerm -> TList)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 1i :(TTerm -> TList)),
#                        subst-alpha_Maybe => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TMaybe)),
#                       findFP-inMaybe_dbg => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                       subst-alpha_direct => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TTerm)),
#                    findFP-inMaybe_dbgXXX => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                    subst-par-alpha_Maybe => ( 0p,      0f,  0o,    1+ 0i :(TList -> TTerm -> TMaybe)),
#                   free-varNames-internal => ( 1p,      0f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList)),
#                   subst-par-alpha_direct => ( 0p,      0f,  0o,    1+ 0i :(TList -> TTerm -> TTerm))
# (λf.λa.λb.f b a) (B (C cons) (C cons nil))  =  (λf.λa.λb.f b a) ((λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)))
#     =_β0   (λf.λa.λb.f b a) ((λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)))
#     =_β1   λa.λb.(λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)) b a
#     =_β2   λa.λb.(λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h) b) a
#     =_β3   λa.λb.(λf1.λf2.λ_.λh.h f1 f2) a ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h) b)
#     =_β4   λa.λb.λ_.λh.h a ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h) b)
#     =_β5   λa.λb.λ_.λh.h a ((λf1.λf2.λ_.λh.h f1 f2) b (λh.λ_.h))
#     =_β6   λa.λb.λ_.λh.h a (λ_.λh.h b (λh.λ_.h))
#     (6 steps)
# λa.λb.cons a (cons b nil)  =  λa.λb.(λf1.λf2.λ_.λh.h f1 f2) a ((λf1.λf2.λ_.λh.h f1 f2) b (λh.λ_.h))
#     =_β0   λa.λb.(λf1.λf2.λ_.λh.h f1 f2) a ((λf1.λf2.λ_.λh.h f1 f2) b (λh.λ_.h))
#     =_β1   λa.λb.λ_.λh.h a ((λf1.λf2.λ_.λh.h f1 f2) b (λh.λ_.h))
#     =_β2   λa.λb.λ_.λh.h a (λ_.λh.h b (λh.λ_.h))
#     (2 steps)
# 6.20 = 4.75 + 1.45 sec (77% + 23%) consumed for beta-reduction
ok 1 - (λf.λa.λb.f b a) (B (C cons) (C cons nil))  =_β*  λa.λb.cons a (cons b nil)  [NO alpha-conv needed]
# (C (B (C cons) (C cons nil)))  =  (λf.λx.λy.f y x) ((λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)))
#     =_β0   (λf.λx.λy.f y x) ((λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)))
#     =_β1   λx.λy.(λf.λg.λx.f (g x)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2)) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h)) y x
#     =_β2   λx.λy.(λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h) y) x
#     =_β3   λx.λy.(λf1.λf2.λ_.λh.h f1 f2) x ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h) y)
#     =_β4   λx.λy.λ_.λh.h x ((λf.λx.λy.f y x) (λf1.λf2.λ_.λh.h f1 f2) (λh.λ_.h) y)
#     =_β5   λx.λy.λ_.λh.h x ((λf1.λf2.λ_.λh.h f1 f2) y (λh.λ_.h))
#     =_β6   λx.λy.λ_.λh.h x (λ_.λh.h y (λh.λ_.h))
#     (6 steps)
# λx.λy.cons x (cons y nil)  =  λx.λy.(λf1.λf2.λ_.λh.h f1 f2) x ((λf1.λf2.λ_.λh.h f1 f2) y (λh.λ_.h))
#     =_β0   λx.λy.(λf1.λf2.λ_.λh.h f1 f2) x ((λf1.λf2.λ_.λh.h f1 f2) y (λh.λ_.h))
#     =_β1   λx.λy.λ_.λh.h x ((λf1.λf2.λ_.λh.h f1 f2) y (λh.λ_.h))
#     =_β2   λx.λy.λ_.λh.h x (λ_.λh.h y (λh.λ_.h))
#     (2 steps)
# 6.89 = 5.30 + 1.59 sec (77% + 23%) consumed for beta-reduction
ok 2 - (C (B (C cons) (C cons nil)))  =_β*  λx.λy.cons x (cons y nil)  [DOES need alpha-conv]
#     =_β0   (x x)
#     (0 steps)
#     =_β0   (x x)
#     (0 steps)
# 0.11 = 0.05 + 0.06 sec (43% + 57%) consumed for beta-reduction
ok 3 - (x x)  =_β*  (x x)  (sanity check)
#     =_β0   (λx.x) x
#     =_β1   x
#     (1 steps)
#     =_β0   x
#     (0 steps)
# 0.16 = 0.13 + 0.03 sec (80% + 20%) consumed for beta-reduction
ok 4 - (λx.x) x  =_β*  x  (sanity check)
# 0.23 sec consumed for big-term construction
ok 5 - $bigTerm.lambda is λf1.λf2.λf3.λf4.λf5.(λy.λ_.y) ((λg.λh.(λy.λ_.y) (g h)) ((λg.λh.(λy.λ_.y) (g h)) (λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5)))
ok 6 - $expectedTerm.lambda is λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.h f1 f2 f3 f4 f5
# CurryStats: (18p,  11253f,  0o, 1879+5i)
#  1041 (  2):                       π2->2 => ( 0p,   1041f,  0o,    1+ 0i :(Mu -> Mu -> Mu)),
#                                Pair->snd => ( 0p,   1041f,  0o,    1+ 0i :(TPair -> Mu))
#  1018 (  1):                        Pair => ( 0p,   1018f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#   957 (  1):    Term->srcLesser-internal => ( 0p,    957f,  0o,    1+ 0i :(TTerm -> TPair))
#   366 (  2):                       π2->1 => ( 0p,    366f,  0o,    1+ 0i :(Mu -> Mu -> Mu)),
#                                Pair->fst => ( 0p,    366f,  0o,    1+ 0i :(TPair -> Mu))
#   302 (  1):                     Str-eq? => ( 0p,    302f,  0o,    1+ 0i :(Str -> Str -> TBool))
#   248 (  1):               free-varName? => ( 0p,    248f,  0o,    1+ 0i :(Str -> TTerm -> TBool))
#   232 (  1):                      #false => ( 0p,    232f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   231 (  1):                        AppT => ( 0p,    231f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#   196 (  1):                        LamT => ( 0p,    196f,  0o,    1+ 0i :(Str -> TTerm -> TTerm))
#   186 (  1):               <<Aka+TTerm>> => ( 0p,    186f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   140 (  1):               <<Aka+TTerm>> => ( 0p,    140f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   127 (  1):          betaContract_multi => ( 0p,    127f,  0o,    1+ 0i :(TTerm -> Mu))
#   126 (  1):                        Some => ( 0p,    126f,  0o,    1+ 0i :(Mu -> Mu))
#   116 (  1):                       #true => ( 0p,    116f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   104 (  1):                        None => ( 0p,    104f,  0o,    1+ 0i TMaybe:(Mu -> Mu -> Mu))
#   100 (  1):               <<Aka+TTerm>> => ( 0p,    100f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    98 (  2):                        cons => ( 0p,     98f,  0o,    1+ 0i :(Mu -> TList -> TList)),
#                            <<Aka+TTerm>> => ( 0p,     98f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    94 (  1):                       first => ( 0p,     94f,  0o,    1+ 0i :(Callable -> TList -> Mu))
#    92 (  1):               <<Aka+TTerm>> => ( 0p,     92f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    90 (  1):      subst-par-alpha_direct => ( 0p,     90f,  0o,    1+ 0i :(TList -> TTerm -> TTerm))
#    84 (  2):               <<Aka+TTerm>> => ( 0p,     84f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                            <<Aka+TTerm>> => ( 0p,     84f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    76 (  1):               <<Aka+TTerm>> => ( 0p,     76f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    75 (  1):                         nil => ( 0p,     75f,  0o,    1+ 0i TList:(Mu -> Mu -> Mu))
#    69 (  1):                collect-args => ( 0p,     69f,  0o,    1+ 0i :(Mu -> Mu -> TTerm -> TList -> TTerm -> Mu))
#    66 (  2):               <<Aka+TTerm>> => ( 0p,     66f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                            <<Aka+TTerm>> => ( 0p,     66f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    64 (  1):               <<Aka+TTerm>> => ( 0p,     64f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    55 (  1):               <<Aka+TTerm>> => ( 0p,     55f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    54 (  1):               <<Aka+TTerm>> => ( 0p,     54f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    50 (  3):                   <<TTerm>> => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                                <<TTerm>> => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                            <<Aka+TTerm>> => ( 0p,     50f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    38 (  1):                    Term-eq? => ( 0p,     38f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#    31 (  1):                           Y => ( 0p,     31f,  0o,    2+ 0i :(Callable -> Mu))
#    30 (  1):                           B => ( 0p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    29 (  1):                        VarT => ( 0p,     29f,  0o,    1+ 0i :(Str -> TTerm))
#    17 (  1):                  foldl(1/3) => ( 0p,     17f,  0o,    0+ 0i :(Mu -> TList -> Mu))
#     8 (  1):                       foldl => (17p,      8f,  0o,    2+ 0i :(Callable -> Mu -> TList -> Mu))
#     5 (  1):                           I => ( 0p,      5f,  0o,    1+ 0i :(Mu -> Mu))
#     4 (  2):                           K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      K^2 => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu))
#     2 (  2):                      findFP => ( 0p,      2f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),
#                           findFP-inMaybe => ( 0p,      2f,  0o,    1+ 0i :(Callable -> Mu))
#     0 ( 19):                         _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),
#                                      _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                      not => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool)),
#                                     _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                     caar => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    free? => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    subst => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TMaybe)),
#                                 map-iter => ( 0p,      0f,  0o,    0+ 1i :(Callable -> Mu -> Mu)),
#                                subst-seq => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TList -> TMaybe)),
#                               betaReduce => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                             Term->source => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> Str)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 0i :(TTerm -> TList)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 1i :(TTerm -> TList)),
#                        subst-alpha_Maybe => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TMaybe)),
#                       findFP-inMaybe_dbg => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                       subst-alpha_direct => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TTerm)),
#                    findFP-inMaybe_dbgXXX => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                    subst-par-alpha_Maybe => ( 0p,      0f,  0o,    1+ 0i :(TList -> TTerm -> TMaybe)),
#                   free-varNames-internal => ( 1p,      0f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList))
#     =_β0   λf1.λf2.λf3.λf4.λf5.(λy.λ_.y) ((λg.λh.(λy.λ_.y) (g h)) ((λg.λh.(λy.λ_.y) (g h)) (λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5)))
#     =_β1   λf1.λf2.λf3.λf4.λf5.λ_.(λg.λh.(λy.λ_.y) (g h)) ((λg.λh.(λy.λ_.y) (g h)) (λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5))
#     =_β2   λf1.λf2.λf3.λf4.λf5.λ_.λh.(λy.λ_.y) ((λg.λh.(λy.λ_.y) (g h)) (λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5) h)
#     =_β3   λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.(λg.λh.(λy.λ_.y) (g h)) (λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5) h
#     =_β4   λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.(λy.λ_.y) ((λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5) h)
#     =_β5   λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.(λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5) h
#     =_β6   λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) h f5
#     =_β7   λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) h f4 f5
#     =_β8   λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.(λk.(λk.(λx.x) k f1) k f2) h f3 f4 f5
#     =_β9   λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.(λk.(λx.x) k f1) h f2 f3 f4 f5
#     =_β10  λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.(λx.x) h f1 f2 f3 f4 f5
#     =_β11  λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.h f1 f2 f3 f4 f5
#     (11 steps)
#     =_β0   λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.h f1 f2 f3 f4 f5
#     (0 steps)
# 9.14 = 8.84 + 0.30 sec (97% + 3%) consumed for beta-reduction
ok 7 - λf1.λf2.λf3.λf4.λf5.(λy.λ_.y) ((λg.λh.(λy.λ_.y) (g h)) ((λg.λh.(λy.λ_.y) (g h)) (λk.(λk.(λk.(λk.(λk.(λx.x) k f1) k f2) k f3) k f4) k f5)))  =_β*  λf1.λf2.λf3.λf4.λf5.λ_.λh.λ_.λ_.h f1 f2 f3 f4 f5  
# CurryStats: (29p,  16669f,  0o, 2728+5i)
#  1612 (  2):                       π2->2 => ( 0p,   1612f,  0o,    1+ 0i :(Mu -> Mu -> Mu)),
#                                Pair->snd => ( 0p,   1612f,  0o,    1+ 0i :(TPair -> Mu))
#  1588 (  1):                        Pair => ( 0p,   1588f,  0o,    1+ 0i :(Mu -> Mu -> Mu))
#  1503 (  1):    Term->srcLesser-internal => ( 0p,   1503f,  0o,    1+ 0i :(TTerm -> TPair))
#   491 (  2):                       π2->1 => ( 0p,    491f,  0o,    1+ 0i :(Mu -> Mu -> Mu)),
#                                Pair->fst => ( 0p,    491f,  0o,    1+ 0i :(TPair -> Mu))
#   355 (  1):                     Str-eq? => ( 0p,    355f,  0o,    1+ 0i :(Str -> Str -> TBool))
#   288 (  1):                        LamT => ( 0p,    288f,  0o,    1+ 0i :(Str -> TTerm -> TTerm))
#   263 (  1):               free-varName? => ( 0p,    263f,  0o,    1+ 0i :(Str -> TTerm -> TBool))
#   260 (  1):                        AppT => ( 0p,    260f,  0o,    1+ 0i :(TTerm -> TTerm -> TTerm))
#   258 (  1):                      #false => ( 0p,    258f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   256 (  1):          betaContract_multi => ( 0p,    256f,  0o,    1+ 0i :(TTerm -> Mu))
#   249 (  1):                        Some => ( 0p,    249f,  0o,    1+ 0i :(Mu -> Mu))
#   232 (  1):               <<Aka+TTerm>> => ( 0p,    232f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   154 (  1):               <<Aka+TTerm>> => ( 0p,    154f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   152 (  1):                        None => ( 0p,    152f,  0o,    1+ 0i TMaybe:(Mu -> Mu -> Mu))
#   147 (  1):                       #true => ( 0p,    147f,  0o,    1+ 0i TBool:(Mu -> Mu -> Mu))
#   135 (  1):               <<Aka+TTerm>> => ( 0p,    135f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   133 (  1):                        cons => ( 0p,    133f,  0o,    1+ 0i :(Mu -> TList -> TList))
#   128 (  1):      subst-par-alpha_direct => ( 0p,    128f,  0o,    1+ 0i :(TList -> TTerm -> TTerm))
#   127 (  1):               <<Aka+TTerm>> => ( 0p,    127f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   118 (  1):                       first => ( 0p,    118f,  0o,    1+ 0i :(Callable -> TList -> Mu))
#   114 (  1):                         nil => ( 0p,    114f,  0o,    1+ 0i TList:(Mu -> Mu -> Mu))
#   106 (  1):                collect-args => ( 0p,    106f,  0o,    1+ 0i :(Mu -> Mu -> TTerm -> TList -> TTerm -> Mu))
#   105 (  1):               <<Aka+TTerm>> => ( 0p,    105f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   104 (  1):               <<Aka+TTerm>> => ( 0p,    104f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#   102 (  1):               <<Aka+TTerm>> => ( 0p,    102f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    84 (  1):               <<Aka+TTerm>> => ( 0p,     84f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    76 (  1):               <<Aka+TTerm>> => ( 0p,     76f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    70 (  1):               <<Aka+TTerm>> => ( 0p,     70f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    66 (  2):               <<Aka+TTerm>> => ( 0p,     66f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                            <<Aka+TTerm>> => ( 0p,     66f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    58 (  1):                    Term-eq? => ( 0p,     58f,  0o,    1+ 0i :(TTerm -> TTerm -> TBool))
#    55 (  1):               <<Aka+TTerm>> => ( 0p,     55f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    54 (  1):               <<Aka+TTerm>> => ( 0p,     54f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu))
#    50 (  4):                   <<TTerm>> => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                                <<TTerm>> => ( 0p,     50f,  0o,    1+ 0i TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                            <<Aka+TTerm>> => ( 0p,     50f,  0o,    1+ 0i Aka+TTerm:(Callable -> Callable -> Callable -> Callable -> Mu)),
#                            Term->srcLess => ( 0p,     50f,  0o,    1+ 0i :(TTerm -> Str))
#    31 (  1):                           Y => ( 0p,     31f,  0o,    2+ 0i :(Callable -> Mu))
#    30 (  1):                           B => ( 0p,     30f,  0o,    1+ 0i :(Callable -> Callable -> Mu))
#    29 (  1):                        VarT => ( 0p,     29f,  0o,    1+ 0i :(Str -> TTerm))
#    28 (  1):                  foldl(1/3) => ( 0p,     28f,  0o,    0+ 0i :(Mu -> TList -> Mu))
#    23 (  1):                       foldl => (28p,     23f,  0o,    2+ 0i :(Callable -> Mu -> TList -> Mu))
#     6 (  1):                           I => ( 0p,      6f,  0o,    1+ 0i :(Mu -> Mu))
#     4 (  2):                           K => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu)),
#                                      K^2 => ( 0p,      4f,  0o,    1+ 0i :(Mu -> Mu))
#     2 (  2):                      findFP => ( 0p,      2f,  0o,    1+ 0i :(Callable -> Callable -> Mu)),
#                           findFP-inMaybe => ( 0p,      2f,  0o,    1+ 0i :(Callable -> Mu))
#     0 ( 19):                         _if => ( 0p,      0f,  0o,    1+ 0i :(TBool -> Callable -> Callable -> Mu)),
#                                      _or => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                      not => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool)),
#                                     _and => ( 0p,      0f,  0o,    1+ 0i :(TBool -> TBool -> TBool)),
#                                     caar => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    free? => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                                    subst => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TMaybe)),
#                                 map-iter => ( 0p,      0f,  0o,    0+ 1i :(Callable -> Mu -> Mu)),
#                                subst-seq => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> TList -> TMaybe)),
#                               betaReduce => ( 0p,      0f,  0o,    0+ 1i :(Mu -> Mu)),
#                             Term->source => ( 0p,      0f,  0o,    1+ 0i :(TTerm -> Str)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 0i :(TTerm -> TList)),
#                            free-varNames => ( 0p,      0f,  0o,    0+ 1i :(TTerm -> TList)),
#                        subst-alpha_Maybe => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TMaybe)),
#                       findFP-inMaybe_dbg => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                       subst-alpha_direct => ( 0p,      0f,  0o,    1+ 0i :(Str -> TTerm -> TTerm -> TTerm)),
#                    findFP-inMaybe_dbgXXX => ( 0p,      0f,  0o,    1+ 0i :(Callable -> Mu)),
#                    subst-par-alpha_Maybe => ( 0p,      0f,  0o,    1+ 0i :(TList -> TTerm -> TMaybe)),
#                   free-varNames-internal => ( 1p,      0f,  0o,    1+ 0i :(TList -> TList -> TTerm -> TList))

Output completed (1 min 13 sec consumed) - Normal Termination