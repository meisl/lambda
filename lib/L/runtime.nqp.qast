──CompUnit+{StrByDump}
  └─:Block
    ╟○ lexical @ARGS :decl(param) :slurpy(1)
    ╟○ lexical GLOBALish :decl(static) :default(P6opaque)
    ╟○ lexical $?PACKAGE :decl(static) :default(P6opaque)
    ╟○ lexical EXPORT :decl(static) :default(P6opaque)
    ╟○ lexical .λsrc :decl(var)
    ╟○ lexical %info :decl(var)
    ╟─bind
    ║ ├○ lexical .LAMFIELD_ID :decl(var)
    ║ └─:Block  ««"{ 0 }"
    ║   ╙◙ IVal 0
    ╟─bind
    ║ ├○ lexical .LAMFIELD_CODE :decl(var)
    ║ └─:Block  ««"{ 1 }"
    ║   ╙◙ IVal 1
    ╟─bind
    ║ ├○ lexical .LAMFIELD_FREEVARS :decl(var)
    ║ └─:Block  ««"{ 2 }"
    ║   ╙◙ IVal 2
    ╟─bind
    ║ ├○ lexical .lam2id :decl(var)
    ║ └─:Block  ««"{ $lam[LAMFIELD_ID()] }"
    ║   ╟○ lexical $lam :decl(param)
    ║   ╙─atpos
    ║     ├○ lexical $lam
    ║     └◙ IVal 0
    ╟─bind
    ║ ├○ lexical .lam2code :decl(var)
    ║ └─:Block  ««"{ $lam[LAMFIELD_CODE()] }"
    ║   ╟○ lexical $lam :decl(param)
    ║   ╙─atpos
    ║     ├○ lexical $lam
    ║     └◙ IVal 1
    ╟─bind
    ║ ├○ lexical .lam2fvs :decl(var)
    ║ └─:Block  ««"{ sublist($lam, LAMFIELD_FREEVARS()) }"
    ║   ╟○ lexical $lam :decl(param)
    ║   ╙─call .sublist  ««"$lam, LAMFIELD_FREEVARS()"
    ║     ├○ lexical $lam
    ║     └◙ IVal 2
    ╟─bind
    ║ ├○ lexical .int2str :decl(var)
    ║ └─:Block  ««"{ ~$i }"
    ║   ╟○ lexical $i :decl(param)
    ║   ╙─stringify  ««"~"
    ║     └○ lexical $i
    ╟─bind
    ║ ├○ lexical .num2str :decl(var)
    ║ └─:Block  ««"{ ~$n }"
    ║   ╟○ lexical $n :decl(param)
    ║   ╙─stringify  ««"~"
    ║     └○ lexical $n
    ╟─bind
    ║ ├○ lexical .strLit :decl(var)
    ║ └─:Block  ««"{ '\"' ~ nqp::escape($s) ~ '\"' }"
    ║   ╟○ lexical $s :decl(param)
    ║   ╙─concat  ««"~"
    ║     ├─concat  ««"~"
    ║     │ ├◙ SVal "\""
    ║     │ └─escape  ««"nqp::escape($s)"
    ║     │   └○ lexical $s
    ║     └◙ SVal "\""
    ╟─bind
    ║ ├○ lexical .force :decl(var)
    ║ └─:Block  ««"{\n    nqp::isinvokable($v) ?? $v() !! $v;\n}"
    ║   ╟○ lexical $v :decl(param)
    ║   ╙─if  ««"?? $v() !!"
    ║     ├─isinvokable  ««"nqp::isinvokable($v)"
    ║     │ └○ lexical $v
    ║     ├─call  ««""
    ║     │ └○ lexical $v
    ║     └○ lexical $v
    ╟─bind
    ║ ├○ lexical .delayMemo :decl(var)
    ║ └─:Block  ««"{\n    my int $wasRun := 0;\n    my $result := nqp:"...
    ║   ╟○ lexical $block :decl(param)
    ║   ╟○ lexical $wasRun :decl(var)
    ║   ╟○ lexical $result :decl(var)
    ║   ╟○ lexical $out :decl(var)
    ║   ╟─bind  ««"int $wasRun := 0"
    ║   ║ ├○ lexical $wasRun
    ║   ║ └◙ IVal 0
    ║   ╟─bind  ««"$result := nqp::null"
    ║   ║ ├○ lexical $result
    ║   ║ └─null  ««"nqp::null"
    ║   ╟─bind  ««"$out := {\n        if $wasRun {\n            $resul"...
    ║   ║ ├○ lexical $out
    ║   ║ └─:Block  ««"{\n        if $wasRun {\n            $result;\n    "...
    ║   ║   ╙─if  ««"$wasRun {\n            $result;\n        }"
    ║   ║     ├○ lexical $wasRun
    ║   ║     ├○ lexical $result
    ║   ║     └─:Stmts  ««"{\n            $wasRun := 1;\n            $result :"...
    ║   ║       ├─bind  ««":="
    ║   ║       │ ├○ lexical $wasRun
    ║   ║       │ └◙ IVal 1
    ║   ║       └─bind  ««":="
    ║   ║         ├○ lexical $result
    ║   ║         └─call  ««""
    ║   ║           └○ lexical $block
    ║   ╙○ lexical $out
    ╟─bind
    ║ ├○ lexical .sublist :decl(var)
    ║ └─:Block  ««"{\n    my int $n     := nqp::elems(@list);\n    my "...
    ║   ╟○ lexical @list :decl(param)
    ║   ╟○ lexical $from :decl(param)
    ║   ╟○ lexical $n :decl(var)
    ║   ╟○ lexical $count :decl(var)
    ║   ╟○ lexical $to :decl(var)
    ║   ╟○ lexical @out :decl(var)
    ║   ╟─bind  ««"int $n     := nqp::elems(@list)"
    ║   ║ ├○ lexical $n
    ║   ║ └─elems  ««"nqp::elems(@list)"
    ║   ║   └○ lexical @list
    ║   ╟─bind  ««"int $count := $n"
    ║   ║ ├○ lexical $count
    ║   ║ └○ lexical $n
    ║   ╟─bind  ««"int $to    := $from + $count"
    ║   ║ ├○ lexical $to
    ║   ║ └─add_n  ««"+"
    ║   ║   ├○ lexical $from
    ║   ║   └○ lexical $count
    ║   ╟─bind  ««"@out   := []"
    ║   ║ ├○ lexical @out
    ║   ║ └─list
    ║   ╟─if  ««"$to > $n {\n        $to := $n\n    }"
    ║   ║ ├─isgt_n  ««">"
    ║   ║ │ ├○ lexical $to
    ║   ║ │ └○ lexical $n
    ║   ║ └─bind  ««":="
    ║   ║   ├○ lexical $to
    ║   ║   └○ lexical $n
    ║   ╟─while  ««"$from < $to {\n        @out.push(@list[$from]);\n  "...
    ║   ║ ├─islt_n  ««"<"
    ║   ║ │ ├○ lexical $from
    ║   ║ │ └○ lexical $to
    ║   ║ ├─:Stmts  ««"{\n        @out.push(@list[$from]);\n        $from+"...
    ║   ║ │ ├─push  ««"@list[$from]"
    ║   ║ │ │ ├○ lexical @out
    ║   ║ │ │ └─atpos
    ║   ║ │ │   ├○ lexical @list
    ║   ║ │ │   └○ lexical $from
    ║   ║ │ └─postinc  ««"++"
    ║   ║ │   └○ lexical $from
    ║   ║ └◙ IVal 1 :named("nohandler")
    ║   ╙○ lexical @out
    ╟─bind
    ║ ├○ lexical .lam2info :decl(var)
    ║ └─:Block  ««"{\n    my $id      := lam2id($lambda);\n    my $idx"...
    ║   ╟○ lexical $lambda :decl(param)
    ║   ╟○ lexical $id :decl(var)
    ║   ╟○ lexical $idx :decl(var)
    ║   ╟○ lexical $infoIt :decl(var)
    ║   ╟○ lexical $binder :decl(var)
    ║   ╟○ lexical $from :decl(var)
    ║   ╟○ lexical $length :decl(var)
    ║   ╟○ lexical %out :decl(var)
    ║   ╟○ lexical $varsIt :decl(var)
    ║   ╟○ lexical $namesIt :decl(var)
    ║   ╟○ lexical %fvs :decl(var)
    ║   ╟─bind  ««"$id      := lam2id($lambda)"
    ║   ║ ├○ lexical $id
    ║   ║ └─atpos  ««"$lambda"
    ║   ║   ├○ lexical $lambda
    ║   ║   └◙ IVal 0
    ║   ╟─bind  ««"$idx     := nqp::radix(10, $id, 1, 0)[0]"
    ║   ║ ├○ lexical $idx
    ║   ║ └─atpos
    ║   ║   ├─radix  ««"nqp::radix(10, $id, 1, 0)"
    ║   ║   │ ├◙ IVal 10
    ║   ║   │ ├○ lexical $id
    ║   ║   │ ├◙ IVal 1
    ║   ║   │ └◙ IVal 0
    ║   ║   └◙ IVal 0
    ║   ╟─bind  ««"$infoIt  := nqp::iterator(nqp::split(' ', %info<λ>["...
    ║   ║ ├○ lexical $infoIt
    ║   ║ └─iterator  ««"nqp::iterator(nqp::split(' ', %info<λ>[$idx]))"
    ║   ║   └─split  ««"nqp::split(' ', %info<λ>[$idx])"
    ║   ║     ├◙ SVal " "
    ║   ║     └─atpos
    ║   ║       ├─atkey
    ║   ║       │ ├○ lexical %info
    ║   ║       │ └◙ SVal "λ"
    ║   ║       └○ lexical $idx
    ║   ╟─bind  ««"$binder  := nqp::shift($infoIt)"
    ║   ║ ├○ lexical $binder
    ║   ║ └─shift  ««"nqp::shift($infoIt)"
    ║   ║   └○ lexical $infoIt
    ║   ╟─bind  ««"$from    := nqp::shift($infoIt)"
    ║   ║ ├○ lexical $from
    ║   ║ └─shift  ««"nqp::shift($infoIt)"
    ║   ║   └○ lexical $infoIt
    ║   ╟─bind  ««"$length  := nqp::shift($infoIt)"
    ║   ║ ├○ lexical $length
    ║   ║ └─shift  ««"nqp::shift($infoIt)"
    ║   ║   └○ lexical $infoIt
    ║   ╟─bind  ««"%out     := nqp::hash(\n        'id',       $id,\n "...
    ║   ║ ├○ lexical %out
    ║   ║ └─hash  ««"nqp::hash(\n        'id',       $id,\n        'idx'"...
    ║   ║   ├◙ SVal "id"
    ║   ║   ├○ lexical $id
    ║   ║   ├◙ SVal "idx"
    ║   ║   ├○ lexical $idx
    ║   ║   ├◙ SVal "binder"
    ║   ║   ├○ lexical $binder
    ║   ║   ├◙ SVal "from"
    ║   ║   ├○ lexical $from
    ║   ║   ├◙ SVal "length"
    ║   ║   ├○ lexical $length
    ║   ║   ├◙ SVal "src"
    ║   ║   └─substr  ««"nqp::substr($λsrc, $from, $length)"
    ║   ║     ├○ lexical .λsrc
    ║   ║     ├○ lexical $from
    ║   ║     └○ lexical $length
    ║   ╟─bind  ««"$varsIt  := nqp::iterator(lam2fvs($lambda))"
    ║   ║ ├○ lexical $varsIt
    ║   ║ └─iterator  ««"nqp::iterator(lam2fvs($lambda))"
    ║   ║   └─call .sublist  ««"$lambda"
    ║   ║     ├○ lexical $lambda
    ║   ║     └◙ IVal 2
    ║   ╟─bind  ««"$namesIt := $infoIt"
    ║   ║ ├○ lexical $namesIt
    ║   ║ └○ lexical $infoIt
    ║   ╟─bind  ««"%fvs     := {}"
    ║   ║ ├○ lexical %fvs
    ║   ║ └─hash
    ║   ╟─while  ««"$varsIt {\n        %fvs{nqp::shift($namesIt)} := nq"...
    ║   ║ ├○ lexical $varsIt
    ║   ║ ├─bindkey
    ║   ║ │ ├○ lexical %fvs
    ║   ║ │ ├─shift  ««"nqp::shift($namesIt)"
    ║   ║ │ │ └○ lexical $namesIt
    ║   ║ │ └─shift  ««"nqp::shift($varsIt)"
    ║   ║ │   └○ lexical $varsIt
    ║   ║ └◙ IVal 1 :named("nohandler")
    ║   ╟─bindkey
    ║   ║ ├○ lexical %out
    ║   ║ ├◙ SVal "freeVars"
    ║   ║ └○ lexical %fvs
    ║   ╙○ lexical %out
    ╟─bind
    ║ ├○ lexical .typecase :decl(var)
    ║ └─:Block  ««"{\n    #say('>>>typecase(', nqp::reprname($subject)"...
    ║   ╟○ lexical $subject :decl(param)
    ║   ╟○ lexical %callbacks :decl(param) :named(1) :slurpy(1)
    ║   ╟○ lexical $otherwise :decl(var)
    ║   ╟○ lexical $cbKey :decl(var)
    ║   ╟○ lexical $cb :decl(var)
    ║   ╟─bind  ««"$otherwise := nqp::defor(\n        %callbacks<other"...
    ║   ║ ├○ lexical $otherwise
    ║   ║ └─defor  ««"nqp::defor(\n        %callbacks<otherwise>,\n      "...
    ║   ║   ├─atkey
    ║   ║   │ ├○ lexical %callbacks
    ║   ║   │ └◙ SVal "otherwise"
    ║   ║   └─:Block  ««"{ # compiler should see that this needs not be a cl"...
    ║   ║     ╟○ lexical $x :decl(param)
    ║   ║     ╙─die  ««"nqp::die('typecase: fell through due to missing \"o"...
    ║   ║       └─concat  ««"~"
    ║   ║         ├◙ SVal "typecase: fell through due to missing \"otherwise\"-callback: "
    ║   ║         └─reprname  ««"nqp::reprname($subject)"
    ║   ║           └○ lexical $subject
    ║   ╟─bind  ««"$cbKey := nqp::null"
    ║   ║ ├○ lexical $cbKey
    ║   ║ └─null  ««"nqp::null"
    ║   ╟─if  ««"nqp::islist($subject) {\n        my $id := $subject"...
    ║   ║ ├─islist  ««"nqp::islist($subject)"
    ║   ║ │ └○ lexical $subject
    ║   ║ ├─:Block :blocktype(immediate)  ««"{\n        my $id := $subject[0];\n        my $tag "...
    ║   ║ │ ╟○ lexical $id :decl(var)
    ║   ║ │ ╟○ lexical $tag :decl(var)
    ║   ║ │ ╟─bind  ««"$id := $subject[0]"
    ║   ║ │ ║ ├○ lexical $id
    ║   ║ │ ║ └─atpos
    ║   ║ │ ║   ├○ lexical $subject
    ║   ║ │ ║   └◙ IVal 0
    ║   ║ │ ╟─bind  ««"$tag := nqp::substr($id, 0, 1)"
    ║   ║ │ ║ ├○ lexical $tag
    ║   ║ │ ║ └─substr  ««"nqp::substr($id, 0, 1)"
    ║   ║ │ ║   ├○ lexical $id
    ║   ║ │ ║   ├◙ IVal 0
    ║   ║ │ ║   └◙ IVal 1
    ║   ║ │ ╙─if  ««"$tag eq 'λ' {\n            $cbKey := $tag;\n        }"
    ║   ║ │   ├─iseq_s  ««"eq"
    ║   ║ │   │ ├○ lexical $tag
    ║   ║ │   │ └◙ SVal "λ"
    ║   ║ │   ├─bind  ««":="
    ║   ║ │   │ ├○ lexical $cbKey
    ║   ║ │   │ └○ lexical $tag
    ║   ║ │   └─if  ««"nqp::elems($subject) == 0 {\n                nqp::d"...
    ║   ║ │     ├─iseq_n  ««"=="
    ║   ║ │     │ ├─elems  ««"nqp::elems($subject)"
    ║   ║ │     │ │ └○ lexical $subject
    ║   ║ │     │ └◙ IVal 0
    ║   ║ │     ├─die  ««"nqp::die('typecase: unsupported low-level list type"...
    ║   ║ │     │ └◙ SVal "typecase: unsupported low-level list type - empty"
    ║   ║ │     └─die  ««"nqp::die('typecase: unsupported low-level list type"...
    ║   ║ │       └─concat  ««"~"
    ║   ║ │         ├◙ SVal "typecase: unsupported low-level list type - invalid tag "
    ║   ║ │         └─reprname  ««"nqp::reprname($tag)"
    ║   ║ │           └○ lexical $tag
    ║   ║ └─if  ««"nqp::isstr($subject) { $cbKey := 'str';\n        }"
    ║   ║   ├─isstr  ««"nqp::isstr($subject)"
    ║   ║   │ └○ lexical $subject
    ║   ║   ├─bind  ««":="
    ║   ║   │ ├○ lexical $cbKey
    ║   ║   │ └◙ SVal "str"
    ║   ║   └─if  ««"nqp::isint($subject) { $cbKey := 'int';\n        }"
    ║   ║     ├─isint  ««"nqp::isint($subject)"
    ║   ║     │ └○ lexical $subject
    ║   ║     ├─bind  ««":="
    ║   ║     │ ├○ lexical $cbKey
    ║   ║     │ └◙ SVal "int"
    ║   ║     └─if  ««"nqp::isnum($subject) { $cbKey := 'num';\n        }"
    ║   ║       ├─isnum  ««"nqp::isnum($subject)"
    ║   ║       │ └○ lexical $subject
    ║   ║       ├─bind  ««":="
    ║   ║       │ ├○ lexical $cbKey
    ║   ║       │ └◙ SVal "num"
    ║   ║       └─die  ««"nqp::die('typecase: unsupported low-level type ' ~ "...
    ║   ║         └─concat  ««"~"
    ║   ║           ├◙ SVal "typecase: unsupported low-level type "
    ║   ║           └─reprname  ««"nqp::reprname($subject)"
    ║   ║             └○ lexical $subject
    ║   ╟─bind  ««"$cb := nqp::defor(%callbacks{$cbKey}, $otherwise)"
    ║   ║ ├○ lexical $cb
    ║   ║ └─defor  ««"nqp::defor(%callbacks{$cbKey}, $otherwise)"
    ║   ║   ├─atkey
    ║   ║   │ ├○ lexical %callbacks
    ║   ║   │ └○ lexical $cbKey
    ║   ║   └○ lexical $otherwise
    ║   ╙─call  ««"$subject"
    ║     ├○ lexical $cb
    ║     └○ lexical $subject
    ╟─bind
    ║ ├○ lexical .strOut :decl(var)
    ║ └─:Block  ««"{\n    typecase(force($v),\n        :λ(-> $lambda {"...
    ║   ╟○ lexical $v :decl(param)
    ║   ╟○ lexical $indent :decl(param) :default(SVal "")
    ║   ╟○ lexical %done :decl(param) :default(hash)
    ║   ╙─call .typecase  ««"force($v),\n        :λ(-> $lambda { # compiler shou"...
    ║     ├─call .force  ««"$v"
    ║     │ └○ lexical $v
    ║     ├─:Block :named("λ")  ««"{ # compiler should see that this needs not be a cl"...
    ║     │ ╟○ lexical $lambda :decl(param)
    ║     │ ╟○ lexical %info :decl(var)
    ║     │ ╟○ lexical $src :decl(var)
    ║     │ ╟─bind  ««"%info := lam2info($lambda)"
    ║     │ ║ ├○ lexical %info
    ║     │ ║ └─call .lam2info  ««"$lambda"
    ║     │ ║   └○ lexical $lambda
    ║     │ ╟─bind  ««"$src := %info<src>"
    ║     │ ║ ├○ lexical $src
    ║     │ ║ └─atkey
    ║     │ ║   ├○ lexical %info
    ║     │ ║   └◙ SVal "src"
    ║     │ ╟─for  ««"%info<freeVars> {\n                my $fvName  := $"...
    ║     │ ║ ├─atkey
    ║     │ ║ │ ├○ lexical %info
    ║     │ ║ │ └◙ SVal "freeVars"
    ║     │ ║ ├─:Block :blocktype(immediate)  ««"{\n                my $fvName  := $_.key;\n        "...
    ║     │ ║ │ ╟○ lexical $fvName :decl(var)
    ║     │ ║ │ ╟○ lexical $fv :decl(var)
    ║     │ ║ │ ╟○ lexical $pre :decl(var)
    ║     │ ║ │ ╟○ lexical $flatVal :decl(var)
    ║     │ ║ │ ╟○ lexical $doneKey :decl(var)
    ║     │ ║ │ ╟○ lexical $_ :decl(param)
    ║     │ ║ │ ╟─bind  ««"$fvName  := $_.key"
    ║     │ ║ │ ║ ├○ lexical $fvName
    ║     │ ║ │ ║ └─iterkey_s  ««".key"
    ║     │ ║ │ ║   └○ lexical $_
    ║     │ ║ │ ╟─bind  ««"$fv      := $_.value"
    ║     │ ║ │ ║ ├○ lexical $fv
    ║     │ ║ │ ║ └─iterval  ««".value"
    ║     │ ║ │ ║   └○ lexical $_
    ║     │ ║ │ ╟─bind  ««"$pre     := \"# where $fvName = \""
    ║     │ ║ │ ║ ├○ lexical $pre
    ║     │ ║ │ ║ └─concat
    ║     │ ║ │ ║   ├─concat
    ║     │ ║ │ ║   │ ├◙ SVal "# where "
    ║     │ ║ │ ║   │ └○ lexical $fvName
    ║     │ ║ │ ║   └◙ SVal " = "
    ║     │ ║ │ ╟─bind  ««"$flatVal := typecase($fv,\n                    :λ(-"...
    ║     │ ║ │ ║ ├○ lexical $flatVal
    ║     │ ║ │ ║ └─call .typecase  ««"$fv,\n                    :λ(-> $x { nqp::null }), "...
    ║     │ ║ │ ║   ├○ lexical $fv
    ║     │ ║ │ ║   ├─:Block :named("λ")  ««"{ nqp::null }"
    ║     │ ║ │ ║   │ ╟○ lexical $x :decl(param)
    ║     │ ║ │ ║   │ ╙─null  ««"nqp::null"
    ║     │ ║ │ ║   ├○ lexical .strLit :named("str")
    ║     │ ║ │ ║   ├○ lexical .int2str :named("int")
    ║     │ ║ │ ║   └○ lexical .num2str :named("num")
    ║     │ ║ │ ╟─bind  ««"$doneKey := nqp::isnull($flatVal)\n                "...
    ║     │ ║ │ ║ ├○ lexical $doneKey
    ║     │ ║ │ ║ └─if  ««"?? $pre ~ lam2id($fv)\n                    !!"
    ║     │ ║ │ ║   ├─isnull  ««"nqp::isnull($flatVal)"
    ║     │ ║ │ ║   │ └○ lexical $flatVal
    ║     │ ║ │ ║   ├─concat  ««"~"
    ║     │ ║ │ ║   │ ├○ lexical $pre
    ║     │ ║ │ ║   │ └─atpos  ««"$fv"
    ║     │ ║ │ ║   │   ├○ lexical $fv
    ║     │ ║ │ ║   │   └◙ IVal 0
    ║     │ ║ │ ║   └─concat  ««"~"
    ║     │ ║ │ ║     ├○ lexical $pre
    ║     │ ║ │ ║     └○ lexical $flatVal
    ║     │ ║ │ ╙─unless  ««"%done{$doneKey} {\n                    %done{$doneK"...
    ║     │ ║ │   ├─atkey
    ║     │ ║ │   │ ├○ lexical %done
    ║     │ ║ │   │ └○ lexical $doneKey
    ║     │ ║ │   └─:Stmts  ««"{\n                    %done{$doneKey} := 1;\n     "...
    ║     │ ║ │     ├─bindkey
    ║     │ ║ │     │ ├○ lexical %done
    ║     │ ║ │     │ ├○ lexical $doneKey
    ║     │ ║ │     │ └◙ IVal 1
    ║     │ ║ │     └─bind  ««":="
    ║     │ ║ │       ├○ lexical $src
    ║     │ ║ │       └─concat  ««"~"
    ║     │ ║ │         ├─concat  ««"~"
    ║     │ ║ │         │ ├─concat  ««"~"
    ║     │ ║ │         │ │ ├○ lexical $src
    ║     │ ║ │         │ │ └◙ SVal "\n"
    ║     │ ║ │         │ └○ lexical $indent
    ║     │ ║ │         └─if  ««"?? $pre ~ strOut($fv, $indent ~ '#' ~ nqp::x(' ', n"...
    ║     │ ║ │           ├─isnull  ««"nqp::isnull($flatVal)"
    ║     │ ║ │           │ └○ lexical $flatVal
    ║     │ ║ │           ├─concat  ««"~"
    ║     │ ║ │           │ ├○ lexical $pre
    ║     │ ║ │           │ └─call .strOut  ««"$fv, $indent ~ '#' ~ nqp::x(' ', nqp::chars($pre) -"...
    ║     │ ║ │           │   ├○ lexical $fv
    ║     │ ║ │           │   ├─concat  ««"~"
    ║     │ ║ │           │   │ ├─concat  ««"~"
    ║     │ ║ │           │   │ │ ├○ lexical $indent
    ║     │ ║ │           │   │ │ └◙ SVal "#"
    ║     │ ║ │           │   │ └─x  ««"nqp::x(' ', nqp::chars($pre) - 1)"
    ║     │ ║ │           │   │   ├◙ SVal " "
    ║     │ ║ │           │   │   └─sub_n  ««"-"
    ║     │ ║ │           │   │     ├─chars  ««"nqp::chars($pre)"
    ║     │ ║ │           │   │     │ └○ lexical $pre
    ║     │ ║ │           │   │     └◙ IVal 1
    ║     │ ║ │           │   └○ lexical %done
    ║     │ ║ │           └○ lexical $doneKey
    ║     │ ║ └◙ IVal 1 :named("nohandler")
    ║     │ ╙○ lexical $src
    ║     ├○ lexical .strLit :named("str")
    ║     ├○ lexical .int2str :named("int")
    ║     └○ lexical .num2str :named("num")
    ╟─bind
    ║ ├○ lexical .apply1 :decl(var)
    ║ └─:Block  ««"{\n    my $result := typecase(force($f),\n        :"...
    ║   ╟○ lexical $f :decl(param)
    ║   ╟○ lexical $a1 :decl(param)
    ║   ╟○ lexical $result :decl(var)
    ║   ╟─bind  ««"$result := typecase(force($f),\n        :λ(&lam2cod"...
    ║   ║ ├○ lexical $result
    ║   ║ └─call  ««"$a1"
    ║   ║   ├─call .typecase  ««"force($f),\n        :λ(&lam2code),\n        :otherw"...
    ║   ║   │ ├─call .force  ««"$f"
    ║   ║   │ │ └○ lexical $f
    ║   ║   │ ├○ lexical .lam2code :named("λ")
    ║   ║   │ └─:Block :named("otherwise")  ««"{\n            nqp::die('ERROR: cannot apply ' ~ st"...
    ║   ║   │   ╟○ lexical $x :decl(param)
    ║   ║   │   ╙─die  ««"nqp::die('ERROR: cannot apply ' ~ strOut($x) ~ ' to"...
    ║   ║   │     └─concat  ««"~"
    ║   ║   │       ├─concat  ««"~"
    ║   ║   │       │ ├─concat  ««"~"
    ║   ║   │       │ │ ├◙ SVal "ERROR: cannot apply "
    ║   ║   │       │ │ └─call .strOut  ««"$x"
    ║   ║   │       │ │   └○ lexical $x
    ║   ║   │       │ └◙ SVal " to "
    ║   ║   │       └─call .strOut  ««"$a1"
    ║   ║   │         └○ lexical $a1
    ║   ║   └○ lexical $a1
    ║   ╙─call .force  ««"$result"
    ║     └○ lexical $result
    ╟─bind
    ║ ├○ lexical .say :decl(var)
    ║ └─:Block  ««"{\n    my $it := nqp::iterator(@args);\n    my $s  "...
    ║   ╟○ lexical @args :decl(param) :slurpy(1)
    ║   ╟○ lexical $it :decl(var)
    ║   ╟○ lexical $s :decl(var)
    ║   ╟─bind  ««"$_"
    ║   ║ ├○ lexical $_ :decl(var)
    ║   ║ └◙ WVal NQPMu
    ║   ╟─bind  ««"$it := nqp::iterator(@args)"
    ║   ║ ├○ lexical $it
    ║   ║ └─iterator  ««"nqp::iterator(@args)"
    ║   ║   └○ lexical @args
    ║   ╟─bind  ««"$s  := ''"
    ║   ║ ├○ lexical $s
    ║   ║ └◙ SVal ""
    ║   ╟○ lexical $_
    ║   ╟─while  ««"$it {\n        $_ := nqp::shift($it);  # nqpc would"...
    ║   ║ ├○ lexical $it
    ║   ║ ├─:Stmts  ««"{\n        $_ := nqp::shift($it);  # nqpc would con"...
    ║   ║ │ ├─bind  ««":="
    ║   ║ │ │ ├○ lexical $_
    ║   ║ │ │ └─shift  ««"nqp::shift($it)"
    ║   ║ │ │   └○ lexical $it
    ║   ║ │ └─bind  ««":="
    ║   ║ │   ├○ lexical $s
    ║   ║ │   └─concat  ««"~"
    ║   ║ │     ├○ lexical $s
    ║   ║ │     └─if  ««"?? $_\n            !!"
    ║   ║ │       ├─isstr  ««"nqp::isstr($_)"
    ║   ║ │       │ └○ lexical $_
    ║   ║ │       ├○ lexical $_
    ║   ║ │       └─call .strOut  ««"$_"
    ║   ║ │         └○ lexical $_
    ║   ║ └◙ IVal 1 :named("nohandler")
    ║   ╙─say  ««"nqp::say($s)"
    ║     └○ lexical $s
    ╟─bind
    ║ ├○ lexical .MAIN :decl(var)
    ║ └─:Block  ««"{\n    my $n := 0;\n    my $b := { $n := $n + 1; };"...
    ║   ╟○ lexical @ARGS :decl(param) :slurpy(1)
    ║   ╟○ lexical $n :decl(var)
    ║   ╟○ lexical $b :decl(var)
    ║   ╟○ lexical $d :decl(var)
    ║   ╟○ lexical $lambda2 :decl(var)
    ║   ╟○ lexical $lambda1 :decl(var)
    ║   ╟─bind  ««"$n := 0"
    ║   ║ ├○ lexical $n
    ║   ║ └◙ IVal 0
    ║   ╟─bind  ««"$b := { $n := $n + 1; }"
    ║   ║ ├○ lexical $b
    ║   ║ └─:Block  ««"{ $n := $n + 1; }"
    ║   ║   ╙─bind  ««":="
    ║   ║     ├○ lexical $n
    ║   ║     └─add_n  ««"+"
    ║   ║       ├○ lexical $n
    ║   ║       └◙ IVal 1
    ║   ╟─bind  ««"$d := delayMemo($b)"
    ║   ║ ├○ lexical $d
    ║   ║ └─call .delayMemo  ««"$b"
    ║   ║   └○ lexical $b
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless $n == 0"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├○ lexical $n
    ║   ║ │ └◙ IVal 0
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless force($d) == 1"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├─call .force  ««"$d"
    ║   ║ │ │ └○ lexical $d
    ║   ║ │ └◙ IVal 1
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless force($d) == 1"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├─call .force  ««"$d"
    ║   ║ │ │ └○ lexical $d
    ║   ║ │ └◙ IVal 1
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless force($b) == 2"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├─call .force  ««"$b"
    ║   ║ │ │ └○ lexical $b
    ║   ║ │ └◙ IVal 2
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless force($b) == 3"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├─call .force  ««"$b"
    ║   ║ │ │ └○ lexical $b
    ║   ║ │ └◙ IVal 3
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless force($d) == 1"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├─call .force  ««"$d"
    ║   ║ │ │ └○ lexical $d
    ║   ║ │ └◙ IVal 1
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─bind  ««"$lambda2 := [\n        'λ1',                       "...
    ║   ║ ├○ lexical $lambda2
    ║   ║ └─list  ««","
    ║   ║   ├◙ SVal "λ1"
    ║   ║   ├─:Block  ««"{ 'λ1(...) called' }"
    ║   ║   │ ╟○ lexical @as :decl(param) :slurpy(1)
    ║   ║   │ ╙◙ SVal "λ1(...) called"
    ║   ║   └◙ IVal 23
    ║   ╟─bind  ««"$lambda1 := [\n        'λ0',                       "...
    ║   ║ ├○ lexical $lambda1
    ║   ║ └─list  ««","
    ║   ║   ├◙ SVal "λ0"
    ║   ║   ├─:Block  ««"{ 'λ0(...) called' }"
    ║   ║   │ ╟○ lexical @as :decl(param) :slurpy(1)
    ║   ║   │ ╙◙ SVal "λ0(...) called"
    ║   ║   ├◙ SVal "foo"
    ║   ║   ├◙ IVal 42
    ║   ║   ├◙ NVal 3.14159265
    ║   ║   └○ lexical $lambda2
    ║   ╟─push  ««"$lambda1"
    ║   ║ ├○ lexical $lambda1
    ║   ║ └○ lexical $lambda1
    ║   ╟─push  ««"$lambda1"
    ║   ║ ├○ lexical $lambda1
    ║   ║ └○ lexical $lambda1
    ║   ╙─call .say  ««"strOut($lambda1)"
    ║     └─call .strOut  ««"$lambda1"
    ║       └○ lexical $lambda1
    ╟─bind
    ║ ├○ local ctxsave :decl(var)
    ║ └○ contextual $*CTXSAVE
    ╟─unless
    ║ ├─isnull
    ║ │ └○ local ctxsave
    ║ └─if
    ║   ├─can
    ║   │ ├○ local ctxsave
    ║   │ └◙ SVal "ctxsave"
    ║   └─callmethod ctxsave
    ║     └○ local ctxsave
    ╟─bind  ««"$λsrc := '(λf.λstart.λxs.xs start (λhd.λtl.self f ("...
    ║ ├○ lexical .λsrc
    ║ └◙ SVal "(λf.λstart.λxs.xs start (λhd.λtl.self f (f start hd) tl)) (λ_.x)"
    ╟─bind  ««"%info := nqp::hash(\n    'λ', [\n        'binder0 1"...
    ║ ├○ lexical %info
    ║ └─hash  ««"nqp::hash(\n    'λ', [\n        'binder0 1 55 foo b"...
    ║   ├◙ SVal "λ"
    ║   └─list  ««","
    ║     ├◙ SVal "binder0 1 55 foo bar baz qumbl self self"
    ║     └◙ SVal "binder1 59 4 foo"
    ╟○ lexical .LAMFIELD_ID
    ╟○ lexical .LAMFIELD_CODE
    ╟○ lexical .LAMFIELD_FREEVARS
    ╟○ lexical .lam2id
    ╟○ lexical .lam2code
    ╟○ lexical .lam2fvs
    ╟○ lexical .int2str
    ╟○ lexical .num2str
    ╟○ lexical .strLit
    ╟○ lexical .force
    ╟○ lexical .delayMemo
    ╟○ lexical .sublist
    ╟○ lexical .lam2info
    ╟○ lexical .typecase
    ╟○ lexical .strOut
    ╟○ lexical .apply1
    ╟○ lexical .say
    ╟○ lexical .MAIN
    ╙─if
      ├○ lexical @ARGS
      └─call .MAIN
        └○ lexical @ARGS :flat(1)