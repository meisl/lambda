──CompUnit+{StrByDump}
  └─:Block
    ╟○ lexical @ARGS :decl(param) :slurpy(1)
    ╟○ lexical GLOBALish :decl(static) :default(...)
    ╟○ lexical $?PACKAGE :decl(static) :default(...)
    ╟○ lexical EXPORT :decl(static) :default(...)
    ╟○ lexical .λsrc :decl(var)
    ╟○ lexical %info :decl(var)
    ╟─bind
    ║ ├○ lexical .force :decl(var)
    ║ └─:Block  ««"{\n    nqp::isinvokable($v) ?? $v() !! $v;\n}"
    ║   ╟○ lexical $v :decl(param)  ««"$v"
    ║   ╙─if  ««"?? $v() !!"
    ║     ├─isinvokable  ««"nqp::isinvokable($v)"
    ║     │ └○ lexical $v
    ║     ├─call  ««""
    ║     │ └○ lexical $v
    ║     └○ lexical $v
    ╟─bind
    ║ ├○ lexical .delayMemo :decl(var)
    ║ └─:Block  ««"{\n    my int $wasRun := 0;\n    my $result := nqp:"...
    ║   ╟○ lexical $block :decl(param)  ««"$block"
    ║   ╟○ lexical $wasRun :decl(var)
    ║   ╟○ lexical $result :decl(var)
    ║   ╟○ lexical $out :decl(var)
    ║   ╟─bind  ««"int $wasRun := 0"
    ║   ║ ├○ lexical $wasRun
    ║   ║ └◙ IVal 0
    ║   ╟─bind  ««"$result := nqp::null"
    ║   ║ ├○ lexical $result
    ║   ║ └─null  ««"nqp::null"
    ║   ╟─bind  ««"$out := {\n        if $wasRun {\n            $resul"...
    ║   ║ ├○ lexical $out
    ║   ║ └─:Block  ««"{\n        if $wasRun {\n            $result;\n    "...
    ║   ║   ╙─if  ««"$wasRun {\n            $result;\n        }"
    ║   ║     ├○ lexical $wasRun
    ║   ║     ├○ lexical $result
    ║   ║     └─:Stmts  ««"{\n            $wasRun := 1;\n            $result :"...
    ║   ║       ├─bind  ««":="
    ║   ║       │ ├○ lexical $wasRun
    ║   ║       │ └◙ IVal 1
    ║   ║       └─bind  ««":="
    ║   ║         ├○ lexical $result
    ║   ║         └─call  ««""
    ║   ║           └○ lexical $block
    ║   ╙○ lexical $out
    ╟─bind
    ║ ├○ lexical .sublist :decl(var)
    ║ └─:Block  ««"{\n    my int $n     := nqp::elems(@list);\n    my "...
    ║   ╟○ lexical @list :decl(param)  ««"@list"
    ║   ╟○ lexical $from :decl(param)  ««"$from"
    ║   ╟○ lexical $n :decl(var)
    ║   ╟○ lexical $count :decl(var)
    ║   ╟○ lexical $to :decl(var)
    ║   ╟○ lexical @out :decl(var)
    ║   ╟─bind  ««"int $n     := nqp::elems(@list)"
    ║   ║ ├○ lexical $n
    ║   ║ └─elems  ««"nqp::elems(@list)"
    ║   ║   └○ lexical @list
    ║   ╟─bind  ««"int $count := $n"
    ║   ║ ├○ lexical $count
    ║   ║ └○ lexical $n
    ║   ╟─bind  ««"int $to    := $from + $count"
    ║   ║ ├○ lexical $to
    ║   ║ └─add_n  ««"+"
    ║   ║   ├○ lexical $from
    ║   ║   └○ lexical $count
    ║   ╟─bind  ««"@out   := []"
    ║   ║ ├○ lexical @out
    ║   ║ └─list
    ║   ╟─if  ««"$to > $n {\n        $to := $n\n    }"
    ║   ║ ├─isgt_n  ««">"
    ║   ║ │ ├○ lexical $to
    ║   ║ │ └○ lexical $n
    ║   ║ └─bind  ««":="
    ║   ║   ├○ lexical $to
    ║   ║   └○ lexical $n
    ║   ╟─while  ««"$from < $to {\n        @out.push(@list[$from]);\n  "...
    ║   ║ ├─islt_n  ««"<"
    ║   ║ │ ├○ lexical $from
    ║   ║ │ └○ lexical $to
    ║   ║ ├─:Stmts  ««"{\n        @out.push(@list[$from]);\n        $from+"...
    ║   ║ │ ├─callmethod push  ««"@list[$from]"
    ║   ║ │ │ ├○ lexical @out
    ║   ║ │ │ └─VarWithFallback positional 
    ║   ║ │ │   ├○ lexical @list :decl()
    ║   ║ │ │   └○ lexical $from :decl()
    ║   ║ │ └─postinc  ««"++"
    ║   ║ │   └○ lexical $from
    ║   ║ └◙ IVal 1 :named("nohandler")
    ║   ╙○ lexical @out
    ╟─bind
    ║ ├○ lexical .lam2id :decl(var)
    ║ └─:Block  ««"{ nqp::atpos($lambda, 0) }"
    ║   ╟○ lexical $lambda :decl(param)  ««"$lambda"
    ║   ╙─atpos  ««"nqp::atpos($lambda, 0)"
    ║     ├○ lexical $lambda
    ║     └◙ IVal 0
    ╟─bind
    ║ ├○ lexical .lam2code :decl(var)
    ║ └─:Block  ««"{ nqp::atpos($lambda, 1) }"
    ║   ╟○ lexical $lambda :decl(param)  ««"$lambda"
    ║   ╙─atpos  ««"nqp::atpos($lambda, 1)"
    ║     ├○ lexical $lambda
    ║     └◙ IVal 1
    ╟─bind
    ║ ├○ lexical .lam2fvs :decl(var)
    ║ └─:Block  ««"{    sublist($lambda, 2) }"
    ║   ╟○ lexical $lambda :decl(param)  ««"$lambda"
    ║   ╙─call .sublist  ««"$lambda, 2"
    ║     ├○ lexical $lambda
    ║     └◙ IVal 2
    ╟─bind
    ║ ├○ lexical .lam2info :decl(var)
    ║ └─:Block  ««"{\n    my $id      := lam2id($lambda);\n    my $idx"...
    ║   ╟○ lexical $lambda :decl(param)  ««"$lambda"
    ║   ╟○ lexical $id :decl(var)
    ║   ╟○ lexical $idx :decl(var)
    ║   ╟○ lexical %rawInfo :decl(var)
    ║   ╟○ lexical %out :decl(var)
    ║   ╟○ lexical @fvs :decl(var)
    ║   ╟○ lexical %fvs :decl(var)
    ║   ╟○ lexical @fvns :decl(var)
    ║   ╟○ lexical $i :decl(var)
    ║   ╟─bind  ««"$id      := lam2id($lambda)"
    ║   ║ ├○ lexical $id
    ║   ║ └─call .lam2id  ««"$lambda"
    ║   ║   └○ lexical $lambda
    ║   ╟─bind  ««"$idx     := nqp::atpos(nqp::radix(10, $id, 1, 0), 0)"
    ║   ║ ├○ lexical $idx
    ║   ║ └─atpos  ««"nqp::atpos(nqp::radix(10, $id, 1, 0), 0)"
    ║   ║   ├─radix  ««"nqp::radix(10, $id, 1, 0)"
    ║   ║   │ ├◙ IVal 10
    ║   ║   │ ├○ lexical $id
    ║   ║   │ ├◙ IVal 1
    ║   ║   │ └◙ IVal 0
    ║   ║   └◙ IVal 0
    ║   ╟─bind  ««"%rawInfo := %info<λ>[$idx]"
    ║   ║ ├○ lexical %rawInfo
    ║   ║ └─VarWithFallback positional 
    ║   ║   ├─VarWithFallback associative  :decl()
    ║   ║   │ ├○ lexical %info :decl()
    ║   ║   │ └◙ SVal "λ"
    ║   ║   └○ lexical $idx :decl()
    ║   ╟─bind  ««"%out     := nqp::hash(\n        'id',       $id,\n "...
    ║   ║ ├○ lexical %out
    ║   ║ └─hash  ««"nqp::hash(\n        'id',       $id,\n        'idx'"...
    ║   ║   ├◙ SVal "id"
    ║   ║   ├○ lexical $id
    ║   ║   ├◙ SVal "idx"
    ║   ║   ├○ lexical $idx
    ║   ║   ├◙ SVal "from"
    ║   ║   ├─VarWithFallback associative 
    ║   ║   │ ├○ lexical %rawInfo :decl()
    ║   ║   │ └◙ SVal "from"
    ║   ║   ├◙ SVal "length"
    ║   ║   ├─VarWithFallback associative 
    ║   ║   │ ├○ lexical %rawInfo :decl()
    ║   ║   │ └◙ SVal "length"
    ║   ║   ├◙ SVal "src"
    ║   ║   └─substr  ««"nqp::substr($λsrc, %rawInfo<from>, %rawInfo<length>)"
    ║   ║     ├○ lexical .λsrc
    ║   ║     ├─VarWithFallback associative 
    ║   ║     │ ├○ lexical %rawInfo :decl()
    ║   ║     │ └◙ SVal "from"
    ║   ║     └─VarWithFallback associative 
    ║   ║       ├○ lexical %rawInfo :decl()
    ║   ║       └◙ SVal "length"
    ║   ╟─bind  ««"@fvs     := lam2fvs($lambda)"
    ║   ║ ├○ lexical @fvs
    ║   ║ └─call .lam2fvs  ««"$lambda"
    ║   ║   └○ lexical $lambda
    ║   ╟─bind  ««"%fvs     := nqp::hash()"
    ║   ║ ├○ lexical %fvs
    ║   ║ └─hash  ««"nqp::hash()"
    ║   ╟─bind  ««"@fvns := %rawInfo<freeVarNames>"
    ║   ║ ├○ lexical @fvns
    ║   ║ └─VarWithFallback associative 
    ║   ║   ├○ lexical %rawInfo :decl()
    ║   ║   └◙ SVal "freeVarNames"
    ║   ╟─bind  ««"$i := 0"
    ║   ║ ├○ lexical $i
    ║   ║ └◙ IVal 0
    ║   ╟─for  ««"@fvns {\n        nqp::bindkey(%fvs, $_, @fvs[$i]);\"...
    ║   ║ ├○ lexical @fvns
    ║   ║ ├─:Block  ««"{\n        nqp::bindkey(%fvs, $_, @fvs[$i]);\n     "...
    ║   ║ │ ╟○ lexical $_ :decl(param)
    ║   ║ │ ╟─bindkey  ««"nqp::bindkey(%fvs, $_, @fvs[$i])"
    ║   ║ │ ║ ├○ lexical %fvs
    ║   ║ │ ║ ├○ lexical $_
    ║   ║ │ ║ └─VarWithFallback positional 
    ║   ║ │ ║   ├○ lexical @fvs :decl()
    ║   ║ │ ║   └○ lexical $i :decl()
    ║   ║ │ ╙─postinc  ««"++"
    ║   ║ │   └○ lexical $i
    ║   ║ └◙ IVal 1 :named("nohandler")
    ║   ╟─bindkey  ««"nqp::bindkey(%out, 'freeVars', %fvs)"
    ║   ║ ├○ lexical %out
    ║   ║ ├◙ SVal "freeVars"
    ║   ║ └○ lexical %fvs
    ║   ╙○ lexical %out
    ╟─bind
    ║ ├○ lexical .typecase :decl(var)
    ║ └─:Block  ««"{\n    say('>>>typecase(', nqp::reprname($subject),"...
    ║   ╟○ lexical $subject :decl(param)  ««"$subject"
    ║   ╟○ lexical %callbacks :decl(param) :named(1) :slurpy(1)  ««"%callbacks"
    ║   ╟○ lexical $otherwise :decl(var)
    ║   ╟─bind  ««"$cbKey"
    ║   ║ ├○ lexical $cbKey :decl(var)
    ║   ║ └◙ WVal NQPMu
    ║   ╟○ lexical $cb :decl(var)
    ║   ╟─call .say  ««"'>>>typecase(', nqp::reprname($subject), '...) '"
    ║   ║ ├◙ SVal ">>>typecase("
    ║   ║ ├─reprname  ««"nqp::reprname($subject)"
    ║   ║ │ └○ lexical $subject
    ║   ║ └◙ SVal "...) "
    ║   ╟─bind  ««"$otherwise := nqp::defor(\n        %callbacks<other"...
    ║   ║ ├○ lexical $otherwise
    ║   ║ └─defor  ««"nqp::defor(\n        %callbacks<otherwise>,\n      "...
    ║   ║   ├─VarWithFallback associative 
    ║   ║   │ ├○ lexical %callbacks :decl()
    ║   ║   │ └◙ SVal "otherwise"
    ║   ║   └─:Block  ««"{ # compiler should see that this needs not be a cl"...
    ║   ║     ╟○ lexical $x :decl(param)  ««"$x"
    ║   ║     ╙─die  ««"nqp::die('typecase: fell through due to missing \"o"...
    ║   ║       └─concat  ««"~"
    ║   ║         ├◙ SVal "typecase: fell through due to missing \"otherwise\"-callback: "
    ║   ║         └─reprname  ««"nqp::reprname($subject)"
    ║   ║           └○ lexical $subject
    ║   ╟─if  ««"nqp::islist($subject) {\n        my $id := nqp::atp"...
    ║   ║ ├─islist  ««"nqp::islist($subject)"
    ║   ║ │ └○ lexical $subject
    ║   ║ ├─:Block  ««"{\n        my $id := nqp::atpos($subject, 0);\n    "...
    ║   ║ │ ╟○ lexical $id :decl(var)
    ║   ║ │ ╟○ lexical $tag :decl(var)
    ║   ║ │ ╟─bind  ««"$id := nqp::atpos($subject, 0)"
    ║   ║ │ ║ ├○ lexical $id
    ║   ║ │ ║ └─atpos  ««"nqp::atpos($subject, 0)"
    ║   ║ │ ║   ├○ lexical $subject
    ║   ║ │ ║   └◙ IVal 0
    ║   ║ │ ╟─bind  ««"$tag := nqp::substr($id, 0, 1)"
    ║   ║ │ ║ ├○ lexical $tag
    ║   ║ │ ║ └─substr  ««"nqp::substr($id, 0, 1)"
    ║   ║ │ ║   ├○ lexical $id
    ║   ║ │ ║   ├◙ IVal 0
    ║   ║ │ ║   └◙ IVal 1
    ║   ║ │ ╙─if  ««"$tag eq 'λ' {\n            $cbKey := $tag;\n        }"
    ║   ║ │   ├─iseq_s  ««"eq"
    ║   ║ │   │ ├○ lexical $tag
    ║   ║ │   │ └◙ SVal "λ"
    ║   ║ │   ├─bind  ««":="
    ║   ║ │   │ ├○ lexical $cbKey
    ║   ║ │   │ └○ lexical $tag
    ║   ║ │   └─if  ««"nqp::elems($subject) == 0 {\n                nqp::d"...
    ║   ║ │     ├─iseq_n  ««"=="
    ║   ║ │     │ ├─elems  ««"nqp::elems($subject)"
    ║   ║ │     │ │ └○ lexical $subject
    ║   ║ │     │ └◙ IVal 0
    ║   ║ │     ├─die  ««"nqp::die('typecase: unsupported low-level list type"...
    ║   ║ │     │ └◙ SVal "typecase: unsupported low-level list type - empty"
    ║   ║ │     └─die  ««"nqp::die('typecase: unsupported low-level list type"...
    ║   ║ │       └─concat  ««"~"
    ║   ║ │         ├◙ SVal "typecase: unsupported low-level list type - invalid tag "
    ║   ║ │         └─reprname  ««"nqp::reprname($tag)"
    ║   ║ │           └○ lexical $tag
    ║   ║ └─if  ««"nqp::isstr($subject) { $cbKey := 'str';\n        }"
    ║   ║   ├─isstr  ««"nqp::isstr($subject)"
    ║   ║   │ └○ lexical $subject
    ║   ║   ├─bind  ««":="
    ║   ║   │ ├○ lexical $cbKey
    ║   ║   │ └◙ SVal "str"
    ║   ║   └─if  ««"nqp::isint($subject) { $cbKey := 'int';\n        }"
    ║   ║     ├─isint  ««"nqp::isint($subject)"
    ║   ║     │ └○ lexical $subject
    ║   ║     ├─bind  ««":="
    ║   ║     │ ├○ lexical $cbKey
    ║   ║     │ └◙ SVal "int"
    ║   ║     └─if  ««"nqp::isnum($subject) { $cbKey := 'num';\n        }"
    ║   ║       ├─isnum  ««"nqp::isnum($subject)"
    ║   ║       │ └○ lexical $subject
    ║   ║       ├─bind  ««":="
    ║   ║       │ ├○ lexical $cbKey
    ║   ║       │ └◙ SVal "num"
    ║   ║       └─die  ««"nqp::die('typecase: unsupported low-level type ' ~ "...
    ║   ║         └─concat  ««"~"
    ║   ║           ├◙ SVal "typecase: unsupported low-level type "
    ║   ║           └─reprname  ««"nqp::reprname($subject)"
    ║   ║             └○ lexical $subject
    ║   ╟─bind  ««"$cb := nqp::defor(%callbacks{$cbKey}, $otherwise)"
    ║   ║ ├○ lexical $cb
    ║   ║ └─defor  ««"nqp::defor(%callbacks{$cbKey}, $otherwise)"
    ║   ║   ├─VarWithFallback associative 
    ║   ║   │ ├○ lexical %callbacks :decl()
    ║   ║   │ └○ lexical $cbKey :decl()
    ║   ║   └○ lexical $otherwise
    ║   ╙─call  ««"$subject"
    ║     ├○ lexical $cb
    ║     └○ lexical $subject
    ╟─bind
    ║ ├○ lexical .int2str :decl(var)
    ║ └─:Block  ««"{ ~$i }"
    ║   ╟○ lexical $i :decl(param)  ««"$i"
    ║   ╙─stringify  ««"~"
    ║     └○ lexical $i
    ╟─bind
    ║ ├○ lexical .num2str :decl(var)
    ║ └─:Block  ««"{ ~$n }"
    ║   ╟○ lexical $n :decl(param)  ««"$n"
    ║   ╙─stringify  ««"~"
    ║     └○ lexical $n
    ╟─bind
    ║ ├○ lexical .strLit :decl(var)
    ║ └─:Block  ««"{ '\"' ~ nqp::escape($s) ~ '\"' }"
    ║   ╟○ lexical $s :decl(param)  ««"$s"
    ║   ╙─concat  ««"~"
    ║     ├─concat  ««"~"
    ║     │ ├◙ SVal "\""
    ║     │ └─escape  ««"nqp::escape($s)"
    ║     │   └○ lexical $s
    ║     └◙ SVal "\""
    ╟─bind
    ║ ├○ lexical .strOut :decl(var)
    ║ └─:Block  ««"{\n    typecase(force($v),\n        :λ(-> $lambda {"...
    ║   ╟○ lexical $v :decl(param)  ««"$v"
    ║   ╟○ lexical $indent :decl(param) :default(...)  ««"$indent"
    ║   ╟○ lexical %done :decl(param) :default(...)  ««"%done"
    ║   ╙─call .typecase  ««"force($v),\n        :λ(-> $lambda { # compiler shou"...
    ║     ├─call .force  ««"$v"
    ║     │ └○ lexical $v
    ║     ├─:Block :named("λ")  ««"{ # compiler should see that this needs not be a cl"...
    ║     │ ╟○ lexical $lambda :decl(param)  ««"$lambda"
    ║     │ ╟○ lexical %info :decl(var)
    ║     │ ╟○ lexical $src :decl(var)
    ║     │ ╟○ lexical %fvs :decl(var)
    ║     │ ╟─bind  ««"%info := lam2info($lambda)"
    ║     │ ║ ├○ lexical %info
    ║     │ ║ └─call .lam2info  ««"$lambda"
    ║     │ ║   └○ lexical $lambda
    ║     │ ╟─bind  ««"$src := %info<src>"
    ║     │ ║ ├○ lexical $src
    ║     │ ║ └─VarWithFallback associative 
    ║     │ ║   ├○ lexical %info :decl()
    ║     │ ║   └◙ SVal "src"
    ║     │ ╟─bind  ««"%fvs := %info<freeVars>"
    ║     │ ║ ├○ lexical %fvs
    ║     │ ║ └─VarWithFallback associative 
    ║     │ ║   ├○ lexical %info :decl()
    ║     │ ║   └◙ SVal "freeVars"
    ║     │ ╟─for  ««"%fvs {\n                my $fvName  := nqp::iterkey"...
    ║     │ ║ ├○ lexical %fvs
    ║     │ ║ ├─:Block  ««"{\n                my $fvName  := nqp::iterkey_s($_"...
    ║     │ ║ │ ╟○ lexical $fvName :decl(var)
    ║     │ ║ │ ╟○ lexical $fv :decl(var)
    ║     │ ║ │ ╟○ lexical $pre :decl(var)
    ║     │ ║ │ ╟○ lexical $flatVal :decl(var)
    ║     │ ║ │ ╟○ lexical $doneKey :decl(var)
    ║     │ ║ │ ╟○ lexical $_ :decl(param)
    ║     │ ║ │ ╟─bind  ««"$fvName  := nqp::iterkey_s($_)"
    ║     │ ║ │ ║ ├○ lexical $fvName
    ║     │ ║ │ ║ └─iterkey_s  ««"nqp::iterkey_s($_)"
    ║     │ ║ │ ║   └○ lexical $_
    ║     │ ║ │ ╟─bind  ««"$fv      := nqp::iterval($_)"
    ║     │ ║ │ ║ ├○ lexical $fv
    ║     │ ║ │ ║ └─iterval  ««"nqp::iterval($_)"
    ║     │ ║ │ ║   └○ lexical $_
    ║     │ ║ │ ╟─bind  ««"$pre     := \"# where $fvName = \""
    ║     │ ║ │ ║ ├○ lexical $pre
    ║     │ ║ │ ║ └─concat
    ║     │ ║ │ ║   ├─concat
    ║     │ ║ │ ║   │ ├◙ SVal "# where "
    ║     │ ║ │ ║   │ └○ lexical $fvName
    ║     │ ║ │ ║   └◙ SVal " = "
    ║     │ ║ │ ╟─bind  ««"$flatVal := typecase($fv,\n                    :λ(-"...
    ║     │ ║ │ ║ ├○ lexical $flatVal
    ║     │ ║ │ ║ └─call .typecase  ««"$fv,\n                    :λ(-> $x { nqp::null }), "...
    ║     │ ║ │ ║   ├○ lexical $fv
    ║     │ ║ │ ║   ├─:Block :named("λ")  ««"{ nqp::null }"
    ║     │ ║ │ ║   │ ╟○ lexical $x :decl(param)  ««"$x"
    ║     │ ║ │ ║   │ ╙─null  ««"nqp::null"
    ║     │ ║ │ ║   ├○ lexical .strLit :named("str")
    ║     │ ║ │ ║   ├○ lexical .int2str :named("int")
    ║     │ ║ │ ║   └○ lexical .num2str :named("num")
    ║     │ ║ │ ╟─bind  ««"$doneKey := nqp::isnull($flatVal)\n                "...
    ║     │ ║ │ ║ ├○ lexical $doneKey
    ║     │ ║ │ ║ └─if  ««"?? $pre ~ lam2id($fv)\n                    !!"
    ║     │ ║ │ ║   ├─isnull  ««"nqp::isnull($flatVal)"
    ║     │ ║ │ ║   │ └○ lexical $flatVal
    ║     │ ║ │ ║   ├─concat  ««"~"
    ║     │ ║ │ ║   │ ├○ lexical $pre
    ║     │ ║ │ ║   │ └─call .lam2id  ««"$fv"
    ║     │ ║ │ ║   │   └○ lexical $fv
    ║     │ ║ │ ║   └─concat  ««"~"
    ║     │ ║ │ ║     ├○ lexical $pre
    ║     │ ║ │ ║     └○ lexical $flatVal
    ║     │ ║ │ ╙─unless  ««"%done{$doneKey} {\n                    %done{$doneK"...
    ║     │ ║ │   ├─VarWithFallback associative 
    ║     │ ║ │   │ ├○ lexical %done :decl()
    ║     │ ║ │   │ └○ lexical $doneKey :decl()
    ║     │ ║ │   └─:Stmts  ««"{\n                    %done{$doneKey} := 1;\n     "...
    ║     │ ║ │     ├─bind  ««":="
    ║     │ ║ │     │ ├─VarWithFallback associative 
    ║     │ ║ │     │ │ ├○ lexical %done :decl()
    ║     │ ║ │     │ │ └○ lexical $doneKey :decl()
    ║     │ ║ │     │ └◙ IVal 1
    ║     │ ║ │     └─bind  ««":="
    ║     │ ║ │       ├○ lexical $src
    ║     │ ║ │       └─concat  ««"~"
    ║     │ ║ │         ├─concat  ««"~"
    ║     │ ║ │         │ ├─concat  ««"~"
    ║     │ ║ │         │ │ ├○ lexical $src
    ║     │ ║ │         │ │ └◙ SVal "\n"
    ║     │ ║ │         │ └○ lexical $indent
    ║     │ ║ │         └─if  ««"?? $pre ~ strOut($fv, $indent ~ '#' ~ nqp::x(' ', n"...
    ║     │ ║ │           ├─isnull  ««"nqp::isnull($flatVal)"
    ║     │ ║ │           │ └○ lexical $flatVal
    ║     │ ║ │           ├─concat  ««"~"
    ║     │ ║ │           │ ├○ lexical $pre
    ║     │ ║ │           │ └─call .strOut  ««"$fv, $indent ~ '#' ~ nqp::x(' ', nqp::chars($pre) -"...
    ║     │ ║ │           │   ├○ lexical $fv
    ║     │ ║ │           │   ├─concat  ««"~"
    ║     │ ║ │           │   │ ├─concat  ««"~"
    ║     │ ║ │           │   │ │ ├○ lexical $indent
    ║     │ ║ │           │   │ │ └◙ SVal "#"
    ║     │ ║ │           │   │ └─x  ««"nqp::x(' ', nqp::chars($pre) - 1)"
    ║     │ ║ │           │   │   ├◙ SVal " "
    ║     │ ║ │           │   │   └─sub_n  ««"-"
    ║     │ ║ │           │   │     ├─chars  ««"nqp::chars($pre)"
    ║     │ ║ │           │   │     │ └○ lexical $pre
    ║     │ ║ │           │   │     └◙ IVal 1
    ║     │ ║ │           │   └○ lexical %done
    ║     │ ║ │           └○ lexical $doneKey
    ║     │ ║ └◙ IVal 1 :named("nohandler")
    ║     │ ╙○ lexical $src
    ║     ├○ lexical .strLit :named("str")
    ║     ├○ lexical .int2str :named("int")
    ║     └○ lexical .num2str :named("num")
    ╟─bind
    ║ ├○ lexical .apply1 :decl(var)
    ║ └─:Block  ««"{\n    my $result := typecase(force($f),\n        :"...
    ║   ╟○ lexical $f :decl(param)  ««"$f"
    ║   ╟○ lexical $a1 :decl(param)  ««"$a1"
    ║   ╟○ lexical $result :decl(var)
    ║   ╟─bind  ««"$result := typecase(force($f),\n        :λ(&lam2cod"...
    ║   ║ ├○ lexical $result
    ║   ║ └─call  ««"$a1"
    ║   ║   ├─call .typecase  ««"force($f),\n        :λ(&lam2code),\n        :otherw"...
    ║   ║   │ ├─call .force  ««"$f"
    ║   ║   │ │ └○ lexical $f
    ║   ║   │ ├○ lexical .lam2code :named("λ")
    ║   ║   │ └─:Block :named("otherwise")  ««"{\n            nqp::die('ERROR: cannot apply ' ~ st"...
    ║   ║   │   ╟○ lexical $x :decl(param)  ««"$x"
    ║   ║   │   ╙─die  ««"nqp::die('ERROR: cannot apply ' ~ strOut($x) ~ ' to"...
    ║   ║   │     └─concat  ««"~"
    ║   ║   │       ├─concat  ««"~"
    ║   ║   │       │ ├─concat  ««"~"
    ║   ║   │       │ │ ├◙ SVal "ERROR: cannot apply "
    ║   ║   │       │ │ └─call .strOut  ««"$x"
    ║   ║   │       │ │   └○ lexical $x
    ║   ║   │       │ └◙ SVal " to "
    ║   ║   │       └─call .strOut  ««"$a1"
    ║   ║   │         └○ lexical $a1
    ║   ║   └○ lexical $a1
    ║   ╙─call .force  ««"$result"
    ║     └○ lexical $result
    ╟─bind
    ║ ├○ lexical .say :decl(var)
    ║ └─:Block  ««"{\n    my $s := '';\n    for @args {\n        $s :="...
    ║   ╟○ lexical @args :decl(param) :slurpy(1)  ««"@args"
    ║   ╟○ lexical $s :decl(var)
    ║   ╟─bind  ««"$s := ''"
    ║   ║ ├○ lexical $s
    ║   ║ └◙ SVal ""
    ║   ╟─for  ««"@args {\n        $s := $s ~ (nqp::isstr($_)\n      "...
    ║   ║ ├○ lexical @args
    ║   ║ ├─:Block  ««"{\n        $s := $s ~ (nqp::isstr($_)\n            "...
    ║   ║ │ ╟○ lexical $_ :decl(param)
    ║   ║ │ ╙─bind  ««":="
    ║   ║ │   ├○ lexical $s
    ║   ║ │   └─concat  ««"~"
    ║   ║ │     ├○ lexical $s
    ║   ║ │     └─if  ««"?? $_\n            !!"
    ║   ║ │       ├─isstr  ««"nqp::isstr($_)"
    ║   ║ │       │ └○ lexical $_
    ║   ║ │       ├○ lexical $_
    ║   ║ │       └─call .strOut  ««"$_"
    ║   ║ │         └○ lexical $_
    ║   ║ └◙ IVal 1 :named("nohandler")
    ║   ╙─say  ««"nqp::say($s)"
    ║     └○ lexical $s
    ╟─bind
    ║ ├○ lexical .MAIN :decl(var)
    ║ └─:Block  ««"{\n    my $n := 0;\n    my $b := { $n := $n + 1; };"...
    ║   ╟○ lexical @ARGS :decl(param) :slurpy(1)  ««"@ARGS"
    ║   ╟○ lexical $n :decl(var)
    ║   ╟○ lexical $b :decl(var)
    ║   ╟○ lexical $d :decl(var)
    ║   ╟○ lexical $lambda2 :decl(var)
    ║   ╟○ lexical $lambda1 :decl(var)
    ║   ╟─bind  ««"$n := 0"
    ║   ║ ├○ lexical $n
    ║   ║ └◙ IVal 0
    ║   ╟─bind  ««"$b := { $n := $n + 1; }"
    ║   ║ ├○ lexical $b
    ║   ║ └─:Block  ««"{ $n := $n + 1; }"
    ║   ║   ╙─bind  ««":="
    ║   ║     ├○ lexical $n
    ║   ║     └─add_n  ««"+"
    ║   ║       ├○ lexical $n
    ║   ║       └◙ IVal 1
    ║   ╟─bind  ««"$d := delayMemo($b)"
    ║   ║ ├○ lexical $d
    ║   ║ └─call .delayMemo  ««"$b"
    ║   ║   └○ lexical $b
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless $n == 0"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├○ lexical $n
    ║   ║ │ └◙ IVal 0
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless force($d) == 1"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├─call .force  ««"$d"
    ║   ║ │ │ └○ lexical $d
    ║   ║ │ └◙ IVal 1
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless force($d) == 1"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├─call .force  ««"$d"
    ║   ║ │ │ └○ lexical $d
    ║   ║ │ └◙ IVal 1
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless force($b) == 2"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├─call .force  ««"$b"
    ║   ║ │ │ └○ lexical $b
    ║   ║ │ └◙ IVal 2
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless force($b) == 3"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├─call .force  ««"$b"
    ║   ║ │ │ └○ lexical $b
    ║   ║ │ └◙ IVal 3
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─unless  ««"nqp::die('not ok: .delayMemo') unless force($d) == 1"
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├─call .force  ««"$d"
    ║   ║ │ │ └○ lexical $d
    ║   ║ │ └◙ IVal 1
    ║   ║ └─die  ««"nqp::die('not ok: .delayMemo')"
    ║   ║   └◙ SVal "not ok: .delayMemo"
    ║   ╟─bind  ««"$lambda2 := [\n        'λ1',                       "...
    ║   ║ ├○ lexical $lambda2
    ║   ║ └─list  ««","
    ║   ║   ├◙ SVal "λ1"
    ║   ║   ├─:Block  ««"{ 'λ1(...) called' }"
    ║   ║   │ ╟○ lexical @as :decl(param) :slurpy(1)  ««"@as"
    ║   ║   │ ╙◙ SVal "λ1(...) called"
    ║   ║   └◙ IVal 23
    ║   ╟─bind  ««"$lambda1 := [\n        'λ0',                       "...
    ║   ║ ├○ lexical $lambda1
    ║   ║ └─list  ««","
    ║   ║   ├◙ SVal "λ0"
    ║   ║   ├─:Block  ««"{ 'λ0(...) called' }"
    ║   ║   │ ╟○ lexical @as :decl(param) :slurpy(1)  ««"@as"
    ║   ║   │ ╙◙ SVal "λ0(...) called"
    ║   ║   ├◙ SVal "foo"
    ║   ║   ├◙ IVal 42
    ║   ║   ├◙ NVal 3.14159265
    ║   ║   └○ lexical $lambda2
    ║   ╟─callmethod push  ««"$lambda1"
    ║   ║ ├○ lexical $lambda1
    ║   ║ └○ lexical $lambda1
    ║   ╟─callmethod push  ««"$lambda1"
    ║   ║ ├○ lexical $lambda1
    ║   ║ └○ lexical $lambda1
    ║   ╙─call .say  ««"strOut($lambda1)"
    ║     └─call .strOut  ««"$lambda1"
    ║       └○ lexical $lambda1
    ╟─bind
    ║ ├○ local ctxsave :decl(var)
    ║ └○ contextual $*CTXSAVE
    ╟─unless
    ║ ├─isnull
    ║ │ └○ local ctxsave
    ║ └─if
    ║   ├─can
    ║   │ ├○ local ctxsave
    ║   │ └◙ SVal "ctxsave"
    ║   └─callmethod ctxsave
    ║     └○ local ctxsave
    ╟─bind  ««"$λsrc := '(λf.λstart.λxs.xs start (λhd.λtl.self f ("...
    ║ ├○ lexical .λsrc
    ║ └◙ SVal "(λf.λstart.λxs.xs start (λhd.λtl.self f (f start hd) tl)) (λ_.x)"
    ╟─bind  ««"%info := nqp::hash(\n    'λ', [\n        nqp::hash("...
    ║ ├○ lexical %info
    ║ └─hash  ««"nqp::hash(\n    'λ', [\n        nqp::hash('from',  "...
    ║   ├◙ SVal "λ"
    ║   └─list  ««","
    ║     ├─hash  ««"nqp::hash('from',  1, 'length', 55, 'freeVarNames',"...
    ║     │ ├◙ SVal "from"
    ║     │ ├◙ IVal 1
    ║     │ ├◙ SVal "length"
    ║     │ ├◙ IVal 55
    ║     │ ├◙ SVal "freeVarNames"
    ║     │ └─list  ««","
    ║     │   ├◙ SVal "foo"
    ║     │   ├◙ SVal "bar"
    ║     │   ├◙ SVal "baz"
    ║     │   ├◙ SVal "qumbl"
    ║     │   ├◙ SVal "self"
    ║     │   └◙ SVal "self"
    ║     └─hash  ««"nqp::hash('from', 59, 'length',  4, 'freeVarNames',"...
    ║       ├◙ SVal "from"
    ║       ├◙ IVal 59
    ║       ├◙ SVal "length"
    ║       ├◙ IVal 4
    ║       ├◙ SVal "freeVarNames"
    ║       └─list
    ║         └◙ SVal "foo"
    ╙─if
      ├○ lexical @ARGS
      └─call .MAIN
        └○ lexical @ARGS :flat(1)