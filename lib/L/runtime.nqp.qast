──CompUnit+{StrByDump}
  └◄Block
    ╟─○ (lexical @ARGS :decl(param))
    ╟─○ (lexical GLOBALish :decl(static))
    ╟─○ (lexical $?PACKAGE :decl(static))
    ╟─○ (lexical EXPORT :decl(static))
    ╟─○ (lexical .λsrc :decl(var))
    ╟─○ (lexical %info :decl(var))
    ╟─(bind)
    ║ ├─○ (lexical .force :decl(var))
    ║ └◄Block {\n    nqp::isinvokable($v) ?? $v() !! $v;\n}
    ║   ╟─○ (lexical $v :decl(param)) $v
    ║   ╙─(if) ?? $v() !!
    ║     ├─(isinvokable) nqp::isinvokable($v)
    ║     │ └─○ (lexical $v :decl())
    ║     ├─(call) 
    ║     │ └─○ (lexical $v :decl())
    ║     └─○ (lexical $v :decl())
    ╟─(bind)
    ║ ├─○ (lexical .delayMemo :decl(var))
    ║ └◄Block {\n    my int $wasRun := 0;\n    my $result := nqp...
    ║   ╟─○ (lexical $block :decl(param)) $block
    ║   ╟─○ (lexical $wasRun :decl(var))
    ║   ╟─○ (lexical $result :decl(var))
    ║   ╙─(lexotic RETURN)
    ║     └◄Stmts \n    my int $wasRun := 0;\n    my $result := nqp:...
    ║       ├─(bind) int $wasRun := 0
    ║       │ ├─○ (lexical $wasRun :decl())
    ║       │ └─IVal
    ║       ├─(bind) $result := nqp::null
    ║       │ ├─○ (lexical $result :decl())
    ║       │ └─(null) nqp::null
    ║       └─(call RETURN)
    ║         └─(takeclosure)
    ║           └◄Block {\n        if $wasRun {\n            $result;\n   ...
    ║             ╙─(if) $wasRun {\n            $result;\n        }
    ║               ├─○ (lexical $wasRun :decl())
    ║               ├─○ (lexical $result :decl())
    ║               └◄Stmts {\n            $wasRun := 1;\n            $result ...
    ║                 ├─(bind) :=
    ║                 │ ├─○ (lexical $wasRun :decl())
    ║                 │ └─IVal(1)
    ║                 └─(bind) :=
    ║                   ├─○ (lexical $result :decl())
    ║                   └─(call) 
    ║                     └─○ (lexical $block :decl())
    ╟─(bind)
    ║ ├─○ (lexical .sublist :decl(var))
    ║ └◄Block {\n    my int $n     := nqp::elems(@list);\n    my...
    ║   ╟─○ (lexical @list :decl(param)) @list
    ║   ╟─○ (lexical $from :decl(param)) $from
    ║   ╟─○ (lexical $n :decl(var))
    ║   ╟─○ (lexical $count :decl(var))
    ║   ╟─○ (lexical $to :decl(var))
    ║   ╟─○ (lexical @out :decl(var))
    ║   ╟─(bind) int $n     := nqp::elems(@list)
    ║   ║ ├─○ (lexical $n :decl())
    ║   ║ └─(elems) nqp::elems(@list)
    ║   ║   └─○ (lexical @list :decl())
    ║   ╟─(bind) int $count := $n
    ║   ║ ├─○ (lexical $count :decl())
    ║   ║ └─○ (lexical $n :decl())
    ║   ╟─(bind) int $to    := $from + $count
    ║   ║ ├─○ (lexical $to :decl())
    ║   ║ └─(add_n) +
    ║   ║   ├─○ (lexical $from :decl())
    ║   ║   └─○ (lexical $count :decl())
    ║   ╟─(bind) @out   := []
    ║   ║ ├─○ (lexical @out :decl())
    ║   ║ └─(list)
    ║   ╟─(if) $to > $n {\n        $to := $n\n    }
    ║   ║ ├─(isgt_n) >
    ║   ║ │ ├─○ (lexical $to :decl())
    ║   ║ │ └─○ (lexical $n :decl())
    ║   ║ └─(bind) :=
    ║   ║   ├─○ (lexical $to :decl())
    ║   ║   └─○ (lexical $n :decl())
    ║   ╟─(while) $from < $to {\n        @out.push(@list[$from]);\n ...
    ║   ║ ├─(islt_n) <
    ║   ║ │ ├─○ (lexical $from :decl())
    ║   ║ │ └─○ (lexical $to :decl())
    ║   ║ ├◄Stmts {\n        @out.push(@list[$from]);\n        $from...
    ║   ║ │ ├─(callmethod push) @list[$from]
    ║   ║ │ │ ├─○ (lexical @out :decl())
    ║   ║ │ │ └─VarWithFallback(positional  :decl())
    ║   ║ │ │   ├─○ (lexical @list :decl())
    ║   ║ │ │   └─○ (lexical $from :decl())
    ║   ║ │ └─(postinc) ++
    ║   ║ │   └─○ (lexical $from :decl())
    ║   ║ └─IVal(1 :named(0))
    ║   ╙─○ (lexical @out :decl())
    ╟─(bind)
    ║ ├─○ (lexical .lam2id :decl(var))
    ║ └◄Block { nqp::atpos($lambda, 0) }
    ║   ╟─○ (lexical $lambda :decl(param)) $lambda
    ║   ╙─(atpos) nqp::atpos($lambda, 0)
    ║     ├─○ (lexical $lambda :decl())
    ║     └─IVal
    ╟─(bind)
    ║ ├─○ (lexical .lam2code :decl(var))
    ║ └◄Block { nqp::atpos($lambda, 1) }
    ║   ╟─○ (lexical $lambda :decl(param)) $lambda
    ║   ╙─(atpos) nqp::atpos($lambda, 1)
    ║     ├─○ (lexical $lambda :decl())
    ║     └─IVal(1)
    ╟─(bind)
    ║ ├─○ (lexical .lam2fvs :decl(var))
    ║ └◄Block {    sublist($lambda, 2) }
    ║   ╟─○ (lexical $lambda :decl(param)) $lambda
    ║   ╙─(call .sublist) $lambda, 2
    ║     ├─○ (lexical $lambda :decl())
    ║     └─IVal(2)
    ╟─(bind)
    ║ ├─○ (lexical .lam2info :decl(var))
    ║ └◄Block {\n    my $id      := lam2id($lambda);\n    my $id...
    ║   ╟─○ (lexical $lambda :decl(param)) $lambda
    ║   ╟─○ (lexical $id :decl(var))
    ║   ╟─○ (lexical $idx :decl(var))
    ║   ╟─○ (lexical %rawInfo :decl(var))
    ║   ╟─○ (lexical %out :decl(var))
    ║   ╟─○ (lexical @fvs :decl(var))
    ║   ╟─○ (lexical %fvs :decl(var))
    ║   ╟─○ (lexical @fvns :decl(var))
    ║   ╟─○ (lexical $i :decl(var))
    ║   ╟─(bind) $id      := lam2id($lambda)
    ║   ║ ├─○ (lexical $id :decl())
    ║   ║ └─(call .lam2id) $lambda
    ║   ║   └─○ (lexical $lambda :decl())
    ║   ╟─(bind) $idx     := nqp::atpos(nqp::radix(10, $id, 1, 0), 0)
    ║   ║ ├─○ (lexical $idx :decl())
    ║   ║ └─(atpos) nqp::atpos(nqp::radix(10, $id, 1, 0), 0)
    ║   ║   ├─(radix) nqp::radix(10, $id, 1, 0)
    ║   ║   │ ├─IVal(10)
    ║   ║   │ ├─○ (lexical $id :decl())
    ║   ║   │ ├─IVal(1)
    ║   ║   │ └─IVal
    ║   ║   └─IVal
    ║   ╟─(bind) %rawInfo := %info<λ>[$idx]
    ║   ║ ├─○ (lexical %rawInfo :decl())
    ║   ║ └─VarWithFallback(positional  :decl())
    ║   ║   ├─VarWithFallback(associative  :decl())
    ║   ║   │ ├─○ (lexical %info :decl())
    ║   ║   │ └─SVal(λ)
    ║   ║   └─○ (lexical $idx :decl())
    ║   ╟─(bind) %out     := nqp::hash(\n        'id',       $id,\n...
    ║   ║ ├─○ (lexical %out :decl())
    ║   ║ └─(hash) nqp::hash(\n        'id',       $id,\n        'idx...
    ║   ║   ├─SVal(id)
    ║   ║   ├─○ (lexical $id :decl())
    ║   ║   ├─SVal(idx)
    ║   ║   ├─○ (lexical $idx :decl())
    ║   ║   ├─SVal(from)
    ║   ║   ├─VarWithFallback(associative  :decl())
    ║   ║   │ ├─○ (lexical %rawInfo :decl())
    ║   ║   │ └─SVal(from)
    ║   ║   ├─SVal(length)
    ║   ║   ├─VarWithFallback(associative  :decl())
    ║   ║   │ ├─○ (lexical %rawInfo :decl())
    ║   ║   │ └─SVal(length)
    ║   ║   ├─SVal(src)
    ║   ║   └─(substr) nqp::substr($λsrc, %rawInfo<from>, %rawInfo<length>)
    ║   ║     ├─○ (lexical .λsrc :decl())
    ║   ║     ├─VarWithFallback(associative  :decl())
    ║   ║     │ ├─○ (lexical %rawInfo :decl())
    ║   ║     │ └─SVal(from)
    ║   ║     └─VarWithFallback(associative  :decl())
    ║   ║       ├─○ (lexical %rawInfo :decl())
    ║   ║       └─SVal(length)
    ║   ╟─(bind) @fvs     := lam2fvs($lambda)
    ║   ║ ├─○ (lexical @fvs :decl())
    ║   ║ └─(call .lam2fvs) $lambda
    ║   ║   └─○ (lexical $lambda :decl())
    ║   ╟─(bind) %fvs     := nqp::hash()
    ║   ║ ├─○ (lexical %fvs :decl())
    ║   ║ └─(hash) nqp::hash()
    ║   ╟─(bind) @fvns := %rawInfo<freeVarNames>
    ║   ║ ├─○ (lexical @fvns :decl())
    ║   ║ └─VarWithFallback(associative  :decl())
    ║   ║   ├─○ (lexical %rawInfo :decl())
    ║   ║   └─SVal(freeVarNames)
    ║   ╟─(bind) $i := 0
    ║   ║ ├─○ (lexical $i :decl())
    ║   ║ └─IVal
    ║   ╟─(for) @fvns {\n        nqp::bindkey(%fvs, $_, @fvs[$i]);...
    ║   ║ ├─○ (lexical @fvns :decl())
    ║   ║ ├◄Block {\n        nqp::bindkey(%fvs, $_, @fvs[$i]);\n    ...
    ║   ║ │ ╟─○ (lexical $_ :decl(param))
    ║   ║ │ ╟─(bindkey) nqp::bindkey(%fvs, $_, @fvs[$i])
    ║   ║ │ ║ ├─○ (lexical %fvs :decl())
    ║   ║ │ ║ ├─○ (lexical $_ :decl())
    ║   ║ │ ║ └─VarWithFallback(positional  :decl())
    ║   ║ │ ║   ├─○ (lexical @fvs :decl())
    ║   ║ │ ║   └─○ (lexical $i :decl())
    ║   ║ │ ╙─(postinc) ++
    ║   ║ │   └─○ (lexical $i :decl())
    ║   ║ └─IVal(1 :named(0))
    ║   ╟─(bindkey) nqp::bindkey(%out, 'freeVars', %fvs)
    ║   ║ ├─○ (lexical %out :decl())
    ║   ║ ├─SVal(freeVars)
    ║   ║ └─○ (lexical %fvs :decl())
    ║   ╙─○ (lexical %out :decl())
    ╟─(bind)
    ║ ├─○ (lexical .typecase :decl(var))
    ║ └◄Block {\n    say('>>>typecase(', nqp::reprname($subject)...
    ║   ╟─○ (lexical $subject :decl(param)) $subject
    ║   ╟─○ (lexical %callbacks :decl(param) :named(0)) %callbacks
    ║   ╟─○ (lexical $otherwise :decl(var))
    ║   ╟─(bind) $cbKey
    ║   ║ ├─○ (lexical $cbKey :decl(var))
    ║   ║ └─WVal(NQPMu)
    ║   ╟─○ (lexical $cb :decl(var))
    ║   ╟─(call .say) '>>>typecase(', nqp::reprname($subject), '...) '
    ║   ║ ├─SVal(>>>typecase()
    ║   ║ ├─(reprname) nqp::reprname($subject)
    ║   ║ │ └─○ (lexical $subject :decl())
    ║   ║ └─SVal(...) )
    ║   ╟─(bind) $otherwise := nqp::defor(\n        %callbacks<othe...
    ║   ║ ├─○ (lexical $otherwise :decl())
    ║   ║ └─(defor) nqp::defor(\n        %callbacks<otherwise>,\n     ...
    ║   ║   ├─VarWithFallback(associative  :decl())
    ║   ║   │ ├─○ (lexical %callbacks :decl())
    ║   ║   │ └─SVal(otherwise)
    ║   ║   └─(takeclosure)
    ║   ║     └◄Block { # compiler should see that this needs not be a c...
    ║   ║       ╟─○ (lexical $x :decl(param)) $x
    ║   ║       ╙─(die) nqp::die('typecase: fell through due to missing \"...
    ║   ║         └─(concat) ~
    ║   ║           ├─SVal(typecase: fell through due to missing \"otherwise\"-callback: )
    ║   ║           └─(reprname) nqp::reprname($subject)
    ║   ║             └─○ (lexical $subject :decl())
    ║   ╟─(if) nqp::islist($subject) {\n        my $id := nqp::at...
    ║   ║ ├─(islist) nqp::islist($subject)
    ║   ║ │ └─○ (lexical $subject :decl())
    ║   ║ ├◄Block {\n        my $id := nqp::atpos($subject, 0);\n   ...
    ║   ║ │ ╟─○ (lexical $id :decl(var))
    ║   ║ │ ╟─○ (lexical $tag :decl(var))
    ║   ║ │ ╟─(bind) $id := nqp::atpos($subject, 0)
    ║   ║ │ ║ ├─○ (lexical $id :decl())
    ║   ║ │ ║ └─(atpos) nqp::atpos($subject, 0)
    ║   ║ │ ║   ├─○ (lexical $subject :decl())
    ║   ║ │ ║   └─IVal
    ║   ║ │ ╟─(bind) $tag := nqp::substr($id, 0, 1)
    ║   ║ │ ║ ├─○ (lexical $tag :decl())
    ║   ║ │ ║ └─(substr) nqp::substr($id, 0, 1)
    ║   ║ │ ║   ├─○ (lexical $id :decl())
    ║   ║ │ ║   ├─IVal
    ║   ║ │ ║   └─IVal(1)
    ║   ║ │ ╙─(if) $tag eq 'λ' {\n            $cbKey := $tag;\n        }
    ║   ║ │   ├─(iseq_s) eq
    ║   ║ │   │ ├─○ (lexical $tag :decl())
    ║   ║ │   │ └─SVal(λ)
    ║   ║ │   ├─(bind) :=
    ║   ║ │   │ ├─○ (lexical $cbKey :decl())
    ║   ║ │   │ └─○ (lexical $tag :decl())
    ║   ║ │   └─(if) nqp::elems($subject) == 0 {\n                nqp::...
    ║   ║ │     ├─(iseq_n) ==
    ║   ║ │     │ ├─(elems) nqp::elems($subject)
    ║   ║ │     │ │ └─○ (lexical $subject :decl())
    ║   ║ │     │ └─IVal
    ║   ║ │     ├─(die) nqp::die('typecase: unsupported low-level list typ...
    ║   ║ │     │ └─SVal(typecase: unsupported low-level list type - empty)
    ║   ║ │     └─(die) nqp::die('typecase: unsupported low-level list typ...
    ║   ║ │       └─(concat) ~
    ║   ║ │         ├─SVal(typecase: unsupported low-level list type - invalid tag )
    ║   ║ │         └─(reprname) nqp::reprname($tag)
    ║   ║ │           └─○ (lexical $tag :decl())
    ║   ║ └─(if) nqp::isstr($subject) { $cbKey := 'str';\n        }
    ║   ║   ├─(isstr) nqp::isstr($subject)
    ║   ║   │ └─○ (lexical $subject :decl())
    ║   ║   ├─(bind) :=
    ║   ║   │ ├─○ (lexical $cbKey :decl())
    ║   ║   │ └─SVal(str)
    ║   ║   └─(if) nqp::isint($subject) { $cbKey := 'int';\n        }
    ║   ║     ├─(isint) nqp::isint($subject)
    ║   ║     │ └─○ (lexical $subject :decl())
    ║   ║     ├─(bind) :=
    ║   ║     │ ├─○ (lexical $cbKey :decl())
    ║   ║     │ └─SVal(int)
    ║   ║     └─(if) nqp::isnum($subject) { $cbKey := 'num';\n        }
    ║   ║       ├─(isnum) nqp::isnum($subject)
    ║   ║       │ └─○ (lexical $subject :decl())
    ║   ║       ├─(bind) :=
    ║   ║       │ ├─○ (lexical $cbKey :decl())
    ║   ║       │ └─SVal(num)
    ║   ║       └─(die) nqp::die('typecase: unsupported low-level type ' ~...
    ║   ║         └─(concat) ~
    ║   ║           ├─SVal(typecase: unsupported low-level type )
    ║   ║           └─(reprname) nqp::reprname($subject)
    ║   ║             └─○ (lexical $subject :decl())
    ║   ╟─(bind) $cb := nqp::defor(%callbacks{$cbKey}, $otherwise)
    ║   ║ ├─○ (lexical $cb :decl())
    ║   ║ └─(defor) nqp::defor(%callbacks{$cbKey}, $otherwise)
    ║   ║   ├─VarWithFallback(associative  :decl())
    ║   ║   │ ├─○ (lexical %callbacks :decl())
    ║   ║   │ └─○ (lexical $cbKey :decl())
    ║   ║   └─○ (lexical $otherwise :decl())
    ║   ╙─(call) $subject
    ║     ├─○ (lexical $cb :decl())
    ║     └─○ (lexical $subject :decl())
    ╟─(bind)
    ║ ├─○ (lexical .int2str :decl(var))
    ║ └◄Block { ~$i }
    ║   ╟─○ (lexical $i :decl(param)) $i
    ║   ╙─(stringify) ~
    ║     └─○ (lexical $i :decl())
    ╟─(bind)
    ║ ├─○ (lexical .num2str :decl(var))
    ║ └◄Block { ~$n }
    ║   ╟─○ (lexical $n :decl(param)) $n
    ║   ╙─(stringify) ~
    ║     └─○ (lexical $n :decl())
    ╟─(bind)
    ║ ├─○ (lexical .strLit :decl(var))
    ║ └◄Block { '\"' ~ nqp::escape($s) ~ '\"' }
    ║   ╟─○ (lexical $s :decl(param)) $s
    ║   ╙─(concat) ~
    ║     ├─(concat) ~
    ║     │ ├─SVal(\")
    ║     │ └─(escape) nqp::escape($s)
    ║     │   └─○ (lexical $s :decl())
    ║     └─SVal(\")
    ╟─(bind)
    ║ ├─○ (lexical .strOut :decl(var))
    ║ └◄Block {\n    typecase(force($v),\n        :λ(-> $lambda ...
    ║   ╟─○ (lexical $v :decl(param)) $v
    ║   ╟─○ (lexical $indent :decl(param)) $indent
    ║   ╟─○ (lexical %done :decl(param)) %done
    ║   ╙─(call .typecase) force($v),\n        :λ(-> $lambda { # compiler sho...
    ║     ├─(call .force) $v
    ║     │ └─○ (lexical $v :decl())
    ║     ├─(takeclosure :named(0))
    ║     │ └◄Block { # compiler should see that this needs not be a c...
    ║     │   ╟─○ (lexical $lambda :decl(param)) $lambda
    ║     │   ╟─○ (lexical %info :decl(var))
    ║     │   ╟─○ (lexical $src :decl(var))
    ║     │   ╟─○ (lexical %fvs :decl(var))
    ║     │   ╟─(bind) %info := lam2info($lambda)
    ║     │   ║ ├─○ (lexical %info :decl())
    ║     │   ║ └─(call .lam2info) $lambda
    ║     │   ║   └─○ (lexical $lambda :decl())
    ║     │   ╟─(bind) $src := %info<src>
    ║     │   ║ ├─○ (lexical $src :decl())
    ║     │   ║ └─VarWithFallback(associative  :decl())
    ║     │   ║   ├─○ (lexical %info :decl())
    ║     │   ║   └─SVal(src)
    ║     │   ╟─(bind) %fvs := %info<freeVars>
    ║     │   ║ ├─○ (lexical %fvs :decl())
    ║     │   ║ └─VarWithFallback(associative  :decl())
    ║     │   ║   ├─○ (lexical %info :decl())
    ║     │   ║   └─SVal(freeVars)
    ║     │   ╟─(for) %fvs {\n                my $fvName  := nqp::iterke...
    ║     │   ║ ├─○ (lexical %fvs :decl())
    ║     │   ║ ├◄Block {\n                my $fvName  := nqp::iterkey_s($...
    ║     │   ║ │ ╟─○ (lexical $fvName :decl(var))
    ║     │   ║ │ ╟─○ (lexical $fv :decl(var))
    ║     │   ║ │ ╟─○ (lexical $pre :decl(var))
    ║     │   ║ │ ╟─○ (lexical $flatVal :decl(var))
    ║     │   ║ │ ╟─○ (lexical $doneKey :decl(var))
    ║     │   ║ │ ╟─○ (lexical $_ :decl(param))
    ║     │   ║ │ ╟─(bind) $fvName  := nqp::iterkey_s($_)
    ║     │   ║ │ ║ ├─○ (lexical $fvName :decl())
    ║     │   ║ │ ║ └─(iterkey_s) nqp::iterkey_s($_)
    ║     │   ║ │ ║   └─○ (lexical $_ :decl())
    ║     │   ║ │ ╟─(bind) $fv      := nqp::iterval($_)
    ║     │   ║ │ ║ ├─○ (lexical $fv :decl())
    ║     │   ║ │ ║ └─(iterval) nqp::iterval($_)
    ║     │   ║ │ ║   └─○ (lexical $_ :decl())
    ║     │   ║ │ ╟─(bind) $pre     := \"# where $fvName = \"
    ║     │   ║ │ ║ ├─○ (lexical $pre :decl())
    ║     │   ║ │ ║ └─(concat)
    ║     │   ║ │ ║   ├─(concat)
    ║     │   ║ │ ║   │ ├─SVal(# where )
    ║     │   ║ │ ║   │ └─○ (lexical $fvName :decl())
    ║     │   ║ │ ║   └─SVal( = )
    ║     │   ║ │ ╟─(bind) $flatVal := typecase($fv,\n                    :λ(...
    ║     │   ║ │ ║ ├─○ (lexical $flatVal :decl())
    ║     │   ║ │ ║ └─(call .typecase) $fv,\n                    :λ(-> $x { nqp::null }),...
    ║     │   ║ │ ║   ├─○ (lexical $fv :decl())
    ║     │   ║ │ ║   ├─(takeclosure :named(0))
    ║     │   ║ │ ║   │ └◄Block { nqp::null }
    ║     │   ║ │ ║   │   ╟─○ (lexical $x :decl(param)) $x
    ║     │   ║ │ ║   │   ╙─(null) nqp::null
    ║     │   ║ │ ║   ├─○ (lexical .strLit :decl() :named(0))
    ║     │   ║ │ ║   ├─○ (lexical .int2str :decl() :named(0))
    ║     │   ║ │ ║   └─○ (lexical .num2str :decl() :named(0))
    ║     │   ║ │ ╟─(bind) $doneKey := nqp::isnull($flatVal)\n               ...
    ║     │   ║ │ ║ ├─○ (lexical $doneKey :decl())
    ║     │   ║ │ ║ └─(if) ?? $pre ~ lam2id($fv)\n                    !!
    ║     │   ║ │ ║   ├─(isnull) nqp::isnull($flatVal)
    ║     │   ║ │ ║   │ └─○ (lexical $flatVal :decl())
    ║     │   ║ │ ║   ├─(concat) ~
    ║     │   ║ │ ║   │ ├─○ (lexical $pre :decl())
    ║     │   ║ │ ║   │ └─(call .lam2id) $fv
    ║     │   ║ │ ║   │   └─○ (lexical $fv :decl())
    ║     │   ║ │ ║   └─(concat) ~
    ║     │   ║ │ ║     ├─○ (lexical $pre :decl())
    ║     │   ║ │ ║     └─○ (lexical $flatVal :decl())
    ║     │   ║ │ ╙─(unless) %done{$doneKey} {\n                    %done{$done...
    ║     │   ║ │   ├─VarWithFallback(associative  :decl())
    ║     │   ║ │   │ ├─○ (lexical %done :decl())
    ║     │   ║ │   │ └─○ (lexical $doneKey :decl())
    ║     │   ║ │   └◄Stmts {\n                    %done{$doneKey} := 1;\n    ...
    ║     │   ║ │     ├─(bind) :=
    ║     │   ║ │     │ ├─VarWithFallback(associative  :decl())
    ║     │   ║ │     │ │ ├─○ (lexical %done :decl())
    ║     │   ║ │     │ │ └─○ (lexical $doneKey :decl())
    ║     │   ║ │     │ └─IVal(1)
    ║     │   ║ │     └─(bind) :=
    ║     │   ║ │       ├─○ (lexical $src :decl())
    ║     │   ║ │       └─(concat) ~
    ║     │   ║ │         ├─(concat) ~
    ║     │   ║ │         │ ├─(concat) ~
    ║     │   ║ │         │ │ ├─○ (lexical $src :decl())
    ║     │   ║ │         │ │ └─SVal(\n)
    ║     │   ║ │         │ └─○ (lexical $indent :decl())
    ║     │   ║ │         └─(if) ?? $pre ~ strOut($fv, $indent ~ '#' ~ nqp::x(' ', ...
    ║     │   ║ │           ├─(isnull) nqp::isnull($flatVal)
    ║     │   ║ │           │ └─○ (lexical $flatVal :decl())
    ║     │   ║ │           ├─(concat) ~
    ║     │   ║ │           │ ├─○ (lexical $pre :decl())
    ║     │   ║ │           │ └─(call .strOut) $fv, $indent ~ '#' ~ nqp::x(' ', nqp::chars($pre) ...
    ║     │   ║ │           │   ├─○ (lexical $fv :decl())
    ║     │   ║ │           │   ├─(concat) ~
    ║     │   ║ │           │   │ ├─(concat) ~
    ║     │   ║ │           │   │ │ ├─○ (lexical $indent :decl())
    ║     │   ║ │           │   │ │ └─SVal(#)
    ║     │   ║ │           │   │ └─(x) nqp::x(' ', nqp::chars($pre) - 1)
    ║     │   ║ │           │   │   ├─SVal( )
    ║     │   ║ │           │   │   └─(sub_n) -
    ║     │   ║ │           │   │     ├─(chars) nqp::chars($pre)
    ║     │   ║ │           │   │     │ └─○ (lexical $pre :decl())
    ║     │   ║ │           │   │     └─IVal(1)
    ║     │   ║ │           │   └─○ (lexical %done :decl())
    ║     │   ║ │           └─○ (lexical $doneKey :decl())
    ║     │   ║ └─IVal(1 :named(0))
    ║     │   ╙─○ (lexical $src :decl())
    ║     ├─○ (lexical .strLit :decl() :named(0))
    ║     ├─○ (lexical .int2str :decl() :named(0))
    ║     └─○ (lexical .num2str :decl() :named(0))
    ╟─(bind)
    ║ ├─○ (lexical .apply1 :decl(var))
    ║ └◄Block {\n    my $result := typecase(force($f),\n        ...
    ║   ╟─○ (lexical $f :decl(param)) $f
    ║   ╟─○ (lexical $a1 :decl(param)) $a1
    ║   ╟─○ (lexical $result :decl(var))
    ║   ╟─(bind) $result := typecase(force($f),\n        :λ(&lam2co...
    ║   ║ ├─○ (lexical $result :decl())
    ║   ║ └─(call) $a1
    ║   ║   ├─(call .typecase) force($f),\n        :λ(&lam2code),\n        :other...
    ║   ║   │ ├─(call .force) $f
    ║   ║   │ │ └─○ (lexical $f :decl())
    ║   ║   │ ├─○ (lexical .lam2code :decl() :named(0))
    ║   ║   │ └─(takeclosure :named(0))
    ║   ║   │   └◄Block {\n            nqp::die('ERROR: cannot apply ' ~ s...
    ║   ║   │     ╟─○ (lexical $x :decl(param)) $x
    ║   ║   │     ╙─(die) nqp::die('ERROR: cannot apply ' ~ strOut($x) ~ ' t...
    ║   ║   │       └─(concat) ~
    ║   ║   │         ├─(concat) ~
    ║   ║   │         │ ├─(concat) ~
    ║   ║   │         │ │ ├─SVal(ERROR: cannot apply )
    ║   ║   │         │ │ └─(call .strOut) $x
    ║   ║   │         │ │   └─○ (lexical $x :decl())
    ║   ║   │         │ └─SVal( to )
    ║   ║   │         └─(call .strOut) $a1
    ║   ║   │           └─○ (lexical $a1 :decl())
    ║   ║   └─○ (lexical $a1 :decl())
    ║   ╙─(call .force) $result
    ║     └─○ (lexical $result :decl())
    ╟─(bind)
    ║ ├─○ (lexical .say :decl(var))
    ║ └◄Block {\n    my $s := '';\n    for @args {\n        $s :...
    ║   ╟─○ (lexical @args :decl(param)) @args
    ║   ╟─○ (lexical $s :decl(var))
    ║   ╟─(bind) $s := ''
    ║   ║ ├─○ (lexical $s :decl())
    ║   ║ └─SVal
    ║   ╟─(for) @args {\n        $s := $s ~ (nqp::isstr($_)\n     ...
    ║   ║ ├─○ (lexical @args :decl())
    ║   ║ ├◄Block {\n        $s := $s ~ (nqp::isstr($_)\n           ...
    ║   ║ │ ╟─○ (lexical $_ :decl(param))
    ║   ║ │ ╙─(bind) :=
    ║   ║ │   ├─○ (lexical $s :decl())
    ║   ║ │   └─(concat) ~
    ║   ║ │     ├─○ (lexical $s :decl())
    ║   ║ │     └─(if) ?? $_\n            !!
    ║   ║ │       ├─(isstr) nqp::isstr($_)
    ║   ║ │       │ └─○ (lexical $_ :decl())
    ║   ║ │       ├─○ (lexical $_ :decl())
    ║   ║ │       └─(call .strOut) $_
    ║   ║ │         └─○ (lexical $_ :decl())
    ║   ║ └─IVal(1 :named(0))
    ║   ╙─(say) nqp::say($s)
    ║     └─○ (lexical $s :decl())
    ╟─(bind)
    ║ ├─○ (local ctxsave :decl(var))
    ║ └─○ (contextual $*CTXSAVE :decl())
    ╟─(unless)
    ║ ├─(isnull)
    ║ │ └─○ (local ctxsave :decl())
    ║ └─(if)
    ║   ├─(can)
    ║   │ ├─○ (local ctxsave :decl())
    ║   │ └─SVal(ctxsave)
    ║   └─(callmethod ctxsave)
    ║     └─○ (local ctxsave :decl())
    ╟─(bind) $λsrc := '(λf.λstart.λxs.xs start (λhd.λtl.self f ...
    ║ ├─○ (lexical .λsrc :decl())
    ║ └─SVal((λf.λstart.λxs.xs start (λhd.λtl.self f (f start hd) tl)) (λ_.x))
    ╙─(bind) %info := nqp::hash(\n    'λ', [\n        nqp::hash...
      ├─○ (lexical %info :decl())
      └─(hash) nqp::hash(\n    'λ', [\n        nqp::hash('from', ...
        ├─SVal(λ)
        └─(list) ,
          ├─(hash) nqp::hash('from',  1, 'length', 55, 'freeVarNames'...
          │ ├─SVal(from)
          │ ├─IVal(1)
          │ ├─SVal(length)
          │ ├─IVal(55)
          │ ├─SVal(freeVarNames)
          │ └─(list) ,
          │   ├─SVal(foo)
          │   ├─SVal(bar)
          │   ├─SVal(baz)
          │   ├─SVal(qumbl)
          │   ├─SVal(self)
          │   └─SVal(self)
          └─(hash) nqp::hash('from', 59, 'length',  4, 'freeVarNames'...
            ├─SVal(from)
            ├─IVal(59)
            ├─SVal(length)
            ├─IVal(4)
            ├─SVal(freeVarNames)
            └─(list)
              └─SVal(foo)