──:CompUnit+{StrByDump}
  └─:Block
    ╟○ lexical @ARGS :decl(param) :slurpy(1)
    ╟─:Stmts
    ║ ├○ lexical GLOBALish :decl(static) :default((GLOBALish, Type object))
    ║ ├○ lexical $?PACKAGE :decl(static) :default((GLOBALish, Type object))
    ║ ├○ lexical EXPORT :decl(static) :default((EXPORT, Type object))
    ║ ├─bind
    ║ │ ├○ lexical @?DEPENDENCIES :decl(static)
    ║ │ └─list
    ║ │   ├◙ SVal "nqp"
    ║ │   ├◙ SVal "NQPHLL"
    ║ │   ├◙ SVal "Util"
    ║ │   └◙ SVal "Util::QAST"
    ║ ├○ lexical &min :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &max :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &unixify :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &describe :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &say :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &join :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &istype :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &linesFrom :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical StrByDump :decl(static) :default((StrByDump, Type object))
    ║ ├○ lexical &dump :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &qastChildren :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &removeChild :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &findPath :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &findPaths :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &fix_var_attrs :decl(static) :default((NQPRoutine, invokable))
    ║ ├○ lexical &drop_Stmts :decl(static) :default((NQPRoutine, invokable))
    ║ ├─bind
    ║ │ ├○ lexical &drop_takeclosure :decl(var)
    ║ │ └─:Block  ««"{\n    nqp::die('drop_takeclosure expects a QAST::N"...
    ║ │   ╟─:Stmts
    ║ │   ║ └○ lexical $ast :decl(param)
    ║ │   ╙─:Stmts  ««"\n    nqp::die('drop_takeclosure expects a QAST::No"...
    ║ │     ├─:Stmts
    ║ │     │ └─unless  ««"nqp::die('drop_takeclosure expects a QAST::Node - g"...
    ║ │     │   ├─call &istype  ««"$ast, QAST::Node"
    ║ │     │   │ ├○ lexical $ast
    ║ │     │   │ └◙ WVal QAST::Node
    ║ │     │   └─die  ««"nqp::die('drop_takeclosure expects a QAST::Node - g"...
    ║ │     │     └─concat &infix:<~>  ««"~"
    ║ │     │       ├◙ SVal "drop_takeclosure expects a QAST::Node - got "
    ║ │     │       └─reprname  ««"nqp::reprname($ast)"
    ║ │     │         └○ lexical $ast
    ║ │     ├─:Stmts
    ║ │     │ └─if  ««"istype($ast, QAST::Op) && $ast.op eq 'takeclosure' "...
    ║ │     │   ├─if &infix:<&&>  ««"&&"
    ║ │     │   │ ├─call &istype  ««"$ast, QAST::Op"
    ║ │     │   │ │ ├○ lexical $ast
    ║ │     │   │ │ └◙ WVal QAST::Op
    ║ │     │   │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   │   ├─callmethod op  ««".op"
    ║ │     │   │   │ └○ lexical $ast
    ║ │     │   │   └◙ SVal "takeclosure"
    ║ │     │   ├─:Block :blocktype(immediate)  ««"{\n        my $child := drop_takeclosure($ast[0]); "...
    ║ │     │   │ ╟─:Stmts
    ║ │     │   │ ║ └○ lexical $child :decl(var)
    ║ │     │   │ ╙─:Stmts  ««"\n        my $child := drop_takeclosure($ast[0]);  "...
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$child := drop_takeclosure($ast[0])"
    ║ │     │   │   │   ├○ lexical $child
    ║ │     │   │   │   └─call &drop_takeclosure  ««"$ast[0]"
    ║ │     │   │   │     └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │   │   │       ├○ lexical $ast
    ║ │     │   │   │       └◙ IVal 0
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─if  ««"istype($ast, QAST::SpecialArg) {\n            $chil"...
    ║ │     │   │   │   ├─call &istype  ««"$ast, QAST::SpecialArg"
    ║ │     │   │   │   │ ├○ lexical $ast
    ║ │     │   │   │   │ └◙ WVal QAST::SpecialArg
    ║ │     │   │   │   └─:Stmts  ««"{\n            $child.HOW.mixin($child, QAST::Speci"...
    ║ │     │   │   │     ├─:Stmts
    ║ │     │   │   │     └─:Stmts  ««"\n            $child.HOW.mixin($child, QAST::Specia"...
    ║ │     │   │   │       ├─:Stmts
    ║ │     │   │   │       │ └─callmethod mixin  ««"$child, QAST::SpecialArg"
    ║ │     │   │   │       │   ├─how  ««".HOW"
    ║ │     │   │   │       │   │ └○ lexical $child
    ║ │     │   │   │       │   ├○ lexical $child
    ║ │     │   │   │       │   └◙ WVal QAST::SpecialArg
    ║ │     │   │   │       ├─:Stmts
    ║ │     │   │   │       │ └─callmethod flat  ««"$ast.flat"
    ║ │     │   │   │       │   ├○ lexical $child
    ║ │     │   │   │       │   └─callmethod flat  ««".flat"
    ║ │     │   │   │       │     └○ lexical $ast
    ║ │     │   │   │       └─:Stmts
    ║ │     │   │   │         └─callmethod named  ««"$ast.named"
    ║ │     │   │   │           ├○ lexical $child
    ║ │     │   │   │           └─callmethod named  ««".named"
    ║ │     │   │   │             └○ lexical $ast
    ║ │     │   │   └─:Stmts
    ║ │     │   │     └─bind &infix:<:=>  ««":="
    ║ │     │   │       ├○ lexical $ast
    ║ │     │   │       └○ lexical $child
    ║ │     │   └─if  ««"nqp::can($ast, 'list') { # workaround - not all nod"...
    ║ │     │     ├─can  ««"nqp::can($ast, 'list')"
    ║ │     │     │ ├○ lexical $ast
    ║ │     │     │ └◙ SVal "list"
    ║ │     │     └─:Block :blocktype(immediate)  ««"{ # workaround - not all nodes with children actual"...
    ║ │     │       ╟─:Stmts
    ║ │     │       ║ ├○ lexical @children :decl(var)
    ║ │     │       ║ └○ lexical @list :decl(var)
    ║ │     │       ╙─:Stmts  ««" # workaround - not all nodes with children actuall"...
    ║ │     │         ├─:Stmts
    ║ │     │         │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@children := []"
    ║ │     │         │   ├○ lexical @children
    ║ │     │         │   └─list &circumfix:<[ ]>
    ║ │     │         ├─:Stmts
    ║ │     │         │ └─for  ««"$ast.list {\n            @children.push(drop_takecl"...
    ║ │     │         │   ├─callmethod list  ««".list"
    ║ │     │         │   │ └○ lexical $ast
    ║ │     │         │   ├─:Block :blocktype(immediate)  ««"{\n            @children.push(drop_takeclosure($_))"...
    ║ │     │         │   │ ╟─:Stmts
    ║ │     │         │   │ ║ └○ lexical $_ :decl(param)
    ║ │     │         │   │ ╙─:Stmts  ««"\n            @children.push(drop_takeclosure($_));"...
    ║ │     │         │   │   └─:Stmts
    ║ │     │         │   │     └─callmethod push  ««"drop_takeclosure($_)"
    ║ │     │         │   │       ├○ lexical @children
    ║ │     │         │   │       └─call &drop_takeclosure  ««"$_"
    ║ │     │         │   │         └○ lexical $_
    ║ │     │         │   └◙ IVal 1 :named("nohandler")
    ║ │     │         ├─:Stmts
    ║ │     │         │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@list := $ast.list"
    ║ │     │         │   ├○ lexical @list
    ║ │     │         │   └─callmethod list  ««".list"
    ║ │     │         │     └○ lexical $ast
    ║ │     │         ├─:Stmts
    ║ │     │         │ └─while  ««"+@list { @list.pop }"
    ║ │     │         │   ├─numify &prefix:<+>  ««"+"
    ║ │     │         │   │ └○ lexical @list
    ║ │     │         │   ├─:Stmts  ««"{ @list.pop }"
    ║ │     │         │   │ ├─:Stmts
    ║ │     │         │   │ └─:Stmts  ««" @list.pop "
    ║ │     │         │   │   └─:Stmts
    ║ │     │         │   │     └─callmethod pop  ««".pop"
    ║ │     │         │   │       └○ lexical @list
    ║ │     │         │   └◙ IVal 1 :named("nohandler")
    ║ │     │         └─:Stmts
    ║ │     │           └─for  ««"@children { @list.push($_) }"
    ║ │     │             ├○ lexical @children
    ║ │     │             ├─:Block :blocktype(immediate)  ««"{ @list.push($_) }"
    ║ │     │             │ ╟─:Stmts
    ║ │     │             │ ║ └○ lexical $_ :decl(param)
    ║ │     │             │ ╙─:Stmts  ««" @list.push($_) "
    ║ │     │             │   └─:Stmts
    ║ │     │             │     └─callmethod push  ««"$_"
    ║ │     │             │       ├○ lexical @list
    ║ │     │             │       └○ lexical $_
    ║ │     │             └◙ IVal 1 :named("nohandler")
    ║ │     └─:Stmts
    ║ │       └○ lexical $ast
    ║ ├─bind
    ║ │ ├○ lexical &isinResultPosition :decl(var)
    ║ │ └─:Block  ««"{\n    my $n := nqp::elems($parent) - 1;\n    if ($"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $node :decl(param)
    ║ │   ║ ├○ lexical $parent :decl(param)
    ║ │   ║ └○ lexical $n :decl(var)
    ║ │   ╙─lexotic RETURN
    ║ │     └─:Stmts  ««"\n    my $n := nqp::elems($parent) - 1;\n    if ($p"...
    ║ │       ├─:Stmts
    ║ │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$n := nqp::elems($parent) - 1"
    ║ │       │   ├○ lexical $n
    ║ │       │   └─sub_n &infix:<->  ««"-"
    ║ │       │     ├─elems  ««"nqp::elems($parent)"
    ║ │       │     │ └○ lexical $parent
    ║ │       │     └◙ IVal 1
    ║ │       ├─:Stmts
    ║ │       │ └─if  ««"($parent[$n] =:= $node) || (nqp::can($parent, 'resu"...
    ║ │       │   ├─unless &infix:<||>  ««"||"
    ║ │       │   │ ├─eqaddr &infix:<=:=>  ««"=:="
    ║ │       │   │ │ ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │       │   │ │ │ ├○ lexical $parent
    ║ │       │   │ │ │ └○ lexical $n
    ║ │       │   │ │ └○ lexical $node
    ║ │       │   │ └─if &infix:<&&>  ««"&&"
    ║ │       │   │   ├─can  ««"nqp::can($parent, 'resultchild')"
    ║ │       │   │   │ ├○ lexical $parent
    ║ │       │   │   │ └◙ SVal "resultchild"
    ║ │       │   │   └─eqaddr &infix:<=:=>  ««"=:="
    ║ │       │   │     ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │       │   │     │ ├○ lexical $parent
    ║ │       │   │     │ └─callmethod resultchild  ««".resultchild"
    ║ │       │   │     │   └○ lexical $parent
    ║ │       │   │     └○ lexical $node
    ║ │       │   └─:Stmts  ««"{\n        return 1;\n    }"
    ║ │       │     ├─:Stmts
    ║ │       │     └─:Stmts  ««"\n        return 1;\n    "
    ║ │       │       └─:Stmts
    ║ │       │         └─call RETURN
    ║ │       │           └◙ IVal 1
    ║ │       ├─:Stmts
    ║ │       │ └─while  ««"--$n >= 0 {\n        return 0 if $node =:= $parent["...
    ║ │       │   ├─isge_n &infix:<>=>  ««">="
    ║ │       │   │ ├─predec &prefix:<-->  ««"--"
    ║ │       │   │ │ └○ lexical $n
    ║ │       │   │ └◙ IVal 0
    ║ │       │   ├─:Stmts  ««"{\n        return 0 if $node =:= $parent[$n];\n    }"
    ║ │       │   │ ├─:Stmts
    ║ │       │   │ └─:Stmts  ««"\n        return 0 if $node =:= $parent[$n];\n    "
    ║ │       │   │   └─:Stmts
    ║ │       │   │     └─if  ««"return 0 if $node =:= $parent[$n]"
    ║ │       │   │       ├─eqaddr &infix:<=:=>  ««"=:="
    ║ │       │   │       │ ├○ lexical $node
    ║ │       │   │       │ └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │       │   │       │   ├○ lexical $parent
    ║ │       │   │       │   └○ lexical $n
    ║ │       │   │       └─call RETURN
    ║ │       │   │         └◙ IVal 0
    ║ │       │   └◙ IVal 1 :named("nohandler")
    ║ │       └─:Stmts
    ║ │         └─die  ««"nqp::die(describe($node) ~ ' not a child of ' ~ des"...
    ║ │           └─concat &infix:<~>  ««"~"
    ║ │             ├─concat &infix:<~>  ««"~"
    ║ │             │ ├─call &describe  ««"$node"
    ║ │             │ │ └○ lexical $node
    ║ │             │ └◙ SVal " not a child of "
    ║ │             └─call &describe  ««"$parent"
    ║ │               └○ lexical $parent
    ║ ├─bind
    ║ │ ├○ lexical &drop_bogusVars :decl(var)
    ║ │ └─:Block  ««"{\n    if istype($ast, QAST::Var) && !$ast.decl {\n"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $ast :decl(param)
    ║ │   ║ └○ lexical $parent :decl(param) :default(null)
    ║ │   ╙─lexotic RETURN
    ║ │     └─:Stmts  ««"\n    if istype($ast, QAST::Var) && !$ast.decl {\n "...
    ║ │       ├─:Stmts
    ║ │       │ └─if  ««"istype($ast, QAST::Var) && !$ast.decl {\n        if"...
    ║ │       │   ├─if &infix:<&&>  ««"&&"
    ║ │       │   │ ├─call &istype  ««"$ast, QAST::Var"
    ║ │       │   │ │ ├○ lexical $ast
    ║ │       │   │ │ └◙ WVal QAST::Var
    ║ │       │   │ └─falsey &prefix:<!>  ««"!"
    ║ │       │   │   └─callmethod decl  ««".decl"
    ║ │       │   │     └○ lexical $ast
    ║ │       │   ├─:Stmts  ««"{\n        if istype($parent, QAST::Block, QAST::St"...
    ║ │       │   │ ├─:Stmts
    ║ │       │   │ └─:Stmts  ««"\n        if istype($parent, QAST::Block, QAST::Stm"...
    ║ │       │   │   └─:Stmts
    ║ │       │   │     └─if  ««"istype($parent, QAST::Block, QAST::Stmt, QAST::Stmt"...
    ║ │       │   │       ├─call &istype  ««"$parent, QAST::Block, QAST::Stmt, QAST::Stmts"
    ║ │       │   │       │ ├○ lexical $parent
    ║ │       │   │       │ ├◙ WVal QAST::Block
    ║ │       │   │       │ ├◙ WVal QAST::Stmt
    ║ │       │   │       │ └◙ WVal QAST::Stmts
    ║ │       │   │       └─:Stmts  ««"{\n            unless isinResultPosition($ast, $par"...
    ║ │       │   │         ├─:Stmts
    ║ │       │   │         └─:Stmts  ««"\n            unless isinResultPosition($ast, $pare"...
    ║ │       │   │           └─:Stmts
    ║ │       │   │             └─unless  ««"isinResultPosition($ast, $parent) {\n              "...
    ║ │       │   │               ├─call &isinResultPosition  ««"$ast, $parent"
    ║ │       │   │               │ ├○ lexical $ast
    ║ │       │   │               │ └○ lexical $parent
    ║ │       │   │               └─:Stmts  ««"{\n                #nqp::print(describe($parent) ~ "...
    ║ │       │   │                 ├─:Stmts
    ║ │       │   │                 └─:Stmts  ««"\n                #nqp::print(describe($parent) ~ '"...
    ║ │       │   │                   └─:Stmts
    ║ │       │   │                     └─call RETURN
    ║ │       │   │                       └─null  ««"nqp::null"
    ║ │       │   └─if  ««"+$ast.list { # workaround - not all nodes with chil"...
    ║ │       │     ├─numify &prefix:<+>  ««"+"
    ║ │       │     │ └─callmethod list  ««".list"
    ║ │       │     │   └○ lexical $ast
    ║ │       │     └─:Block :blocktype(immediate)  ««"{ # workaround - not all nodes with children actual"...
    ║ │       │       ╟─:Stmts
    ║ │       │       ║ ├○ lexical @children :decl(var)
    ║ │       │       ║ └○ lexical $changed :decl(var)
    ║ │       │       ╙─:Stmts  ««" # workaround - not all nodes with children actuall"...
    ║ │       │         ├─:Stmts
    ║ │       │         │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@children := []"
    ║ │       │         │   ├○ lexical @children
    ║ │       │         │   └─list &circumfix:<[ ]>
    ║ │       │         ├─:Stmts
    ║ │       │         │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$changed := 0"
    ║ │       │         │   ├○ lexical $changed
    ║ │       │         │   └◙ IVal 0
    ║ │       │         ├─:Stmts
    ║ │       │         │ └─for  ««"$ast.list {\n            my $child := drop_bogusVar"...
    ║ │       │         │   ├─callmethod list  ««".list"
    ║ │       │         │   │ └○ lexical $ast
    ║ │       │         │   ├─:Block :blocktype(immediate)  ««"{\n            my $child := drop_bogusVars($_, $ast"...
    ║ │       │         │   │ ╟─:Stmts
    ║ │       │         │   │ ║ ├○ lexical $child :decl(var)
    ║ │       │         │   │ ║ └○ lexical $_ :decl(param)
    ║ │       │         │   │ ╙─:Stmts  ««"\n            my $child := drop_bogusVars($_, $ast)"...
    ║ │       │         │   │   ├─:Stmts
    ║ │       │         │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$child := drop_bogusVars($_, $ast)"
    ║ │       │         │   │   │   ├○ lexical $child
    ║ │       │         │   │   │   └─call &drop_bogusVars  ««"$_, $ast"
    ║ │       │         │   │   │     ├○ lexical $_
    ║ │       │         │   │   │     └○ lexical $ast
    ║ │       │         │   │   └─:Stmts
    ║ │       │         │   │     └─if  ««"nqp::isnull($child) {\n                $changed := "...
    ║ │       │         │   │       ├─isnull  ««"nqp::isnull($child)"
    ║ │       │         │   │       │ └○ lexical $child
    ║ │       │         │   │       ├─:Stmts  ««"{\n                $changed := 1;\n            }"
    ║ │       │         │   │       │ ├─:Stmts
    ║ │       │         │   │       │ └─:Stmts  ««"\n                $changed := 1;\n            "
    ║ │       │         │   │       │   └─:Stmts
    ║ │       │         │   │       │     └─bind &infix:<:=>  ««":="
    ║ │       │         │   │       │       ├○ lexical $changed
    ║ │       │         │   │       │       └◙ IVal 1
    ║ │       │         │   │       └─:Stmts  ««"{\n                @children.push($child);\n       "...
    ║ │       │         │   │         ├─:Stmts
    ║ │       │         │   │         └─:Stmts  ««"\n                @children.push($child);\n        "...
    ║ │       │         │   │           └─:Stmts
    ║ │       │         │   │             └─callmethod push  ««"$child"
    ║ │       │         │   │               ├○ lexical @children
    ║ │       │         │   │               └○ lexical $child
    ║ │       │         │   └◙ IVal 1 :named("nohandler")
    ║ │       │         └─:Stmts
    ║ │       │           └─if  ««"$changed {\n            my @list := $ast.list;\n   "...
    ║ │       │             ├○ lexical $changed
    ║ │       │             └─:Block :blocktype(immediate)  ««"{\n            my @list := $ast.list;\n            "...
    ║ │       │               ╟─:Stmts
    ║ │       │               ║ └○ lexical @list :decl(var)
    ║ │       │               ╙─:Stmts  ««"\n            my @list := $ast.list;\n            w"...
    ║ │       │                 ├─:Stmts
    ║ │       │                 │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@list := $ast.list"
    ║ │       │                 │   ├○ lexical @list
    ║ │       │                 │   └─callmethod list  ««".list"
    ║ │       │                 │     └○ lexical $ast
    ║ │       │                 ├─:Stmts
    ║ │       │                 │ └─while  ««"+@list { @list.pop }"
    ║ │       │                 │   ├─numify &prefix:<+>  ««"+"
    ║ │       │                 │   │ └○ lexical @list
    ║ │       │                 │   ├─:Stmts  ««"{ @list.pop }"
    ║ │       │                 │   │ ├─:Stmts
    ║ │       │                 │   │ └─:Stmts  ««" @list.pop "
    ║ │       │                 │   │   └─:Stmts
    ║ │       │                 │   │     └─callmethod pop  ««".pop"
    ║ │       │                 │   │       └○ lexical @list
    ║ │       │                 │   └◙ IVal 1 :named("nohandler")
    ║ │       │                 └─:Stmts
    ║ │       │                   └─for  ««"@children { @list.push($_) }"
    ║ │       │                     ├○ lexical @children
    ║ │       │                     ├─:Block :blocktype(immediate)  ««"{ @list.push($_) }"
    ║ │       │                     │ ╟─:Stmts
    ║ │       │                     │ ║ └○ lexical $_ :decl(param)
    ║ │       │                     │ ╙─:Stmts  ««" @list.push($_) "
    ║ │       │                     │   └─:Stmts
    ║ │       │                     │     └─callmethod push  ««"$_"
    ║ │       │                     │       ├○ lexical @list
    ║ │       │                     │       └○ lexical $_
    ║ │       │                     └◙ IVal 1 :named("nohandler")
    ║ │       └─:Stmts
    ║ │         └○ lexical $ast
    ║ ├─bind
    ║ │ ├○ lexical &remove_bogusOpNames :decl(var)
    ║ │ └─:Block  ««"{\n    nqp::die('remove_bogusOpNames expects a QAST"...
    ║ │   ╟─:Stmts
    ║ │   ║ └○ lexical $ast :decl(param)
    ║ │   ╙─:Stmts  ««"\n    nqp::die('remove_bogusOpNames expects a QAST:"...
    ║ │     ├─:Stmts
    ║ │     │ └─unless  ««"nqp::die('remove_bogusOpNames expects a QAST::Node "...
    ║ │     │   ├─call &istype  ««"$ast, QAST::Node"
    ║ │     │   │ ├○ lexical $ast
    ║ │     │   │ └◙ WVal QAST::Node
    ║ │     │   └─die  ««"nqp::die('remove_bogusOpNames expects a QAST::Node "...
    ║ │     │     └─concat &infix:<~>  ««"~"
    ║ │     │       ├◙ SVal "remove_bogusOpNames expects a QAST::Node - got "
    ║ │     │       └─reprname  ««"nqp::reprname($ast)"
    ║ │     │         └○ lexical $ast
    ║ │     ├─:Stmts
    ║ │     │ └─if  ««"istype($ast, QAST::Op) && ($ast.op ne 'call') && ($"...
    ║ │     │   ├─if &infix:<&&>  ««"&&"
    ║ │     │   │ ├─if &infix:<&&>  ««"&&"
    ║ │     │   │ │ ├─if &infix:<&&>  ««"&&"
    ║ │     │   │ │ │ ├─if &infix:<&&>  ««"&&"
    ║ │     │   │ │ │ │ ├─call &istype  ««"$ast, QAST::Op"
    ║ │     │   │ │ │ │ │ ├○ lexical $ast
    ║ │     │   │ │ │ │ │ └◙ WVal QAST::Op
    ║ │     │   │ │ │ │ └─isne_s &infix:<ne>  ««"ne"
    ║ │     │   │ │ │ │   ├─callmethod op  ««".op"
    ║ │     │   │ │ │ │   │ └○ lexical $ast
    ║ │     │   │ │ │ │   └◙ SVal "call"
    ║ │     │   │ │ │ └─isne_s &infix:<ne>  ««"ne"
    ║ │     │   │ │ │   ├─callmethod op  ««".op"
    ║ │     │   │ │ │   │ └○ lexical $ast
    ║ │     │   │ │ │   └◙ SVal "callstatic"
    ║ │     │   │ │ └─isne_s &infix:<ne>  ««"ne"
    ║ │     │   │ │   ├─callmethod op  ««".op"
    ║ │     │   │ │   │ └○ lexical $ast
    ║ │     │   │ │   └◙ SVal "callmethod"
    ║ │     │   │ └─isne_s &infix:<ne>  ««"ne"
    ║ │     │   │   ├─callmethod op  ««".op"
    ║ │     │   │   │ └○ lexical $ast
    ║ │     │   │   └◙ SVal "lexotic"
    ║ │     │   └─:Stmts  ««"{\n        #say('>>>Op(', $ast.op, ' ', $ast.dump_e"...
    ║ │     │     ├─:Stmts
    ║ │     │     └─:Stmts  ««"\n        #say('>>>Op(', $ast.op, ' ', $ast.dump_ex"...
    ║ │     │       └─:Stmts
    ║ │     │         └─callmethod name  ««"nqp::null_s"
    ║ │     │           ├○ lexical $ast
    ║ │     │           └─null_s  ««"nqp::null_s"
    ║ │     ├─:Stmts
    ║ │     │ └─for  ««"$ast.list {\n        remove_bogusOpNames($_);\n    }"
    ║ │     │   ├─callmethod list  ««".list"
    ║ │     │   │ └○ lexical $ast
    ║ │     │   ├─:Block :blocktype(immediate)  ««"{\n        remove_bogusOpNames($_);\n    }"
    ║ │     │   │ ╟─:Stmts
    ║ │     │   │ ║ └○ lexical $_ :decl(param)
    ║ │     │   │ ╙─:Stmts  ««"\n        remove_bogusOpNames($_);\n    "
    ║ │     │   │   └─:Stmts
    ║ │     │   │     └─call &remove_bogusOpNames  ««"$_"
    ║ │     │   │       └○ lexical $_
    ║ │     │   └◙ IVal 1 :named("nohandler")
    ║ │     └─:Stmts
    ║ │       └○ lexical $ast
    ║ ├─bind
    ║ │ ├○ lexical &remove_MAIN :decl(var)
    ║ │ └─:Block  ««"{\n    say($ast[0].cuid);\n    say(\"CompUnit load:"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $ast :decl(param)
    ║ │   ║ ├○ lexical @path :decl(var)
    ║ │   ║ ├○ lexical $MAIN :decl(var)
    ║ │   ║ └○ lexical $MAINcall :decl(var)
    ║ │   ╙─:Stmts  ««"\n    say($ast[0].cuid);\n    say(\"CompUnit load: "...
    ║ │     ├─:Stmts
    ║ │     │ └─call &say  ««"$ast[0].cuid"
    ║ │     │   └─callmethod cuid  ««".cuid"
    ║ │     │     └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │       ├○ lexical $ast
    ║ │     │       └◙ IVal 0
    ║ │     ├─:Stmts
    ║ │     │ └─call &say  ««"\"CompUnit load: \\n\", dump($ast.load)"
    ║ │     │   ├◙ SVal "CompUnit load: \n"
    ║ │     │   └─call &dump  ««"$ast.load"
    ║ │     │     └─callmethod load  ««".load"
    ║ │     │       └○ lexical $ast
    ║ │     ├─:Stmts
    ║ │     │ └─call &say  ««"\"CompUnit main: \\n\", dump($ast.main)"
    ║ │     │   ├◙ SVal "CompUnit main: \n"
    ║ │     │   └─call &dump  ««"$ast.main"
    ║ │     │     └─callmethod main  ««".main"
    ║ │     │       └○ lexical $ast
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@path := []"
    ║ │     │   ├○ lexical @path
    ║ │     │   └─list &circumfix:<[ ]>
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$MAIN := findDef($ast, '&MAIN', @path)"
    ║ │     │   ├○ lexical $MAIN
    ║ │     │   └─call &findDef  ««"$ast, '&MAIN', @path"
    ║ │     │     ├○ lexical $ast
    ║ │     │     ├◙ SVal "&MAIN"
    ║ │     │     └○ lexical @path
    ║ │     ├─:Stmts
    ║ │     │ └─call &removeChild  ««"@path[0], $MAIN"
    ║ │     │   ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │   │ ├○ lexical @path
    ║ │     │   │ └◙ IVal 0
    ║ │     │   └○ lexical $MAIN
    ║ │     ├─:Stmts
    ║ │     │ └─call &say  ««"describe(@path), \"\\n\", describe($MAIN)"
    ║ │     │   ├─call &describe  ««"@path"
    ║ │     │   │ └○ lexical @path
    ║ │     │   ├◙ SVal "\n"
    ║ │     │   └─call &describe  ««"$MAIN"
    ║ │     │     └○ lexical $MAIN
    ║ │     ├─:Stmts
    ║ │     │ └─bind &infix:<:=>  ««":="
    ║ │     │   ├○ lexical @path
    ║ │     │   └─list &circumfix:<[ ]>
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$MAINcall := findPath(-> $node, @pathUp {\n        "...
    ║ │     │   ├○ lexical $MAINcall
    ║ │     │   └─call &findPath  ««"-> $node, @pathUp {\n            if istype($node, Q"...
    ║ │     │     ├─takeclosure
    ║ │     │     │ └─:Block  ««"{\n            if istype($node, QAST::Op) && ($node"...
    ║ │     │     │   ╟─:Stmts
    ║ │     │     │   ║ ├○ lexical $node :decl(param)
    ║ │     │     │   ║ └○ lexical @pathUp :decl(param)
    ║ │     │     │   ╙─:Stmts  ««"\n            if istype($node, QAST::Op) && ($node."...
    ║ │     │     │     └─:Stmts
    ║ │     │     │       └─if  ««"istype($node, QAST::Op) && ($node.op eq 'call') && "...
    ║ │     │     │         ├─if &infix:<&&>  ««"&&"
    ║ │     │     │         │ ├─if &infix:<&&>  ««"&&"
    ║ │     │     │         │ │ ├─call &istype  ««"$node, QAST::Op"
    ║ │     │     │         │ │ │ ├○ lexical $node
    ║ │     │     │         │ │ │ └◙ WVal QAST::Op
    ║ │     │     │         │ │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │     │         │ │   ├─callmethod op  ««".op"
    ║ │     │     │         │ │   │ └○ lexical $node
    ║ │     │     │         │ │   └◙ SVal "call"
    ║ │     │     │         │ └─unless &infix:<||>  ««"||"
    ║ │     │     │         │   ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │     │         │   │ ├─callmethod name  ««".name"
    ║ │     │     │         │   │ │ └○ lexical $node
    ║ │     │     │         │   │ └◙ SVal "&MAIN"
    ║ │     │     │         │   └─if &infix:<&&>  ««"&&"
    ║ │     │     │         │     ├─call &istype  ««"$node[0], QAST::Var"
    ║ │     │     │         │     │ ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │     │         │     │ │ ├○ lexical $node
    ║ │     │     │         │     │ │ └◙ IVal 0
    ║ │     │     │         │     │ └◙ WVal QAST::Var
    ║ │     │     │         │     └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │     │         │       ├─callmethod name  ««".name"
    ║ │     │     │         │       │ └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │     │         │       │   ├○ lexical $node
    ║ │     │     │         │       │   └◙ IVal 0
    ║ │     │     │         │       └◙ SVal "&MAIN"
    ║ │     │     │         ├─:Block :blocktype(immediate)  ««"{\n                my $parent := @pathUp[0];\n     "...
    ║ │     │     │         │ ╟─:Stmts
    ║ │     │     │         │ ║ └○ lexical $parent :decl(var)
    ║ │     │     │         │ ╙─:Stmts  ««"\n                my $parent := @pathUp[0];\n      "...
    ║ │     │     │         │   ├─:Stmts
    ║ │     │     │         │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$parent := @pathUp[0]"
    ║ │     │     │         │   │   ├○ lexical $parent
    ║ │     │     │         │   │   └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │     │         │   │     ├○ lexical @pathUp
    ║ │     │     │         │   │     └◙ IVal 0
    ║ │     │     │         │   └─:Stmts
    ║ │     │     │         │     └─if  ««"istype($parent, QAST::Op) && $parent.op eq 'if' {\n"...
    ║ │     │     │         │       ├─if &infix:<&&>  ««"&&"
    ║ │     │     │         │       │ ├─call &istype  ««"$parent, QAST::Op"
    ║ │     │     │         │       │ │ ├○ lexical $parent
    ║ │     │     │         │       │ │ └◙ WVal QAST::Op
    ║ │     │     │         │       │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │     │         │       │   ├─callmethod op  ««".op"
    ║ │     │     │         │       │   │ └○ lexical $parent
    ║ │     │     │         │       │   └◙ SVal "if"
    ║ │     │     │         │       ├─:Stmts  ««"{\n                    $parent;\n                }"
    ║ │     │     │         │       │ ├─:Stmts
    ║ │     │     │         │       │ └─:Stmts  ««"\n                    $parent;\n                "
    ║ │     │     │         │       │   └─:Stmts
    ║ │     │     │         │       │     └○ lexical $parent
    ║ │     │     │         │       └─if  ««"istype($parent, QAST::Stmt, QAST::Stmts) {\n       "...
    ║ │     │     │         │         ├─call &istype  ««"$parent, QAST::Stmt, QAST::Stmts"
    ║ │     │     │         │         │ ├○ lexical $parent
    ║ │     │     │         │         │ ├◙ WVal QAST::Stmt
    ║ │     │     │         │         │ └◙ WVal QAST::Stmts
    ║ │     │     │         │         └─:Stmts  ««"{\n                    $parent := @pathUp[0];\n    "...
    ║ │     │     │         │           ├─:Stmts
    ║ │     │     │         │           └─:Stmts  ««"\n                    $parent := @pathUp[0];\n     "...
    ║ │     │     │         │             ├─:Stmts
    ║ │     │     │         │             │ └─bind &infix:<:=>  ««":="
    ║ │     │     │         │             │   ├○ lexical $parent
    ║ │     │     │         │             │   └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │     │         │             │     ├○ lexical @pathUp
    ║ │     │     │         │             │     └◙ IVal 0
    ║ │     │     │         │             └─:Stmts
    ║ │     │     │         │               └─if  ««"istype($parent, QAST::Op) && $parent.op eq 'if' {\n"...
    ║ │     │     │         │                 ├─if &infix:<&&>  ««"&&"
    ║ │     │     │         │                 │ ├─call &istype  ««"$parent, QAST::Op"
    ║ │     │     │         │                 │ │ ├○ lexical $parent
    ║ │     │     │         │                 │ │ └◙ WVal QAST::Op
    ║ │     │     │         │                 │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │     │         │                 │   ├─callmethod op  ««".op"
    ║ │     │     │         │                 │   │ └○ lexical $parent
    ║ │     │     │         │                 │   └◙ SVal "if"
    ║ │     │     │         │                 ├─:Stmts  ««"{\n                        $parent;\n              "...
    ║ │     │     │         │                 │ ├─:Stmts
    ║ │     │     │         │                 │ └─:Stmts  ««"\n                        $parent;\n               "...
    ║ │     │     │         │                 │   └─:Stmts
    ║ │     │     │         │                 │     └○ lexical $parent
    ║ │     │     │         │                 └─:Stmts  ««"{\n                        $node\n                 "...
    ║ │     │     │         │                   ├─:Stmts
    ║ │     │     │         │                   └─:Stmts  ««"\n                        $node\n                    "
    ║ │     │     │         │                     └─:Stmts
    ║ │     │     │         │                       └○ lexical $node
    ║ │     │     │         └─:Stmts  ««"{\n                $node.list;\n            }"
    ║ │     │     │           ├─:Stmts
    ║ │     │     │           └─:Stmts  ««"\n                $node.list;\n            "
    ║ │     │     │             └─:Stmts
    ║ │     │     │               └─callmethod list  ««".list"
    ║ │     │     │                 └○ lexical $node
    ║ │     │     ├○ lexical $ast
    ║ │     │     └○ lexical @path
    ║ │     ├─:Stmts
    ║ │     │ └─call &removeChild  ««"@path[0], $MAINcall"
    ║ │     │   ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │   │ ├○ lexical @path
    ║ │     │   │ └◙ IVal 0
    ║ │     │   └○ lexical $MAINcall
    ║ │     └─:Stmts
    ║ │       └○ lexical $ast
    ║ ├─bind
    ║ │ ├○ lexical &findDef :decl(var)
    ║ │ └─:Block  ««"{\n    if nqp::isstr($matcher) {\n        my $name "...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $ast :decl(param)
    ║ │   ║ ├○ lexical $matcher :decl(param)
    ║ │   ║ └○ lexical @pathUp :decl(param) :default(list &circumfix:<[ ]>)
    ║ │   ╙─:Stmts  ««"\n    if nqp::isstr($matcher) {\n        my $name :"...
    ║ │     ├─:Stmts
    ║ │     │ └─if  ««"nqp::isstr($matcher) {\n        my $name := $matche"...
    ║ │     │   ├─isstr  ««"nqp::isstr($matcher)"
    ║ │     │   │ └○ lexical $matcher
    ║ │     │   └─:Block :blocktype(immediate)  ««"{\n        my $name := $matcher;\n        $matcher "...
    ║ │     │     ╟─:Stmts
    ║ │     │     ║ └○ lexical $name :decl(var)
    ║ │     │     ╙─:Stmts  ««"\n        my $name := $matcher;\n        $matcher :"...
    ║ │     │       ├─:Stmts
    ║ │     │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$name := $matcher"
    ║ │     │       │   ├○ lexical $name
    ║ │     │       │   └○ lexical $matcher
    ║ │     │       └─:Stmts
    ║ │     │         └─bind &infix:<:=>  ««":="
    ║ │     │           ├○ lexical $matcher
    ║ │     │           └─takeclosure
    ║ │     │             └─:Block  ««"{ $var.name eq $name && $var.decl }"
    ║ │     │               ╟─:Stmts
    ║ │     │               ║ ├○ lexical $var :decl(param)
    ║ │     │               ║ └○ lexical @pathUp :decl(param)
    ║ │     │               ╙─:Stmts  ««" $var.name eq $name && $var.decl "
    ║ │     │                 └─:Stmts
    ║ │     │                   └─if &infix:<&&>  ««"&&"
    ║ │     │                     ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │                     │ ├─callmethod name  ««".name"
    ║ │     │                     │ │ └○ lexical $var
    ║ │     │                     │ └○ lexical $name
    ║ │     │                     └─callmethod decl  ««".decl"
    ║ │     │                       └○ lexical $var
    ║ │     └─:Stmts
    ║ │       └─call &findPath  ««"\n        -> $node, @pathUp {\n            my $pare"...
    ║ │         ├─takeclosure
    ║ │         │ └─:Block  ««"{\n            my $parent := nqp::elems(@pathUp) > "...
    ║ │         │   ╟─:Stmts
    ║ │         │   ║ ├○ lexical $node :decl(param)
    ║ │         │   ║ ├○ lexical @pathUp :decl(param)
    ║ │         │   ║ └○ lexical $parent :decl(var)
    ║ │         │   ╙─:Stmts  ««"\n            my $parent := nqp::elems(@pathUp) > 0"...
    ║ │         │     ├─:Stmts
    ║ │         │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$parent := nqp::elems(@pathUp) > 0 ?? @pathUp[0] !!"...
    ║ │         │     │   ├○ lexical $parent
    ║ │         │     │   └─if &infix:<>  ««"?? @pathUp[0] !!"
    ║ │         │     │     ├─isgt_n &infix:<>>  ««">"
    ║ │         │     │     │ ├─elems  ««"nqp::elems(@pathUp)"
    ║ │         │     │     │ │ └○ lexical @pathUp
    ║ │         │     │     │ └◙ IVal 0
    ║ │         │     │     ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │         │     │     │ ├○ lexical @pathUp
    ║ │         │     │     │ └◙ IVal 0
    ║ │         │     │     └─null  ««"nqp::null"
    ║ │         │     └─:Stmts
    ║ │         │       └─if  ««"nqp::isnull($parent) || istype($parent, QAST::CompU"...
    ║ │         │         ├─unless &infix:<||>  ««"||"
    ║ │         │         │ ├─isnull  ««"nqp::isnull($parent)"
    ║ │         │         │ │ └○ lexical $parent
    ║ │         │         │ └─call &istype  ««"$parent, QAST::CompUnit"
    ║ │         │         │   ├○ lexical $parent
    ║ │         │         │   └◙ WVal QAST::CompUnit
    ║ │         │         ├─:Stmts  ««"{\n                $node.list;\n            }"
    ║ │         │         │ ├─:Stmts
    ║ │         │         │ └─:Stmts  ««"\n                $node.list;\n            "
    ║ │         │         │   └─:Stmts
    ║ │         │         │     └─callmethod list  ««".list"
    ║ │         │         │       └○ lexical $node
    ║ │         │         └─if  ««"istype($parent, QAST::Op) && istype($node, QAST::Va"...
    ║ │         │           ├─if &infix:<&&>  ««"&&"
    ║ │         │           │ ├─call &istype  ««"$parent, QAST::Op"
    ║ │         │           │ │ ├○ lexical $parent
    ║ │         │           │ │ └◙ WVal QAST::Op
    ║ │         │           │ └─call &istype  ««"$node, QAST::Var"
    ║ │         │           │   ├○ lexical $node
    ║ │         │           │   └◙ WVal QAST::Var
    ║ │         │           ├─:Stmts  ««"{\n                 $parent.op eq 'bind' && $matche"...
    ║ │         │           │ ├─:Stmts
    ║ │         │           │ └─:Stmts  ««"\n                 $parent.op eq 'bind' && $matcher"...
    ║ │         │           │   └─:Stmts
    ║ │         │           │     └─if &infix:<>  ««"?? $parent\n                    !!"
    ║ │         │           │       ├─if &infix:<&&>  ««"&&"
    ║ │         │           │       │ ├─iseq_s &infix:<eq>  ««"eq"
    ║ │         │           │       │ │ ├─callmethod op  ««".op"
    ║ │         │           │       │ │ │ └○ lexical $parent
    ║ │         │           │       │ │ └◙ SVal "bind"
    ║ │         │           │       │ └─call  ««"$node, @pathUp"
    ║ │         │           │       │   ├○ lexical $matcher
    ║ │         │           │       │   ├○ lexical $node
    ║ │         │           │       │   └○ lexical @pathUp
    ║ │         │           │       ├○ lexical $parent
    ║ │         │           │       └─null  ««"nqp::null"
    ║ │         │           └─if  ««"istype($parent, QAST::Block, QAST::Stmts, QAST::Stm"...
    ║ │         │             ├─call &istype  ««"$parent, QAST::Block, QAST::Stmts, QAST::Stmt, QAST"...
    ║ │         │             │ ├○ lexical $parent
    ║ │         │             │ ├◙ WVal QAST::Block
    ║ │         │             │ ├◙ WVal QAST::Stmts
    ║ │         │             │ ├◙ WVal QAST::Stmt
    ║ │         │             │ └◙ WVal QAST::Op
    ║ │         │             ├─:Block :blocktype(immediate)  ««"{\n                my @next := qastChildren($node, "...
    ║ │         │             │ ╟─:Stmts
    ║ │         │             │ ║ └○ lexical @next :decl(var)
    ║ │         │             │ ╙─:Stmts  ««"\n                my @next := qastChildren($node, Q"...
    ║ │         │             │   ├─:Stmts
    ║ │         │             │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@next := qastChildren($node, QAST::Block, QAST::Stm"...
    ║ │         │             │   │   ├○ lexical @next
    ║ │         │             │   │   └─call &qastChildren  ««"$node, QAST::Block, QAST::Stmts, QAST::Stmt, QAST::"...
    ║ │         │             │   │     ├○ lexical $node
    ║ │         │             │   │     ├◙ WVal QAST::Block
    ║ │         │             │   │     ├◙ WVal QAST::Stmts
    ║ │         │             │   │     ├◙ WVal QAST::Stmt
    ║ │         │             │   │     ├◙ WVal QAST::Var
    ║ │         │             │   │     └◙ WVal QAST::Op
    ║ │         │             │   └─:Stmts
    ║ │         │             │     └○ lexical @next
    ║ │         │             └─:Stmts  ««"{\n                0;\n            }"
    ║ │         │               ├─:Stmts
    ║ │         │               └─:Stmts  ««"\n                0;\n            "
    ║ │         │                 └─:Stmts
    ║ │         │                   └◙ IVal 0
    ║ │         ├○ lexical $ast
    ║ │         └○ lexical @pathUp
    ║ ├─bind
    ║ │ ├○ lexical &findDefs :decl(var)
    ║ │ └─:Block  ««"{\n    my @out := [];\n    my $current := 1;\n    w"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $ast :decl(param)
    ║ │   ║ ├○ lexical $matcher :decl(param)
    ║ │   ║ ├○ lexical @out :decl(var)
    ║ │   ║ └○ lexical $current :decl(var)
    ║ │   ╙─:Stmts  ««"\n    my @out := [];\n    my $current := 1;\n    wh"...
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@out := []"
    ║ │     │   ├○ lexical @out
    ║ │     │   └─list &circumfix:<[ ]>
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$current := 1"
    ║ │     │   ├○ lexical $current
    ║ │     │   └◙ IVal 1
    ║ │     ├─:Stmts
    ║ │     │ └─while  ««"$current {\n        $current := findDef($ast, -> $v"...
    ║ │     │   ├○ lexical $current
    ║ │     │   ├─:Stmts  ««"{\n        $current := findDef($ast, -> $var, @path"...
    ║ │     │   │ ├─:Stmts
    ║ │     │   │ └─:Stmts  ««"\n        $current := findDef($ast, -> $var, @pathU"...
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─bind &infix:<:=>  ««":="
    ║ │     │   │   │   ├○ lexical $current
    ║ │     │   │   │   └─call &findDef  ««"$ast, -> $var, @pathUp {\n            my $takeit :="...
    ║ │     │   │   │     ├○ lexical $ast
    ║ │     │   │   │     └─takeclosure
    ║ │     │   │   │       └─:Block  ««"{\n            my $takeit := 0;\n            if $ma"...
    ║ │     │   │   │         ╟─:Stmts
    ║ │     │   │   │         ║ ├○ lexical $var :decl(param)
    ║ │     │   │   │         ║ ├○ lexical @pathUp :decl(param)
    ║ │     │   │   │         ║ └○ lexical $takeit :decl(var)
    ║ │     │   │   │         ╙─:Stmts  ««"\n            my $takeit := 0;\n            if $mat"...
    ║ │     │   │   │           ├─:Stmts
    ║ │     │   │   │           │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$takeit := 0"
    ║ │     │   │   │           │   ├○ lexical $takeit
    ║ │     │   │   │           │   └◙ IVal 0
    ║ │     │   │   │           ├─:Stmts
    ║ │     │   │   │           │ └─if  ««"$matcher($var, @pathUp) {\n                $takeit "...
    ║ │     │   │   │           │   ├─call  ««"$var, @pathUp"
    ║ │     │   │   │           │   │ ├○ lexical $matcher
    ║ │     │   │   │           │   │ ├○ lexical $var
    ║ │     │   │   │           │   │ └○ lexical @pathUp
    ║ │     │   │   │           │   └─:Block :blocktype(immediate)  ««"{\n                $takeit := 1;\n                m"...
    ║ │     │   │   │           │     ╟─:Stmts
    ║ │     │   │   │           │     ║ └○ lexical $i :decl(var)
    ║ │     │   │   │           │     ╙─:Stmts  ««"\n                $takeit := 1;\n                my"...
    ║ │     │   │   │           │       ├─:Stmts
    ║ │     │   │   │           │       │ └─bind &infix:<:=>  ««":="
    ║ │     │   │   │           │       │   ├○ lexical $takeit
    ║ │     │   │   │           │       │   └◙ IVal 1
    ║ │     │   │   │           │       ├─:Stmts
    ║ │     │   │   │           │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$i := nqp::iterator(@out)"
    ║ │     │   │   │           │       │   ├○ lexical $i
    ║ │     │   │   │           │       │   └─iterator  ««"nqp::iterator(@out)"
    ║ │     │   │   │           │       │     └○ lexical @out
    ║ │     │   │   │           │       └─:Stmts
    ║ │     │   │   │           │         └─while  ««"$i && $takeit {\n                    $takeit := !(n"...
    ║ │     │   │   │           │           ├─if &infix:<&&>  ««"&&"
    ║ │     │   │   │           │           │ ├○ lexical $i
    ║ │     │   │   │           │           │ └○ lexical $takeit
    ║ │     │   │   │           │           ├─:Stmts  ««"{\n                    $takeit := !(nqp::shift($i)["...
    ║ │     │   │   │           │           │ ├─:Stmts
    ║ │     │   │   │           │           │ └─:Stmts  ««"\n                    $takeit := !(nqp::shift($i)[0"...
    ║ │     │   │   │           │           │   └─:Stmts
    ║ │     │   │   │           │           │     └─bind &infix:<:=>  ««":="
    ║ │     │   │   │           │           │       ├○ lexical $takeit
    ║ │     │   │   │           │           │       └─falsey &prefix:<!>  ««"!"
    ║ │     │   │   │           │           │         └─eqaddr &infix:<=:=>  ««"=:="
    ║ │     │   │   │           │           │           ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │   │   │           │           │           │ ├─shift  ««"nqp::shift($i)"
    ║ │     │   │   │           │           │           │ │ └○ lexical $i
    ║ │     │   │   │           │           │           │ └◙ IVal 0
    ║ │     │   │   │           │           │           └○ lexical $var
    ║ │     │   │   │           │           └◙ IVal 1 :named("nohandler")
    ║ │     │   │   │           └─:Stmts
    ║ │     │   │   │             └○ lexical $takeit
    ║ │     │   │   └─:Stmts
    ║ │     │   │     └─unless  ««"nqp::isnull($current) {\n#            say(nqp::elem"...
    ║ │     │   │       ├─isnull  ««"nqp::isnull($current)"
    ║ │     │   │       │ └○ lexical $current
    ║ │     │   │       └─:Stmts  ««"{\n#            say(nqp::elems(@out), ': ', dump($c"...
    ║ │     │   │         ├─:Stmts
    ║ │     │   │         └─:Stmts  ««"\n#            say(nqp::elems(@out), ': ', dump($cu"...
    ║ │     │   │           └─:Stmts
    ║ │     │   │             └─callmethod push  ««"$current"
    ║ │     │   │               ├○ lexical @out
    ║ │     │   │               └○ lexical $current
    ║ │     │   └◙ IVal 1 :named("nohandler")
    ║ │     └─:Stmts
    ║ │       └○ lexical @out
    ║ ├─bind
    ║ │ ├○ lexical &findValueNodeInHash :decl(var)
    ║ │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable) ))  ««"{\n    nqp::die('findValueNodeInHash expects a fn a"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $keyPredicate :decl(param)
    ║ │   ║ ├○ lexical $valuePredicate :decl(param)
    ║ │   ║ ├○ lexical $hash :decl(param) :default((┬VarWithFallback associative  :decl() :fallback((ifnull) ((atkey) ((who) (WVal GLOBALish)) (SVal "NO_VALUE")) (WVal NQPMu))) ((who) ( lexical $?PACKAGE :decl())) (SVal "NO_VALUE"))
    ║ │   ║ └○ lexical $found :decl(var)
    ║ │   ╙─lexotic RETURN
    ║ │     └─:Stmts  ««"\n    nqp::die('findValueNodeInHash expects a fn as"...
    ║ │       ├─:Stmts
    ║ │       │ └─unless  ««"nqp::die('findValueNodeInHash expects a fn as 1st a"...
    ║ │       │   ├─isinvokable  ««"nqp::isinvokable($keyPredicate)"
    ║ │       │   │ └○ lexical $keyPredicate
    ║ │       │   └─die  ««"nqp::die('findValueNodeInHash expects a fn as 1st a"...
    ║ │       │     └─concat &infix:<~>  ««"~"
    ║ │       │       ├◙ SVal "findValueNodeInHash expects a fn as 1st arg - got "
    ║ │       │       └─call &describe  ««"$keyPredicate"
    ║ │       │         └○ lexical $keyPredicate
    ║ │       ├─:Stmts
    ║ │       │ └─unless  ««"nqp::die('findValueNodeInHash expects a fn as 2nd a"...
    ║ │       │   ├─isinvokable  ««"nqp::isinvokable($valuePredicate)"
    ║ │       │   │ └○ lexical $valuePredicate
    ║ │       │   └─die  ««"nqp::die('findValueNodeInHash expects a fn as 2nd a"...
    ║ │       │     └─concat &infix:<~>  ««"~"
    ║ │       │       ├◙ SVal "findValueNodeInHash expects a fn as 2nd arg - got "
    ║ │       │       └─call &describe  ««"$valuePredicate"
    ║ │       │         └○ lexical $valuePredicate
    ║ │       ├─:Stmts
    ║ │       │ └─if  ««"$hash =:= NO_VALUE {\n        return -> $hash { fin"...
    ║ │       │   ├─eqaddr &infix:<=:=>  ««"=:="
    ║ │       │   │ ├○ lexical $hash
    ║ │       │   │ └○┬VarWithFallback associative  :fallback((ifnull) ((atkey) ((who) (WVal GLOBALish)) (SVal "NO_VALUE")) (WVal NQPMu))
    ║ │       │   │   ├─who
    ║ │       │   │   │ └○ lexical $?PACKAGE
    ║ │       │   │   └◙ SVal "NO_VALUE"
    ║ │       │   ├─:Stmts  ««"{\n        return -> $hash { findValueNodeInHash($k"...
    ║ │       │   │ ├─:Stmts
    ║ │       │   │ └─:Stmts  ««"\n        return -> $hash { findValueNodeInHash($ke"...
    ║ │       │   │   └─:Stmts
    ║ │       │   │     └─call RETURN
    ║ │       │   │       └─takeclosure
    ║ │       │   │         └─:Block  ««"{ findValueNodeInHash($keyPredicate, $valuePredicat"...
    ║ │       │   │           ╟─:Stmts
    ║ │       │   │           ║ └○ lexical $hash :decl(param)
    ║ │       │   │           ╙─:Stmts  ««" findValueNodeInHash($keyPredicate, $valuePredicate"...
    ║ │       │   │             └─:Stmts
    ║ │       │   │               └─call &findValueNodeInHash  ««"$keyPredicate, $valuePredicate, $hash"
    ║ │       │   │                 ├○ lexical $keyPredicate
    ║ │       │   │                 ├○ lexical $valuePredicate
    ║ │       │   │                 └○ lexical $hash
    ║ │       │   └─if  ««"!istype($hash, QAST::Node) {\n        nqp::die('fin"...
    ║ │       │     ├─falsey &prefix:<!>  ««"!"
    ║ │       │     │ └─call &istype  ««"$hash, QAST::Node"
    ║ │       │     │   ├○ lexical $hash
    ║ │       │     │   └◙ WVal QAST::Node
    ║ │       │     └─:Stmts  ««"{\n        nqp::die('findValueNodeInHash expects a "...
    ║ │       │       ├─:Stmts
    ║ │       │       └─:Stmts  ««"\n        nqp::die('findValueNodeInHash expects a Q"...
    ║ │       │         └─:Stmts
    ║ │       │           └─die  ««"nqp::die('findValueNodeInHash expects a QAST::Node "...
    ║ │       │             └─concat &infix:<~>  ««"~"
    ║ │       │               ├◙ SVal "findValueNodeInHash expects a QAST::Node as (optional) 3rd arg - got "
    ║ │       │               └─call &describe  ««"$hash"
    ║ │       │                 └○ lexical $hash
    ║ │       ├─:Stmts
    ║ │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$found := nqp::null"
    ║ │       │   ├○ lexical $found
    ║ │       │   └─null  ««"nqp::null"
    ║ │       ├─:Stmts
    ║ │       │ └─if  ««"istype($hash, QAST::Op) && $hash.op eq 'hash' {\n  "...
    ║ │       │   ├─if &infix:<&&>  ««"&&"
    ║ │       │   │ ├─call &istype  ««"$hash, QAST::Op"
    ║ │       │   │ │ ├○ lexical $hash
    ║ │       │   │ │ └◙ WVal QAST::Op
    ║ │       │   │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │       │   │   ├─callmethod op  ««".op"
    ║ │       │   │   │ └○ lexical $hash
    ║ │       │   │   └◙ SVal "hash"
    ║ │       │   └─:Block :blocktype(immediate)  ««"{\n        my $it := nqp::iterator($hash.list);\n  "...
    ║ │       │     ╟─:Stmts
    ║ │       │     ║ └○ lexical $it :decl(var)
    ║ │       │     ╙─:Stmts  ««"\n        my $it := nqp::iterator($hash.list);\n   "...
    ║ │       │       ├─:Stmts
    ║ │       │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$it := nqp::iterator($hash.list)"
    ║ │       │       │   ├○ lexical $it
    ║ │       │       │   └─iterator  ««"nqp::iterator($hash.list)"
    ║ │       │       │     └─callmethod list  ««".list"
    ║ │       │       │       └○ lexical $hash
    ║ │       │       └─:Stmts
    ║ │       │         └─while  ««"$it && !$found {\n            my $k := nqp::shift($"...
    ║ │       │           ├─if &infix:<&&>  ««"&&"
    ║ │       │           │ ├○ lexical $it
    ║ │       │           │ └─falsey &prefix:<!>  ««"!"
    ║ │       │           │   └○ lexical $found
    ║ │       │           ├─:Block :blocktype(immediate)  ««"{\n            my $k := nqp::shift($it);\n         "...
    ║ │       │           │ ╟─:Stmts
    ║ │       │           │ ║ └○ lexical $k :decl(var)
    ║ │       │           │ ╙─:Stmts  ««"\n            my $k := nqp::shift($it);\n          "...
    ║ │       │           │   ├─:Stmts
    ║ │       │           │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$k := nqp::shift($it)"
    ║ │       │           │   │   ├○ lexical $k
    ║ │       │           │   │   └─shift  ««"nqp::shift($it)"
    ║ │       │           │   │     └○ lexical $it
    ║ │       │           │   └─:Stmts
    ║ │       │           │     └─if  ««"$it && $keyPredicate($k) {\n                my $v :"...
    ║ │       │           │       ├─if &infix:<&&>  ««"&&"
    ║ │       │           │       │ ├○ lexical $it
    ║ │       │           │       │ └─call  ««"$k"
    ║ │       │           │       │   ├○ lexical $keyPredicate
    ║ │       │           │       │   └○ lexical $k
    ║ │       │           │       └─:Block :blocktype(immediate)  ««"{\n                my $v := nqp::shift($it);\n     "...
    ║ │       │           │         ╟─:Stmts
    ║ │       │           │         ║ └○ lexical $v :decl(var)
    ║ │       │           │         ╙─:Stmts  ««"\n                my $v := nqp::shift($it);\n      "...
    ║ │       │           │           ├─:Stmts
    ║ │       │           │           │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$v := nqp::shift($it)"
    ║ │       │           │           │   ├○ lexical $v
    ║ │       │           │           │   └─shift  ««"nqp::shift($it)"
    ║ │       │           │           │     └○ lexical $it
    ║ │       │           │           └─:Stmts
    ║ │       │           │             └─if  ««"$valuePredicate($v) {\n                    $found :"...
    ║ │       │           │               ├─call  ««"$v"
    ║ │       │           │               │ ├○ lexical $valuePredicate
    ║ │       │           │               │ └○ lexical $v
    ║ │       │           │               └─:Stmts  ««"{\n                    $found := $v;\n             "...
    ║ │       │           │                 ├─:Stmts
    ║ │       │           │                 └─:Stmts  ««"\n                    $found := $v;\n                "
    ║ │       │           │                   └─:Stmts
    ║ │       │           │                     └─bind &infix:<:=>  ««":="
    ║ │       │           │                       ├○ lexical $found
    ║ │       │           │                       └○ lexical $v
    ║ │       │           └◙ IVal 1 :named("nohandler")
    ║ │       └─:Stmts
    ║ │         └○ lexical $found
    ║ ├─bind
    ║ │ ├○ lexical &cloneAndSubst :decl(var)
    ║ │ └─:Block  ««"{\n    nqp::die('cloneAndSubst expects a QAST::Node"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $node :decl(param)
    ║ │   ║ ├○ lexical $substitution :decl(param)
    ║ │   ║ ├○ lexical @children :decl(var)
    ║ │   ║ └○ lexical $i :decl(var)
    ║ │   ╙─:Stmts  ««"\n    nqp::die('cloneAndSubst expects a QAST::Node "...
    ║ │     ├─:Stmts
    ║ │     │ └─unless  ««"nqp::die('cloneAndSubst expects a QAST::Node as 1st"...
    ║ │     │   ├─call &istype  ««"$node, QAST::Node"
    ║ │     │   │ ├○ lexical $node
    ║ │     │   │ └◙ WVal QAST::Node
    ║ │     │   └─die  ««"nqp::die('cloneAndSubst expects a QAST::Node as 1st"...
    ║ │     │     └─concat &infix:<~>  ««"~"
    ║ │     │       ├◙ SVal "cloneAndSubst expects a QAST::Node as 1st arg - got "
    ║ │     │       └─call &describe  ««"$node"
    ║ │     │         └○ lexical $node
    ║ │     ├─:Stmts
    ║ │     │ └─unless  ««"nqp::die('cloneAndSubst expects a function as 2nd a"...
    ║ │     │   ├─isinvokable  ««"nqp::isinvokable($substitution)"
    ║ │     │   │ └○ lexical $substitution
    ║ │     │   └─die  ««"nqp::die('cloneAndSubst expects a function as 2nd a"...
    ║ │     │     └─concat &infix:<~>  ««"~"
    ║ │     │       ├◙ SVal "cloneAndSubst expects a function as 2nd arg - got "
    ║ │     │       └─call &describe  ««"$substitution"
    ║ │     │         └○ lexical $substitution
    ║ │     ├─:Stmts
    ║ │     │ └─bind &infix:<:=>  ««":="
    ║ │     │   ├○ lexical $node
    ║ │     │   └─callmethod shallow_clone  ««".shallow_clone"
    ║ │     │     └○ lexical $node
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@children := $node.list"
    ║ │     │   ├○ lexical @children
    ║ │     │   └─callmethod list  ««".list"
    ║ │     │     └○ lexical $node
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$i := 0"
    ║ │     │   ├○ lexical $i
    ║ │     │   └◙ IVal 0
    ║ │     ├─:Stmts
    ║ │     │ └─for  ««"@children {\n        my $child := cloneAndSubst($_,"...
    ║ │     │   ├○ lexical @children
    ║ │     │   ├─:Block :blocktype(immediate)  ««"{\n        my $child := cloneAndSubst($_, $substitu"...
    ║ │     │   │ ╟─:Stmts
    ║ │     │   │ ║ ├○ lexical $child :decl(var)
    ║ │     │   │ ║ └○ lexical $_ :decl(param)
    ║ │     │   │ ╙─:Stmts  ««"\n        my $child := cloneAndSubst($_, $substitut"...
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$child := cloneAndSubst($_, $substitution)"
    ║ │     │   │   │   ├○ lexical $child
    ║ │     │   │   │   └─call &cloneAndSubst  ««"$_, $substitution"
    ║ │     │   │   │     ├○ lexical $_
    ║ │     │   │   │     └○ lexical $substitution
    ║ │     │   │   └─:Stmts
    ║ │     │   │     └─unless  ««"nqp::isnull($child) {\n            @children[$i] :="...
    ║ │     │   │       ├─isnull  ««"nqp::isnull($child)"
    ║ │     │   │       │ └○ lexical $child
    ║ │     │   │       └─:Stmts  ««"{\n            @children[$i] := $child;\n          "...
    ║ │     │   │         ├─:Stmts
    ║ │     │   │         └─:Stmts  ««"\n            @children[$i] := $child;\n           "...
    ║ │     │   │           ├─:Stmts
    ║ │     │   │           │ └─bind &infix:<:=>  ««":="
    ║ │     │   │           │   ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │   │           │   │ ├○ lexical @children
    ║ │     │   │           │   │ └○ lexical $i
    ║ │     │   │           │   └○ lexical $child
    ║ │     │   │           └─:Stmts
    ║ │     │   │             └─postinc &postfix:<++>  ««"++"
    ║ │     │   │               └○ lexical $i
    ║ │     │   └◙ IVal 1 :named("nohandler")
    ║ │     ├─:Stmts
    ║ │     │ └─setelems  ««"nqp::setelems(@children, $i)"
    ║ │     │   ├○ lexical @children
    ║ │     │   └○ lexical $i
    ║ │     └─:Stmts
    ║ │       └─call  ««"$node"
    ║ │         ├○ lexical $substitution
    ║ │         └○ lexical $node
    ║ ├─bind
    ║ │ ├○ lexical &collect_params_and_body :decl(var)
    ║ │ └─:Block  ««"{\n    my $arity  := %results<arity>;\n    my %para"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $node :decl(param)
    ║ │   ║ ├○ lexical %results :decl(param) :default((call &hash) (IVal 0 :named("arity")) (hash :named("params")) (list &circumfix:<[ ]> :named("stmts")))
    ║ │   ║ ├○ lexical $arity :decl(var)
    ║ │   ║ ├○ lexical %params :decl(var)
    ║ │   ║ └○ lexical @stmts :decl(var)
    ║ │   ╙─:Stmts  ««"\n    my $arity  := %results<arity>;\n    my %param"...
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$arity  := %results<arity>"
    ║ │     │   ├○ lexical $arity
    ║ │     │   └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     ├○ lexical %results
    ║ │     │     └◙ SVal "arity"
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"%params := %results<params>"
    ║ │     │   ├○ lexical %params
    ║ │     │   └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     ├○ lexical %results
    ║ │     │     └◙ SVal "params"
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@stmts  := %results<stmts>"
    ║ │     │   ├○ lexical @stmts
    ║ │     │   └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     ├○ lexical %results
    ║ │     │     └◙ SVal "stmts"
    ║ │     ├─:Stmts
    ║ │     │ └─for  ««"$node.list {\n        if istype($_, QAST::Var) {\n "...
    ║ │     │   ├─callmethod list  ««".list"
    ║ │     │   │ └○ lexical $node
    ║ │     │   ├─:Block :blocktype(immediate)  ««"{\n        if istype($_, QAST::Var) {\n            "...
    ║ │     │   │ ╟─:Stmts
    ║ │     │   │ ║ └○ lexical $_ :decl(param)
    ║ │     │   │ ╙─:Stmts  ««"\n        if istype($_, QAST::Var) {\n            m"...
    ║ │     │   │   └─:Stmts
    ║ │     │   │     └─if  ««"istype($_, QAST::Var) {\n            my $varName :="...
    ║ │     │   │       ├─call &istype  ««"$_, QAST::Var"
    ║ │     │   │       │ ├○ lexical $_
    ║ │     │   │       │ └◙ WVal QAST::Var
    ║ │     │   │       ├─:Block :blocktype(immediate)  ««"{\n            my $varName := $_.name;\n           "...
    ║ │     │   │       │ ╟─:Stmts
    ║ │     │   │       │ ║ └○ lexical $varName :decl(var)
    ║ │     │   │       │ ╙─:Stmts  ««"\n            my $varName := $_.name;\n            "...
    ║ │     │   │       │   ├─:Stmts
    ║ │     │   │       │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$varName := $_.name"
    ║ │     │   │       │   │   ├○ lexical $varName
    ║ │     │   │       │   │   └─callmethod name  ««".name"
    ║ │     │   │       │   │     └○ lexical $_
    ║ │     │   │       │   └─:Stmts
    ║ │     │   │       │     └─if  ««"$_.decl {\n                if $_.decl eq 'param' {\"...
    ║ │     │   │       │       ├─callmethod decl  ««".decl"
    ║ │     │   │       │       │ └○ lexical $_
    ║ │     │   │       │       ├─:Stmts  ««"{\n                if $_.decl eq 'param' {\n       "...
    ║ │     │   │       │       │ ├─:Stmts
    ║ │     │   │       │       │ └─:Stmts  ««"\n                if $_.decl eq 'param' {\n        "...
    ║ │     │   │       │       │   └─:Stmts
    ║ │     │   │       │       │     └─if  ««"$_.decl eq 'param' {\n                    nqp::die("...
    ║ │     │   │       │       │       ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   │       │       │       │ ├─callmethod decl  ««".decl"
    ║ │     │   │       │       │       │ │ └○ lexical $_
    ║ │     │   │       │       │       │ └◙ SVal "param"
    ║ │     │   │       │       │       ├─:Stmts  ««"{\n                    nqp::die(\"cannot handle :na"...
    ║ │     │   │       │       │       │ ├─:Stmts
    ║ │     │   │       │       │       │ └─:Stmts  ««"\n                    nqp::die(\"cannot handle :nam"...
    ║ │     │   │       │       │       │   ├─:Stmts
    ║ │     │   │       │       │       │   │ └─if  ««"nqp::die(\"cannot handle :named parameter $varName:"...
    ║ │     │   │       │       │       │   │   ├─callmethod named  ««".named"
    ║ │     │   │       │       │       │   │   │ └○ lexical $_
    ║ │     │   │       │       │       │   │   └─die  ««"nqp::die(\"cannot handle :named parameter $varName:"...
    ║ │     │   │       │       │       │   │     └─concat &infix:<~>  ««"~"
    ║ │     │   │       │       │       │   │       ├─concat
    ║ │     │   │       │       │       │   │       │ ├─concat
    ║ │     │   │       │       │       │   │       │ │ ├◙ SVal "cannot handle :named parameter "
    ║ │     │   │       │       │       │   │       │ │ └○ lexical $varName
    ║ │     │   │       │       │       │   │       │ └◙ SVal ": "
    ║ │     │   │       │       │       │   │       └─call &dump  ««"$_"
    ║ │     │   │       │       │       │   │         └○ lexical $_
    ║ │     │   │       │       │       │   ├─:Stmts
    ║ │     │   │       │       │       │   │ └─if  ««"nqp::die(\"cannot handle :slurpy parameter $varName"...
    ║ │     │   │       │       │       │   │   ├─callmethod slurpy  ««".slurpy"
    ║ │     │   │       │       │       │   │   │ └○ lexical $_
    ║ │     │   │       │       │       │   │   └─die  ««"nqp::die(\"cannot handle :slurpy parameter $varName"...
    ║ │     │   │       │       │       │   │     └─concat &infix:<~>  ««"~"
    ║ │     │   │       │       │       │   │       ├─concat
    ║ │     │   │       │       │       │   │       │ ├─concat
    ║ │     │   │       │       │       │   │       │ │ ├◙ SVal "cannot handle :slurpy parameter "
    ║ │     │   │       │       │       │   │       │ │ └○ lexical $varName
    ║ │     │   │       │       │       │   │       │ └◙ SVal ": "
    ║ │     │   │       │       │       │   │       └─call &dump  ««"$_"
    ║ │     │   │       │       │       │   │         └○ lexical $_
    ║ │     │   │       │       │       │   ├─:Stmts
    ║ │     │   │       │       │       │   │ └─bind &infix:<:=>  ««":="
    ║ │     │   │       │       │       │   │   ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   │       │       │       │   │   │ ├○ lexical %params
    ║ │     │   │       │       │       │   │   │ └○ lexical $varName
    ║ │     │   │       │       │       │   │   └○ lexical $arity
    ║ │     │   │       │       │       │   └─:Stmts
    ║ │     │   │       │       │       │     └─postinc &postfix:<++>  ««"++"
    ║ │     │   │       │       │       │       └○ lexical $arity
    ║ │     │   │       │       │       └─:Stmts  ««"{\n                    nqp::die('cannot handle :dec"...
    ║ │     │   │       │       │         ├─:Stmts
    ║ │     │   │       │       │         └─:Stmts  ««"\n                    nqp::die('cannot handle :decl"...
    ║ │     │   │       │       │           └─:Stmts
    ║ │     │   │       │       │             └─die  ««"nqp::die('cannot handle :decl(' ~ $_.decl ~ ')')"
    ║ │     │   │       │       │               └─concat &infix:<~>  ««"~"
    ║ │     │   │       │       │                 ├─concat &infix:<~>  ««"~"
    ║ │     │   │       │       │                 │ ├◙ SVal "cannot handle :decl("
    ║ │     │   │       │       │                 │ └─callmethod decl  ««".decl"
    ║ │     │   │       │       │                 │   └○ lexical $_
    ║ │     │   │       │       │                 └◙ SVal ")"
    ║ │     │   │       │       └─:Stmts  ««"{\n                @stmts.push($_);\n            }"
    ║ │     │   │       │         ├─:Stmts
    ║ │     │   │       │         └─:Stmts  ««"\n                @stmts.push($_);\n            "
    ║ │     │   │       │           └─:Stmts
    ║ │     │   │       │             └─callmethod push  ««"$_"
    ║ │     │   │       │               ├○ lexical @stmts
    ║ │     │   │       │               └○ lexical $_
    ║ │     │   │       └─:Stmts  ««"{\n            @stmts.push($_);\n        }"
    ║ │     │   │         ├─:Stmts
    ║ │     │   │         └─:Stmts  ««"\n            @stmts.push($_);\n        "
    ║ │     │   │           └─:Stmts
    ║ │     │   │             └─callmethod push  ««"$_"
    ║ │     │   │               ├○ lexical @stmts
    ║ │     │   │               └○ lexical $_
    ║ │     │   └◙ IVal 1 :named("nohandler")
    ║ │     ├─:Stmts
    ║ │     │ └─bind &infix:<:=>  ««":="
    ║ │     │   ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   │ ├○ lexical %results
    ║ │     │   │ └◙ SVal "arity"
    ║ │     │   └○ lexical $arity
    ║ │     └─:Stmts
    ║ │       └○ lexical %results
    ║ ├─bind
    ║ │ ├○ lexical &inline_simple_subs :decl(var)
    ║ │ └─:Block  ««"{\n    nqp::die('inline_simple_subs expects a QAST:"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $node :decl(param)
    ║ │   ║ ├○ lexical @inlineDefs :decl(param)
    ║ │   ║ ├○ lexical %inlineables :decl(param) :default(hash)
    ║ │   ║ ├○ lexical $i :decl(var)
    ║ │   ║ └○ lexical @children :decl(var)
    ║ │   ╙─lexotic RETURN
    ║ │     └─:Stmts  ««"\n    nqp::die('inline_simple_subs expects a QAST::"...
    ║ │       ├─:Stmts
    ║ │       │ └─unless  ««"nqp::die('inline_simple_subs expects a QAST::Node a"...
    ║ │       │   ├─call &istype  ««"$node, QAST::Node"
    ║ │       │   │ ├○ lexical $node
    ║ │       │   │ └◙ WVal QAST::Node
    ║ │       │   └─die  ««"nqp::die('inline_simple_subs expects a QAST::Node a"...
    ║ │       │     └─concat &infix:<~>  ««"~"
    ║ │       │       ├◙ SVal "inline_simple_subs expects a QAST::Node as 1st arg - got "
    ║ │       │       └─call &describe  ««"$node"
    ║ │       │         └○ lexical $node
    ║ │       ├─:Stmts
    ║ │       │ └─if  ««"nqp::elems(@inlineDefs) > 0 {\n        for @inlineD"...
    ║ │       │   ├─isgt_n &infix:<>>  ««">"
    ║ │       │   │ ├─elems  ««"nqp::elems(@inlineDefs)"
    ║ │       │   │ │ └○ lexical @inlineDefs
    ║ │       │   │ └◙ IVal 0
    ║ │       │   └─:Stmts  ««"{\n        for @inlineDefs {\n            next if n"...
    ║ │       │     ├─:Stmts
    ║ │       │     └─:Stmts  ««"\n        for @inlineDefs {\n            next if nq"...
    ║ │       │       ├─:Stmts
    ║ │       │       │ └─for  ««"@inlineDefs {\n            next if nqp::isnull($_);"...
    ║ │       │       │   ├○ lexical @inlineDefs
    ║ │       │       │   └─:Block :blocktype(immediate)  ««"{\n            next if nqp::isnull($_);\n          "...
    ║ │       │       │     ╟─:Stmts
    ║ │       │       │     ║ ├○ lexical $name :decl(var)
    ║ │       │       │     ║ ├○ lexical $block :decl(var)
    ║ │       │       │     ║ ├─bind  ««"%results"
    ║ │       │       │     ║ │ ├○ lexical %results :decl(var)
    ║ │       │       │     ║ │ └─hash
    ║ │       │       │     ║ ├○ lexical $arity :decl(var)
    ║ │       │       │     ║ ├○ lexical %params :decl(var)
    ║ │       │       │     ║ ├○ lexical @stmts :decl(var)
    ║ │       │       │     ║ └○ lexical $_ :decl(param)
    ║ │       │       │     ╙─:Stmts  ««"\n            next if nqp::isnull($_);\n           "...
    ║ │       │       │       ├─:Stmts
    ║ │       │       │       │ └─if  ««"next if nqp::isnull($_)"
    ║ │       │       │       │   ├─isnull  ««"nqp::isnull($_)"
    ║ │       │       │       │   │ └○ lexical $_
    ║ │       │       │       │   └─control next
    ║ │       │       │       ├─:Stmts
    ║ │       │       │       │ └─unless  ««"nqp::die(\"invalid def of inlineable sub: \" ~ desc"...
    ║ │       │       │       │   ├─call &istype  ««"$_, QAST::Node"
    ║ │       │       │       │   │ ├○ lexical $_
    ║ │       │       │       │   │ └◙ WVal QAST::Node
    ║ │       │       │       │   └─die  ««"nqp::die(\"invalid def of inlineable sub: \" ~ desc"...
    ║ │       │       │       │     └─concat &infix:<~>  ««"~"
    ║ │       │       │       │       ├◙ SVal "invalid def of inlineable sub: "
    ║ │       │       │       │       └─call &describe  ««"$_"
    ║ │       │       │       │         └○ lexical $_
    ║ │       │       │       ├─:Stmts
    ║ │       │       │       │ └─unless  ««"nqp::die(\"invalid def of inlineable sub: \" ~ dump"...
    ║ │       │       │       │   ├─if &infix:<&&>  ««"&&"
    ║ │       │       │       │   │ ├─if &infix:<&&>  ««"&&"
    ║ │       │       │       │   │ │ ├─if &infix:<&&>  ««"&&"
    ║ │       │       │       │   │ │ │ ├─call &istype  ««"$_, QAST::Op"
    ║ │       │       │       │   │ │ │ │ ├○ lexical $_
    ║ │       │       │       │   │ │ │ │ └◙ WVal QAST::Op
    ║ │       │       │       │   │ │ │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │       │       │       │   │ │ │   ├─callmethod op  ««".op"
    ║ │       │       │       │   │ │ │   │ └○ lexical $_
    ║ │       │       │       │   │ │ │   └◙ SVal "bind"
    ║ │       │       │       │   │ │ └─call &istype  ««"$_[0], QAST::Var"
    ║ │       │       │       │   │ │   ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │       │       │       │   │ │   │ ├○ lexical $_
    ║ │       │       │       │   │ │   │ └◙ IVal 0
    ║ │       │       │       │   │ │   └◙ WVal QAST::Var
    ║ │       │       │       │   │ └─call &istype  ««"$_[1], QAST::Block"
    ║ │       │       │       │   │   ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │       │       │       │   │   │ ├○ lexical $_
    ║ │       │       │       │   │   │ └◙ IVal 1
    ║ │       │       │       │   │   └◙ WVal QAST::Block
    ║ │       │       │       │   └─die  ««"nqp::die(\"invalid def of inlineable sub: \" ~ dump"...
    ║ │       │       │       │     └─concat &infix:<~>  ««"~"
    ║ │       │       │       │       ├◙ SVal "invalid def of inlineable sub: "
    ║ │       │       │       │       └─call &dump  ««"$_"
    ║ │       │       │       │         └○ lexical $_
    ║ │       │       │       ├─:Stmts
    ║ │       │       │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$name   := $_[0].name"
    ║ │       │       │       │   ├○ lexical $name
    ║ │       │       │       │   └─callmethod name  ««".name"
    ║ │       │       │       │     └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │       │       │       │       ├○ lexical $_
    ║ │       │       │       │       └◙ IVal 0
    ║ │       │       │       ├─:Stmts
    ║ │       │       │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$block  := $_[1]"
    ║ │       │       │       │   ├○ lexical $block
    ║ │       │       │       │   └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │       │       │       │     ├○ lexical $_
    ║ │       │       │       │     └◙ IVal 1
    ║ │       │       │       ├─:Stmts
    ║ │       │       │       │ └○ lexical %results
    ║ │       │       │       ├─:Stmts
    ║ │       │       │       │ └─if  ««"istype($block[0], QAST::Stmt, QAST::Stmts) {\n     "...
    ║ │       │       │       │   ├─call &istype  ««"$block[0], QAST::Stmt, QAST::Stmts"
    ║ │       │       │       │   │ ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │       │       │       │   │ │ ├○ lexical $block
    ║ │       │       │       │   │ │ └◙ IVal 0
    ║ │       │       │       │   │ ├◙ WVal QAST::Stmt
    ║ │       │       │       │   │ └◙ WVal QAST::Stmts
    ║ │       │       │       │   ├─:Block :blocktype(immediate)  ««"{\n                my $it := nqp::iterator($block.l"...
    ║ │       │       │       │   │ ╟─:Stmts
    ║ │       │       │       │   │ ║ └○ lexical $it :decl(var)
    ║ │       │       │       │   │ ╙─:Stmts  ««"\n                my $it := nqp::iterator($block.li"...
    ║ │       │       │       │   │   ├─:Stmts
    ║ │       │       │       │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$it := nqp::iterator($block.list)"
    ║ │       │       │       │   │   │   ├○ lexical $it
    ║ │       │       │       │   │   │   └─iterator  ««"nqp::iterator($block.list)"
    ║ │       │       │       │   │   │     └─callmethod list  ««".list"
    ║ │       │       │       │   │   │       └○ lexical $block
    ║ │       │       │       │   │   ├─:Stmts
    ║ │       │       │       │   │   │ └─bind &infix:<:=>  ««":="
    ║ │       │       │       │   │   │   ├○ lexical %results
    ║ │       │       │       │   │   │   └─call &collect_params_and_body  ««"nqp::shift($it)"
    ║ │       │       │       │   │   │     └─shift  ««"nqp::shift($it)"
    ║ │       │       │       │   │   │       └○ lexical $it
    ║ │       │       │       │   │   └─:Stmts
    ║ │       │       │       │   │     └─while  ««"$it {\n                    %results := collect_para"...
    ║ │       │       │       │   │       ├○ lexical $it
    ║ │       │       │       │   │       ├─:Stmts  ««"{\n                    %results := collect_params_a"...
    ║ │       │       │       │   │       │ ├─:Stmts
    ║ │       │       │       │   │       │ └─:Stmts  ««"\n                    %results := collect_params_an"...
    ║ │       │       │       │   │       │   └─:Stmts
    ║ │       │       │       │   │       │     └─bind &infix:<:=>  ««":="
    ║ │       │       │       │   │       │       ├○ lexical %results
    ║ │       │       │       │   │       │       └─call &collect_params_and_body  ««"nqp::shift($it), %results"
    ║ │       │       │       │   │       │         ├─shift  ««"nqp::shift($it)"
    ║ │       │       │       │   │       │         │ └○ lexical $it
    ║ │       │       │       │   │       │         └○ lexical %results
    ║ │       │       │       │   │       └◙ IVal 1 :named("nohandler")
    ║ │       │       │       │   └─:Stmts  ««"{\n                %results := collect_params_and_b"...
    ║ │       │       │       │     ├─:Stmts
    ║ │       │       │       │     └─:Stmts  ««"\n                %results := collect_params_and_bo"...
    ║ │       │       │       │       └─:Stmts
    ║ │       │       │       │         └─bind &infix:<:=>  ««":="
    ║ │       │       │       │           ├○ lexical %results
    ║ │       │       │       │           └─call &collect_params_and_body  ««"$block"
    ║ │       │       │       │             └○ lexical $block
    ║ │       │       │       ├─:Stmts
    ║ │       │       │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$arity  := %results<arity>"
    ║ │       │       │       │   ├○ lexical $arity
    ║ │       │       │       │   └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │       │       │       │     ├○ lexical %results
    ║ │       │       │       │     └◙ SVal "arity"
    ║ │       │       │       ├─:Stmts
    ║ │       │       │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"%params := %results<params>"
    ║ │       │       │       │   ├○ lexical %params
    ║ │       │       │       │   └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │       │       │       │     ├○ lexical %results
    ║ │       │       │       │     └◙ SVal "params"
    ║ │       │       │       ├─:Stmts
    ║ │       │       │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@stmts  := %results<stmts>"
    ║ │       │       │       │   ├○ lexical @stmts
    ║ │       │       │       │   └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │       │       │       │     ├○ lexical %results
    ║ │       │       │       │     └◙ SVal "stmts"
    ║ │       │       │       ├─:Stmts
    ║ │       │       │       │ └─if  ««"nqp::elems(@stmts) == 0 {\n                nqp::die"...
    ║ │       │       │       │   ├─iseq_n &infix:<==>  ««"=="
    ║ │       │       │       │   │ ├─elems  ««"nqp::elems(@stmts)"
    ║ │       │       │       │   │ │ └○ lexical @stmts
    ║ │       │       │       │   │ └◙ IVal 0
    ║ │       │       │       │   ├─:Stmts  ««"{\n                nqp::die(\"no statements found i"...
    ║ │       │       │       │   │ ├─:Stmts
    ║ │       │       │       │   │ └─:Stmts  ««"\n                nqp::die(\"no statements found in"...
    ║ │       │       │       │   │   └─:Stmts
    ║ │       │       │       │   │     └─die  ««"nqp::die(\"no statements found in inlineable $name:"...
    ║ │       │       │       │   │       └─concat &infix:<~>  ««"~"
    ║ │       │       │       │   │         ├─concat
    ║ │       │       │       │   │         │ ├─concat
    ║ │       │       │       │   │         │ │ ├◙ SVal "no statements found in inlineable "
    ║ │       │       │       │   │         │ │ └○ lexical $name
    ║ │       │       │       │   │         │ └◙ SVal ": "
    ║ │       │       │       │   │         └─call &dump  ««"$block"
    ║ │       │       │       │   │           └○ lexical $block
    ║ │       │       │       │   └─if  ««"nqp::elems(@stmts) == 1 {\n                $block :"...
    ║ │       │       │       │     ├─iseq_n &infix:<==>  ««"=="
    ║ │       │       │       │     │ ├─elems  ««"nqp::elems(@stmts)"
    ║ │       │       │       │     │ │ └○ lexical @stmts
    ║ │       │       │       │     │ └◙ IVal 1
    ║ │       │       │       │     ├─:Stmts  ««"{\n                $block := @stmts[0];\n            }"
    ║ │       │       │       │     │ ├─:Stmts
    ║ │       │       │       │     │ └─:Stmts  ««"\n                $block := @stmts[0];\n            "
    ║ │       │       │       │     │   └─:Stmts
    ║ │       │       │       │     │     └─bind &infix:<:=>  ««":="
    ║ │       │       │       │     │       ├○ lexical $block
    ║ │       │       │       │     │       └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │       │       │       │     │         ├○ lexical @stmts
    ║ │       │       │       │     │         └◙ IVal 0
    ║ │       │       │       │     └─:Stmts  ««"{\n                $block := QAST::Stmts.new(|@stmt"...
    ║ │       │       │       │       ├─:Stmts
    ║ │       │       │       │       └─:Stmts  ««"\n                $block := QAST::Stmts.new(|@stmts"...
    ║ │       │       │       │         └─:Stmts
    ║ │       │       │       │           └─bind &infix:<:=>  ««":="
    ║ │       │       │       │             ├○ lexical $block
    ║ │       │       │       │             └─callmethod new  ««"|@stmts"
    ║ │       │       │       │               ├◙ WVal QAST::Stmts
    ║ │       │       │       │               └○ lexical @stmts :flat(1)
    ║ │       │       │       └─:Stmts
    ║ │       │       │         └─bind &infix:<:=>  ««":="
    ║ │       │       │           ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │       │       │           │ ├○ lexical %inlineables
    ║ │       │       │           │ └○ lexical $name
    ║ │       │       │           └─takeclosure
    ║ │       │       │             └─:Block  ««"{\n                my $argCount := nqp::elems(@argu"...
    ║ │       │       │               ╟─:Stmts
    ║ │       │       │               ║ ├○ lexical @arguments :decl(param)
    ║ │       │       │               ║ ├○ lexical $argCount :decl(var)
    ║ │       │       │               ║ └○ lexical $out :decl(var)
    ║ │       │       │               ╙─:Stmts  ««"\n                my $argCount := nqp::elems(@argum"...
    ║ │       │       │                 ├─:Stmts
    ║ │       │       │                 │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$argCount := nqp::elems(@arguments)"
    ║ │       │       │                 │   ├○ lexical $argCount
    ║ │       │       │                 │   └─elems  ««"nqp::elems(@arguments)"
    ║ │       │       │                 │     └○ lexical @arguments
    ║ │       │       │                 ├─:Stmts
    ║ │       │       │                 │ └─unless  ««"nqp::die(\"cannot inline call with $argCount args t"...
    ║ │       │       │                 │   ├─iseq_n &infix:<==>  ««"=="
    ║ │       │       │                 │   │ ├○ lexical $argCount
    ║ │       │       │                 │   │ └○ lexical $arity
    ║ │       │       │                 │   └─die  ««"nqp::die(\"cannot inline call with $argCount args t"...
    ║ │       │       │                 │     └─concat &infix:<~>  ««"~"
    ║ │       │       │                 │       ├─concat
    ║ │       │       │                 │       │ ├─concat
    ║ │       │       │                 │       │ │ ├─concat
    ║ │       │       │                 │       │ │ │ ├◙ SVal "cannot inline call with "
    ║ │       │       │                 │       │ │ │ └○ lexical $argCount
    ║ │       │       │                 │       │ │ └◙ SVal " args to "
    ║ │       │       │                 │       │ └○ lexical $arity
    ║ │       │       │                 │       └─concat
    ║ │       │       │                 │         ├◙ SVal "-arity fn "
    ║ │       │       │                 │         └○ lexical $name
    ║ │       │       │                 ├─:Stmts
    ║ │       │       │                 │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$out := cloneAndSubst($block, -> $n {\n#           "...
    ║ │       │       │                 │   ├○ lexical $out
    ║ │       │       │                 │   └─call &cloneAndSubst  ««"$block, -> $n {\n#                    say('####', d"...
    ║ │       │       │                 │     ├○ lexical $block
    ║ │       │       │                 │     └─takeclosure
    ║ │       │       │                 │       └─:Block  ««"{\n#                    say('####', dump($n));\n   "...
    ║ │       │       │                 │         ╟─:Stmts
    ║ │       │       │                 │         ║ └○ lexical $n :decl(param)
    ║ │       │       │                 │         ╙─:Stmts  ««"\n#                    say('####', dump($n));\n    "...
    ║ │       │       │                 │           └─:Stmts
    ║ │       │       │                 │             └─if  ««"istype($n, QAST::Var) && nqp::existskey(%params, $n"...
    ║ │       │       │                 │               ├─if &infix:<&&>  ««"&&"
    ║ │       │       │                 │               │ ├─call &istype  ««"$n, QAST::Var"
    ║ │       │       │                 │               │ │ ├○ lexical $n
    ║ │       │       │                 │               │ │ └◙ WVal QAST::Var
    ║ │       │       │                 │               │ └─existskey  ««"nqp::existskey(%params, $n.name)"
    ║ │       │       │                 │               │   ├○ lexical %params
    ║ │       │       │                 │               │   └─callmethod name  ««".name"
    ║ │       │       │                 │               │     └○ lexical $n
    ║ │       │       │                 │               ├─:Block :blocktype(immediate)  ««"{\n                        my $out := @arguments[%p"...
    ║ │       │       │                 │               │ ╟─:Stmts
    ║ │       │       │                 │               │ ║ └○ lexical $out :decl(var)
    ║ │       │       │                 │               │ ╙─:Stmts  ««"\n                        my $out := @arguments[%pa"...
    ║ │       │       │                 │               │   ├─:Stmts
    ║ │       │       │                 │               │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$out := @arguments[%params{$n.name}]"
    ║ │       │       │                 │               │   │   ├○ lexical $out
    ║ │       │       │                 │               │   │   └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │       │       │                 │               │   │     ├○ lexical @arguments
    ║ │       │       │                 │               │   │     └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │       │       │                 │               │   │       ├○ lexical %params
    ║ │       │       │                 │               │   │       └─callmethod name  ««".name"
    ║ │       │       │                 │               │   │         └○ lexical $n
    ║ │       │       │                 │               │   └─:Stmts
    ║ │       │       │                 │               │     └○ lexical $out
    ║ │       │       │                 │               └─:Stmts  ««"{\n                        $n;\n                    }"
    ║ │       │       │                 │                 ├─:Stmts
    ║ │       │       │                 │                 └─:Stmts  ««"\n                        $n;\n                    "
    ║ │       │       │                 │                   └─:Stmts
    ║ │       │       │                 │                     └○ lexical $n
    ║ │       │       │                 └─:Stmts
    ║ │       │       │                   └○ lexical $out
    ║ │       │       └─:Stmts
    ║ │       │         └─call RETURN
    ║ │       │           └─call &inline_simple_subs  ««"$node, [], %inlineables"
    ║ │       │             ├○ lexical $node
    ║ │       │             ├─list &circumfix:<[ ]>
    ║ │       │             └○ lexical %inlineables
    ║ │       ├─:Stmts
    ║ │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$i := 0"
    ║ │       │   ├○ lexical $i
    ║ │       │   └◙ IVal 0
    ║ │       ├─:Stmts
    ║ │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@children := $node.list"
    ║ │       │   ├○ lexical @children
    ║ │       │   └─callmethod list  ««".list"
    ║ │       │     └○ lexical $node
    ║ │       ├─:Stmts
    ║ │       │ └─for  ««"@children {\n        @children[$i] := inline_simple"...
    ║ │       │   ├○ lexical @children
    ║ │       │   ├─:Block :blocktype(immediate)  ««"{\n        @children[$i] := inline_simple_subs($_, "...
    ║ │       │   │ ╟─:Stmts
    ║ │       │   │ ║ └○ lexical $_ :decl(param)
    ║ │       │   │ ╙─:Stmts  ««"\n        @children[$i] := inline_simple_subs($_, ["...
    ║ │       │   │   ├─:Stmts
    ║ │       │   │   │ └─bind &infix:<:=>  ««":="
    ║ │       │   │   │   ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │       │   │   │   │ ├○ lexical @children
    ║ │       │   │   │   │ └○ lexical $i
    ║ │       │   │   │   └─call &inline_simple_subs  ««"$_, [], %inlineables"
    ║ │       │   │   │     ├○ lexical $_
    ║ │       │   │   │     ├─list &circumfix:<[ ]>
    ║ │       │   │   │     └○ lexical %inlineables
    ║ │       │   │   └─:Stmts
    ║ │       │   │     └─postinc &postfix:<++>  ««"++"
    ║ │       │   │       └○ lexical $i
    ║ │       │   └◙ IVal 1 :named("nohandler")
    ║ │       ├─:Stmts
    ║ │       │ └─if  ««"istype($node, QAST::Op) && ($node.op eq 'call' || $"...
    ║ │       │   ├─if &infix:<&&>  ««"&&"
    ║ │       │   │ ├─call &istype  ««"$node, QAST::Op"
    ║ │       │   │ │ ├○ lexical $node
    ║ │       │   │ │ └◙ WVal QAST::Op
    ║ │       │   │ └─unless &infix:<||>  ««"||"
    ║ │       │   │   ├─iseq_s &infix:<eq>  ««"eq"
    ║ │       │   │   │ ├─callmethod op  ««".op"
    ║ │       │   │   │ │ └○ lexical $node
    ║ │       │   │   │ └◙ SVal "call"
    ║ │       │   │   └─iseq_s &infix:<eq>  ««"eq"
    ║ │       │   │     ├─callmethod op  ««".op"
    ║ │       │   │     │ └○ lexical $node
    ║ │       │   │     └◙ SVal "callstatic"
    ║ │       │   └─:Block :blocktype(immediate)  ««"{\n        my $codeMaker := %inlineables{$node.name"...
    ║ │       │     ╟─:Stmts
    ║ │       │     ║ └○ lexical $codeMaker :decl(var)
    ║ │       │     ╙─:Stmts  ««"\n        my $codeMaker := %inlineables{$node.name}"...
    ║ │       │       ├─:Stmts
    ║ │       │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$codeMaker := %inlineables{$node.name}"
    ║ │       │       │   ├○ lexical $codeMaker
    ║ │       │       │   └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │       │       │     ├○ lexical %inlineables
    ║ │       │       │     └─callmethod name  ««".name"
    ║ │       │       │       └○ lexical $node
    ║ │       │       └─:Stmts
    ║ │       │         └─if  ««"$codeMaker {\n            my $out := $codeMaker($no"...
    ║ │       │           ├○ lexical $codeMaker
    ║ │       │           └─:Block :blocktype(immediate)  ««"{\n            my $out := $codeMaker($node.list);\n"...
    ║ │       │             ╟─:Stmts
    ║ │       │             ║ └○ lexical $out :decl(var)
    ║ │       │             ╙─:Stmts  ««"\n            my $out := $codeMaker($node.list);\n#"...
    ║ │       │               ├─:Stmts
    ║ │       │               │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$out := $codeMaker($node.list)"
    ║ │       │               │   ├○ lexical $out
    ║ │       │               │   └─call  ««"$node.list"
    ║ │       │               │     ├○ lexical $codeMaker
    ║ │       │               │     └─callmethod list  ««".list"
    ║ │       │               │       └○ lexical $node
    ║ │       │               ├─:Stmts
    ║ │       │               │ └─callmethod node  ««"$node.node"
    ║ │       │               │   ├○ lexical $out
    ║ │       │               │   └─callmethod node  ««".node"
    ║ │       │               │     └○ lexical $node
    ║ │       │               ├─:Stmts
    ║ │       │               │ └─callmethod flat  ««"$node.flat"
    ║ │       │               │   ├○ lexical $out
    ║ │       │               │   └─callmethod flat  ««".flat"
    ║ │       │               │     └○ lexical $node
    ║ │       │               ├─:Stmts
    ║ │       │               │ └─callmethod named  ««"$node.named"
    ║ │       │               │   ├○ lexical $out
    ║ │       │               │   └─callmethod named  ««".named"
    ║ │       │               │     └○ lexical $node
    ║ │       │               └─:Stmts
    ║ │       │                 └─bind &infix:<:=>  ««":="
    ║ │       │                   ├○ lexical $node
    ║ │       │                   └○ lexical $out
    ║ │       └─:Stmts
    ║ │         └○ lexical $node
    ║ ├─bind
    ║ │ ├○ lexical &inline_simple_methods :decl(var)
    ║ │ └─:Block  ««"{\n    nqp::die('inline_simple_methods expects a QA"...
    ║ │   ╟─:Stmts
    ║ │   ║ └○ lexical $node :decl(param)
    ║ │   ╙─:Stmts  ««"\n    nqp::die('inline_simple_methods expects a QAS"...
    ║ │     ├─:Stmts
    ║ │     │ └─unless  ««"nqp::die('inline_simple_methods expects a QAST::Nod"...
    ║ │     │   ├─call &istype  ««"$node, QAST::Node"
    ║ │     │   │ ├○ lexical $node
    ║ │     │   │ └◙ WVal QAST::Node
    ║ │     │   └─die  ««"nqp::die('inline_simple_methods expects a QAST::Nod"...
    ║ │     │     └─concat &infix:<~>  ««"~"
    ║ │     │       ├◙ SVal "inline_simple_methods expects a QAST::Node - got "
    ║ │     │       └─call &describe  ««"$node"
    ║ │     │         └○ lexical $node
    ║ │     ├─:Stmts
    ║ │     │ └─for  ««"$node.list {\n        inline_simple_methods($_);\n "...
    ║ │     │   ├─callmethod list  ««".list"
    ║ │     │   │ └○ lexical $node
    ║ │     │   ├─:Block :blocktype(immediate)  ««"{\n        inline_simple_methods($_);\n    }"
    ║ │     │   │ ╟─:Stmts
    ║ │     │   │ ║ └○ lexical $_ :decl(param)
    ║ │     │   │ ╙─:Stmts  ««"\n        inline_simple_methods($_);\n    "
    ║ │     │   │   └─:Stmts
    ║ │     │   │     └─call &inline_simple_methods  ««"$_"
    ║ │     │   │       └○ lexical $_
    ║ │     │   └◙ IVal 1 :named("nohandler")
    ║ │     ├─:Stmts
    ║ │     │ └─if  ««"istype($node, QAST::Op) && $node.op eq 'callmethod'"...
    ║ │     │   ├─if &infix:<&&>  ««"&&"
    ║ │     │   │ ├─call &istype  ««"$node, QAST::Op"
    ║ │     │   │ │ ├○ lexical $node
    ║ │     │   │ │ └◙ WVal QAST::Op
    ║ │     │   │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   │   ├─callmethod op  ««".op"
    ║ │     │   │   │ └○ lexical $node
    ║ │     │   │   └◙ SVal "callmethod"
    ║ │     │   └─:Block :blocktype(immediate)  ««"{\n        my $meth := $node.name;\n        if $met"...
    ║ │     │     ╟─:Stmts
    ║ │     │     ║ └○ lexical $meth :decl(var)
    ║ │     │     ╙─:Stmts  ««"\n        my $meth := $node.name;\n        if $meth"...
    ║ │     │       ├─:Stmts
    ║ │     │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$meth := $node.name"
    ║ │     │       │   ├○ lexical $meth
    ║ │     │       │   └─callmethod name  ««".name"
    ║ │     │       │     └○ lexical $node
    ║ │     │       └─:Stmts
    ║ │     │         └─if  ««"$meth {\n            if nqp::index('push pop shift "...
    ║ │     │           ├○ lexical $meth
    ║ │     │           └─:Stmts  ««"{\n            if nqp::index('push pop shift unshif"...
    ║ │     │             ├─:Stmts
    ║ │     │             └─:Stmts  ««"\n            if nqp::index('push pop shift unshift"...
    ║ │     │               └─:Stmts
    ║ │     │                 └─if  ««"nqp::index('push pop shift unshift', $meth) > -1 {\"...
    ║ │     │                   ├─isgt_n &infix:<>>  ««">"
    ║ │     │                   │ ├─index  ««"nqp::index('push pop shift unshift', $meth)"
    ║ │     │                   │ │ ├◙ SVal "push pop shift unshift"
    ║ │     │                   │ │ └○ lexical $meth
    ║ │     │                   │ └◙ IVal -1
    ║ │     │                   ├─:Stmts  ««"{\n                $node.op($meth);\n              "...
    ║ │     │                   │ ├─:Stmts
    ║ │     │                   │ └─:Stmts  ««"\n                $node.op($meth);\n               "...
    ║ │     │                   │   ├─:Stmts
    ║ │     │                   │   │ └─callmethod op  ««"$meth"
    ║ │     │                   │   │   ├○ lexical $node
    ║ │     │                   │   │   └○ lexical $meth
    ║ │     │                   │   └─:Stmts
    ║ │     │                   │     └─callmethod name  ««"nqp::null_s"
    ║ │     │                   │       ├○ lexical $node
    ║ │     │                   │       └─null_s  ««"nqp::null_s"
    ║ │     │                   └─if  ««"$meth eq 'key' {\n                $node.op('iterkey"...
    ║ │     │                     ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │                     │ ├○ lexical $meth
    ║ │     │                     │ └◙ SVal "key"
    ║ │     │                     ├─:Stmts  ««"{\n                $node.op('iterkey_s');\n        "...
    ║ │     │                     │ ├─:Stmts
    ║ │     │                     │ └─:Stmts  ««"\n                $node.op('iterkey_s');\n         "...
    ║ │     │                     │   ├─:Stmts
    ║ │     │                     │   │ └─callmethod op  ««"'iterkey_s'"
    ║ │     │                     │   │   ├○ lexical $node
    ║ │     │                     │   │   └◙ SVal "iterkey_s"
    ║ │     │                     │   └─:Stmts
    ║ │     │                     │     └─callmethod name  ««"nqp::null_s"
    ║ │     │                     │       ├○ lexical $node
    ║ │     │                     │       └─null_s  ««"nqp::null_s"
    ║ │     │                     └─if  ««"$meth eq 'value' {\n                $node.op('iterv"...
    ║ │     │                       ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │                       │ ├○ lexical $meth
    ║ │     │                       │ └◙ SVal "value"
    ║ │     │                       └─:Stmts  ««"{\n                $node.op('iterval');\n          "...
    ║ │     │                         ├─:Stmts
    ║ │     │                         └─:Stmts  ««"\n                $node.op('iterval');\n           "...
    ║ │     │                           ├─:Stmts
    ║ │     │                           │ └─callmethod op  ««"'iterval'"
    ║ │     │                           │   ├○ lexical $node
    ║ │     │                           │   └◙ SVal "iterval"
    ║ │     │                           └─:Stmts
    ║ │     │                             └─callmethod name  ««"nqp::null_s"
    ║ │     │                               ├○ lexical $node
    ║ │     │                               └─null_s  ««"nqp::null_s"
    ║ │     └─:Stmts
    ║ │       └○ lexical $node
    ║ ├─bind
    ║ │ ├○ lexical &replace_assoc_and_pos_scoped :decl(var)
    ║ │ └─:Block  ««"{\n    nqp::die('replace_assoc_and_pos_scoped expec"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $node :decl(param)
    ║ │   ║ ├○ lexical $i :decl(var)
    ║ │   ║ └○ lexical @children :decl(var)
    ║ │   ╙─:Stmts  ««"\n    nqp::die('replace_assoc_and_pos_scoped expect"...
    ║ │     ├─:Stmts
    ║ │     │ └─unless  ««"nqp::die('replace_assoc_and_pos_scoped expects a QA"...
    ║ │     │   ├─call &istype  ««"$node, QAST::Node"
    ║ │     │   │ ├○ lexical $node
    ║ │     │   │ └◙ WVal QAST::Node
    ║ │     │   └─die  ««"nqp::die('replace_assoc_and_pos_scoped expects a QA"...
    ║ │     │     └─concat &infix:<~>  ««"~"
    ║ │     │       ├◙ SVal "replace_assoc_and_pos_scoped expects a QAST::Node - got "
    ║ │     │       └─call &describe  ««"$node"
    ║ │     │         └○ lexical $node
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$i := 0"
    ║ │     │   ├○ lexical $i
    ║ │     │   └◙ IVal 0
    ║ │     ├─:Stmts
    ║ │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@children := $node.list"
    ║ │     │   ├○ lexical @children
    ║ │     │   └─callmethod list  ««".list"
    ║ │     │     └○ lexical $node
    ║ │     ├─:Stmts
    ║ │     │ └─for  ««"@children {\n        @children[$i] := replace_assoc"...
    ║ │     │   ├○ lexical @children
    ║ │     │   ├─:Block :blocktype(immediate)  ««"{\n        @children[$i] := replace_assoc_and_pos_s"...
    ║ │     │   │ ╟─:Stmts
    ║ │     │   │ ║ └○ lexical $_ :decl(param)
    ║ │     │   │ ╙─:Stmts  ««"\n        @children[$i] := replace_assoc_and_pos_sc"...
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─bind &infix:<:=>  ««":="
    ║ │     │   │   │   ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │   │   │   │ ├○ lexical @children
    ║ │     │   │   │   │ └○ lexical $i
    ║ │     │   │   │   └─call &replace_assoc_and_pos_scoped  ««"$_"
    ║ │     │   │   │     └○ lexical $_
    ║ │     │   │   └─:Stmts
    ║ │     │   │     └─postinc &postfix:<++>  ««"++"
    ║ │     │   │       └○ lexical $i
    ║ │     │   └◙ IVal 1 :named("nohandler")
    ║ │     ├─:Stmts
    ║ │     │ └─if  ««"istype($node, QAST::Op) && ($node.op eq 'bind') && "...
    ║ │     │   ├─if &infix:<&&>  ««"&&"
    ║ │     │   │ ├─if &infix:<&&>  ««"&&"
    ║ │     │   │ │ ├─call &istype  ««"$node, QAST::Op"
    ║ │     │   │ │ │ ├○ lexical $node
    ║ │     │   │ │ │ └◙ WVal QAST::Op
    ║ │     │   │ │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   │ │   ├─callmethod op  ««".op"
    ║ │     │   │ │   │ └○ lexical $node
    ║ │     │   │ │   └◙ SVal "bind"
    ║ │     │   │ └─falsey &prefix:<!>  ««"!"
    ║ │     │   │   └─call &istype  ««"$node[0], QAST::Var"
    ║ │     │   │     ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │   │     │ ├○ lexical $node
    ║ │     │   │     │ └◙ IVal 0
    ║ │     │   │     └◙ WVal QAST::Var
    ║ │     │   ├─:Block :blocktype(immediate)  ««"{\n        # then our 1st child was just transforme"...
    ║ │     │   │ ╟─:Stmts
    ║ │     │   │ ║ ├○ lexical $child1 :decl(var)
    ║ │     │   │ ║ └○ lexical $which :decl(var)
    ║ │     │   │ ╙─:Stmts  ««"\n        # then our 1st child was just transformed"...
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$child1 := $node.shift"
    ║ │     │   │   │   ├○ lexical $child1
    ║ │     │   │   │   └─callmethod shift  ««".shift"
    ║ │     │   │   │     └○ lexical $node
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─unless  ««"nqp::die(\"ooops: \" ~ dump($child1, :oneLine))\n  "...
    ║ │     │   │   │   ├─call &istype  ««"$child1, QAST::Op"
    ║ │     │   │   │   │ ├○ lexical $child1
    ║ │     │   │   │   │ └◙ WVal QAST::Op
    ║ │     │   │   │   └─die  ««"nqp::die(\"ooops: \" ~ dump($child1, :oneLine))"
    ║ │     │   │   │     └─concat &infix:<~>  ««"~"
    ║ │     │   │   │       ├◙ SVal "ooops: "
    ║ │     │   │   │       └─call &dump  ««"$child1, :oneLine"
    ║ │     │   │   │         ├○ lexical $child1
    ║ │     │   │   │         └◙ IVal 1 :named("oneLine")
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$which := nqp::substr($child1.op, 0, 5)"
    ║ │     │   │   │   ├○ lexical $which
    ║ │     │   │   │   └─substr  ««"nqp::substr($child1.op, 0, 5)"
    ║ │     │   │   │     ├─callmethod op  ««".op"
    ║ │     │   │   │     │ └○ lexical $child1
    ║ │     │   │   │     ├◙ IVal 0
    ║ │     │   │   │     └◙ IVal 5
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─unless  ««"nqp::die(\"ooops: cannot handle op $which: \" ~ dum"...
    ║ │     │   │   │   ├─unless &infix:<||>  ««"||"
    ║ │     │   │   │   │ ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   │   │   │ │ ├○ lexical $which
    ║ │     │   │   │   │ │ └◙ SVal "atpos"
    ║ │     │   │   │   │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   │   │   │   ├○ lexical $which
    ║ │     │   │   │   │   └◙ SVal "atkey"
    ║ │     │   │   │   └─die  ««"nqp::die(\"ooops: cannot handle op $which: \" ~ dum"...
    ║ │     │   │   │     └─concat &infix:<~>  ««"~"
    ║ │     │   │   │       ├─concat
    ║ │     │   │   │       │ ├─concat
    ║ │     │   │   │       │ │ ├◙ SVal "ooops: cannot handle op "
    ║ │     │   │   │       │ │ └○ lexical $which
    ║ │     │   │   │       │ └◙ SVal ": "
    ║ │     │   │   │       └─call &dump  ««"$child1, :oneLine"
    ║ │     │   │   │         ├○ lexical $child1
    ║ │     │   │   │         └◙ IVal 1 :named("oneLine")
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─callmethod op  ««"'bind' ~ nqp::substr($child1.op, 2)"
    ║ │     │   │   │   ├○ lexical $node
    ║ │     │   │   │   └─concat &infix:<~>  ««"~"
    ║ │     │   │   │     ├◙ SVal "bind"
    ║ │     │   │   │     └─substr  ««"nqp::substr($child1.op, 2)"
    ║ │     │   │   │       ├─callmethod op  ««".op"
    ║ │     │   │   │       │ └○ lexical $child1
    ║ │     │   │   │       └◙ IVal 2
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─callmethod node  ««"$child1.node"
    ║ │     │   │   │   ├○ lexical $node
    ║ │     │   │   │   └─callmethod node  ««".node"
    ║ │     │   │   │     └○ lexical $child1
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─callmethod flat  ««"$child1.flat"
    ║ │     │   │   │   ├○ lexical $node
    ║ │     │   │   │   └─callmethod flat  ««".flat"
    ║ │     │   │   │     └○ lexical $child1
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─callmethod named  ««"$child1.named"
    ║ │     │   │   │   ├○ lexical $node
    ║ │     │   │   │   └─callmethod named  ««".named"
    ║ │     │   │   │     └○ lexical $child1
    ║ │     │   │   ├─:Stmts
    ║ │     │   │   │ └─callmethod unshift  ««"$child1[1]"
    ║ │     │   │   │   ├○ lexical $node
    ║ │     │   │   │   └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │   │   │     ├○ lexical $child1
    ║ │     │   │   │     └◙ IVal 1
    ║ │     │   │   └─:Stmts
    ║ │     │   │     └─callmethod unshift  ««"$child1[0]"
    ║ │     │   │       ├○ lexical $node
    ║ │     │   │       └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │   │         ├○ lexical $child1
    ║ │     │   │         └◙ IVal 0
    ║ │     │   └─if  ««"istype($node, QAST::VarWithFallback) {\n        my "...
    ║ │     │     ├─call &istype  ««"$node, QAST::VarWithFallback"
    ║ │     │     │ ├○ lexical $node
    ║ │     │     │ └◙ WVal QAST::VarWithFallback
    ║ │     │     └─:Block :blocktype(immediate)  ««"{\n        my $fallback := $node.fallback;\n       "...
    ║ │     │       ╟─:Stmts
    ║ │     │       ║ ├○ lexical $fallback :decl(var)
    ║ │     │       ║ ├○ lexical $scope :decl(var)
    ║ │     │       ║ └─bind  ««"$op"
    ║ │     │       ║   ├○ lexical $op :decl(var)
    ║ │     │       ║   └◙ WVal NQPMu
    ║ │     │       ╙─:Stmts  ««"\n        my $fallback := $node.fallback;\n        "...
    ║ │     │         ├─:Stmts
    ║ │     │         │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$fallback := $node.fallback"
    ║ │     │         │   ├○ lexical $fallback
    ║ │     │         │   └─callmethod fallback  ««".fallback"
    ║ │     │         │     └○ lexical $node
    ║ │     │         ├─:Stmts
    ║ │     │         │ └─if  ««"nqp::isnull($fallback) || istype($fallback, NQPMu) "...
    ║ │     │         │   ├─unless &infix:<||>  ««"||"
    ║ │     │         │   │ ├─isnull  ««"nqp::isnull($fallback)"
    ║ │     │         │   │ │ └○ lexical $fallback
    ║ │     │         │   │ └─call &istype  ««"$fallback, NQPMu"
    ║ │     │         │   │   ├○ lexical $fallback
    ║ │     │         │   │   └◙ WVal NQPMu
    ║ │     │         │   ├─:Stmts  ««"{\n            $fallback := nqp::null;\n        }"
    ║ │     │         │   │ ├─:Stmts
    ║ │     │         │   │ └─:Stmts  ««"\n            $fallback := nqp::null;\n        "
    ║ │     │         │   │   └─:Stmts
    ║ │     │         │   │     └─bind &infix:<:=>  ««":="
    ║ │     │         │   │       ├○ lexical $fallback
    ║ │     │         │   │       └─null  ««"nqp::null"
    ║ │     │         │   └─:Stmts  ««"{\n            nqp::die('cannot handle fallback ' ~"...
    ║ │     │         │     ├─:Stmts
    ║ │     │         │     └─:Stmts  ««"\n            nqp::die('cannot handle fallback ' ~ "...
    ║ │     │         │       └─:Stmts
    ║ │     │         │         └─die  ««"nqp::die('cannot handle fallback ' ~ describe($node"...
    ║ │     │         │           └─concat &infix:<~>  ««"~"
    ║ │     │         │             ├◙ SVal "cannot handle fallback "
    ║ │     │         │             └─call &describe  ««"$node.fallback"
    ║ │     │         │               └─callmethod fallback  ««".fallback"
    ║ │     │         │                 └○ lexical $node
    ║ │     │         ├─:Stmts
    ║ │     │         │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$scope := $node.scope"
    ║ │     │         │   ├○ lexical $scope
    ║ │     │         │   └─callmethod scope  ««".scope"
    ║ │     │         │     └○ lexical $node
    ║ │     │         ├─:Stmts
    ║ │     │         │ └○ lexical $op
    ║ │     │         ├─:Stmts
    ║ │     │         │ └─if  ««"$scope eq 'positional' {\n            $op := 'atpos"...
    ║ │     │         │   ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │         │   │ ├○ lexical $scope
    ║ │     │         │   │ └◙ SVal "positional"
    ║ │     │         │   ├─:Stmts  ««"{\n            $op := 'atpos';\n        }"
    ║ │     │         │   │ ├─:Stmts
    ║ │     │         │   │ └─:Stmts  ««"\n            $op := 'atpos';\n        "
    ║ │     │         │   │   └─:Stmts
    ║ │     │         │   │     └─bind &infix:<:=>  ««":="
    ║ │     │         │   │       ├○ lexical $op
    ║ │     │         │   │       └◙ SVal "atpos"
    ║ │     │         │   └─if  ««"$scope eq 'associative' {\n            $op := 'atke"...
    ║ │     │         │     ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │         │     │ ├○ lexical $scope
    ║ │     │         │     │ └◙ SVal "associative"
    ║ │     │         │     └─:Stmts  ««"{\n            $op := 'atkey';\n        }"
    ║ │     │         │       ├─:Stmts
    ║ │     │         │       └─:Stmts  ««"\n            $op := 'atkey';\n        "
    ║ │     │         │         └─:Stmts
    ║ │     │         │           └─bind &infix:<:=>  ««":="
    ║ │     │         │             ├○ lexical $op
    ║ │     │         │             └◙ SVal "atkey"
    ║ │     │         └─:Stmts
    ║ │     │           └─if  ««"$op {\n            $node := QAST::Op.new(:$op,\n   "...
    ║ │     │             ├○ lexical $op
    ║ │     │             └─:Stmts  ««"{\n            $node := QAST::Op.new(:$op,\n       "...
    ║ │     │               ├─:Stmts
    ║ │     │               └─:Stmts  ««"\n            $node := QAST::Op.new(:$op,\n        "...
    ║ │     │                 └─:Stmts
    ║ │     │                   └─bind &infix:<:=>  ««":="
    ║ │     │                     ├○ lexical $node
    ║ │     │                     └─callmethod new  ««":$op,\n                :node($node.node),\n        "...
    ║ │     │                       ├◙ WVal QAST::Op
    ║ │     │                       ├○ lexical $op :named("op")
    ║ │     │                       ├─callmethod node :named("node")  ««".node"
    ║ │     │                       │ └○ lexical $node
    ║ │     │                       ├─callmethod named :named("named")  ««".named"
    ║ │     │                       │ └○ lexical $node
    ║ │     │                       ├─callmethod flat :named("flat")  ««".flat"
    ║ │     │                       │ └○ lexical $node
    ║ │     │                       └─callmethod list :flat(1)  ««".list"
    ║ │     │                         └○ lexical $node
    ║ │     └─:Stmts
    ║ │       └○ lexical $node
    ║ ├─bind
    ║ │ ├○ lexical &renameVars :decl(var)
    ║ │ └─:Block  ««"{\n    nqp::die('renameVars expects a QAST::Node as"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $ast :decl(param)
    ║ │   ║ └○ lexical $map :decl(param)
    ║ │   ╙─:Stmts  ««"\n    nqp::die('renameVars expects a QAST::Node as "...
    ║ │     ├─:Stmts
    ║ │     │ └─unless  ««"nqp::die('renameVars expects a QAST::Node as 1st ar"...
    ║ │     │   ├─call &istype  ««"$ast, QAST::Node"
    ║ │     │   │ ├○ lexical $ast
    ║ │     │   │ └◙ WVal QAST::Node
    ║ │     │   └─die  ««"nqp::die('renameVars expects a QAST::Node as 1st ar"...
    ║ │     │     └─concat &infix:<~>  ««"~"
    ║ │     │       ├◙ SVal "renameVars expects a QAST::Node as 1st arg - got "
    ║ │     │       └─call &describe  ««"$ast"
    ║ │     │         └○ lexical $ast
    ║ │     ├─:Stmts
    ║ │     │ └─unless  ««"nqp::die('renameVars expects a unary fn as 2nd arg("...
    ║ │     │   ├─isinvokable  ««"nqp::isinvokable($map)"
    ║ │     │   │ └○ lexical $map
    ║ │     │   └─die  ««"nqp::die('renameVars expects a unary fn as 2nd arg("...
    ║ │     │     └─concat &infix:<~>  ««"~"
    ║ │     │       ├◙ SVal "renameVars expects a unary fn as 2nd arg(optional) - got "
    ║ │     │       └─call &describe  ««"$map"
    ║ │     │         └○ lexical $map
    ║ │     ├─:Stmts
    ║ │     │ └─if  ««"istype($ast, QAST::Var) \n       || (\n          is"...
    ║ │     │   ├─unless &infix:<||>  ««"||"
    ║ │     │   │ ├─call &istype  ««"$ast, QAST::Var"
    ║ │     │   │ │ ├○ lexical $ast
    ║ │     │   │ │ └◙ WVal QAST::Var
    ║ │     │   │ └─if &infix:<&&>  ««"&&"
    ║ │     │   │   ├─call &istype  ««"$ast, QAST::Op"
    ║ │     │   │   │ ├○ lexical $ast
    ║ │     │   │   │ └◙ WVal QAST::Op
    ║ │     │   │   └─unless &infix:<||>  ««"||"
    ║ │     │   │     ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   │     │ ├─callmethod op  ««".op"
    ║ │     │   │     │ │ └○ lexical $ast
    ║ │     │   │     │ └◙ SVal "call"
    ║ │     │   │     └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   │       ├─callmethod op  ««".op"
    ║ │     │   │       │ └○ lexical $ast
    ║ │     │   │       └◙ SVal "callstatic"
    ║ │     │   └─:Block :blocktype(immediate)  ««"{\n        my str $old := $ast.name;\n        my st"...
    ║ │     │     ╟─:Stmts
    ║ │     │     ║ ├○ lexical $old :decl(var)
    ║ │     │     ║ └○ lexical $new :decl(var)
    ║ │     │     ╙─:Stmts  ««"\n        my str $old := $ast.name;\n        my str"...
    ║ │     │       ├─:Stmts
    ║ │     │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"str $old := $ast.name"
    ║ │     │       │   ├○ lexical $old
    ║ │     │       │   └─callmethod name  ««".name"
    ║ │     │       │     └○ lexical $ast
    ║ │     │       ├─:Stmts
    ║ │     │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"str $new := $map($old)"
    ║ │     │       │   ├○ lexical $new
    ║ │     │       │   └─call  ««"$old"
    ║ │     │       │     ├○ lexical $map
    ║ │     │       │     └○ lexical $old
    ║ │     │       └─:Stmts
    ║ │     │         └─if  ««"$new ne $old {\n            $ast.name($new);\n     "...
    ║ │     │           ├─isne_s &infix:<ne>  ««"ne"
    ║ │     │           │ ├○ lexical $new
    ║ │     │           │ └○ lexical $old
    ║ │     │           └─:Stmts  ««"{\n            $ast.name($new);\n        }"
    ║ │     │             ├─:Stmts
    ║ │     │             └─:Stmts  ««"\n            $ast.name($new);\n        "
    ║ │     │               └─:Stmts
    ║ │     │                 └─callmethod name  ««"$new"
    ║ │     │                   ├○ lexical $ast
    ║ │     │                   └○ lexical $new
    ║ │     ├─:Stmts
    ║ │     │ └─for  ««"$ast.list {\n        renameVars($_, $map);\n    }"
    ║ │     │   ├─callmethod list  ««".list"
    ║ │     │   │ └○ lexical $ast
    ║ │     │   ├─:Block :blocktype(immediate)  ««"{\n        renameVars($_, $map);\n    }"
    ║ │     │   │ ╟─:Stmts
    ║ │     │   │ ║ └○ lexical $_ :decl(param)
    ║ │     │   │ ╙─:Stmts  ««"\n        renameVars($_, $map);\n    "
    ║ │     │   │   └─:Stmts
    ║ │     │   │     └─call &renameVars  ««"$_, $map"
    ║ │     │   │       ├○ lexical $_
    ║ │     │   │       └○ lexical $map
    ║ │     │   └◙ IVal 1 :named("nohandler")
    ║ │     └─:Stmts
    ║ │       └○ lexical $ast
    ║ ├○ lexical SmartCompiler :decl(static) :default((SmartCompiler, Type object))
    ║ ├○ lexical NQPActions :decl(static) :default((NQPActions, Type object))
    ║ ├○ lexical $needsCompilation :decl(var)
    ║ ├○ lexical NQPCompiler :decl(static) :default((NQPCompiler, Type object))
    ║ ├─bind
    ║ │ ├○ lexical &flatten :decl(var)
    ║ │ └─:Block  ««"{\n    return [$args]\n        unless nqp::islist($"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $args :decl(param)
    ║ │   ║ └○ lexical @out :decl(var)
    ║ │   ╙─lexotic RETURN
    ║ │     └─:Stmts  ««"\n    return [$args]\n        unless nqp::islist($a"...
    ║ │       ├─:Stmts
    ║ │       │ └─unless  ««"return [$args]\n        unless nqp::islist($args)"
    ║ │       │   ├─islist  ««"nqp::islist($args)"
    ║ │       │   │ └○ lexical $args
    ║ │       │   └─call RETURN
    ║ │       │     └─list &circumfix:<[ ]>
    ║ │       │       └○ lexical $args
    ║ │       ├─:Stmts
    ║ │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@out := []"
    ║ │       │   ├○ lexical @out
    ║ │       │   └─list &circumfix:<[ ]>
    ║ │       ├─:Stmts
    ║ │       │ └─for  ««"$args -> $_ {\n        if nqp::islist($_) {\n      "...
    ║ │       │   ├○ lexical $args
    ║ │       │   ├─:Block :blocktype(immediate)  ««"{\n        if nqp::islist($_) {\n            for fl"...
    ║ │       │   │ ╟─:Stmts
    ║ │       │   │ ║ └○ lexical $_ :decl(param)
    ║ │       │   │ ╙─:Stmts  ««"\n        if nqp::islist($_) {\n            for fla"...
    ║ │       │   │   └─:Stmts
    ║ │       │   │     └─if  ««"nqp::islist($_) {\n            for flatten($_) -> $"...
    ║ │       │   │       ├─islist  ««"nqp::islist($_)"
    ║ │       │   │       │ └○ lexical $_
    ║ │       │   │       ├─:Stmts  ««"{\n            for flatten($_) -> $_ {\n           "...
    ║ │       │   │       │ ├─:Stmts
    ║ │       │   │       │ └─:Stmts  ««"\n            for flatten($_) -> $_ {\n            "...
    ║ │       │   │       │   └─:Stmts
    ║ │       │   │       │     └─for  ««"flatten($_) -> $_ {\n                @out.push($_);"...
    ║ │       │   │       │       ├─call &flatten  ««"$_"
    ║ │       │   │       │       │ └○ lexical $_
    ║ │       │   │       │       ├─:Block :blocktype(immediate)  ««"{\n                @out.push($_);\n            }"
    ║ │       │   │       │       │ ╟─:Stmts
    ║ │       │   │       │       │ ║ └○ lexical $_ :decl(param)
    ║ │       │   │       │       │ ╙─:Stmts  ««"\n                @out.push($_);\n            "
    ║ │       │   │       │       │   └─:Stmts
    ║ │       │   │       │       │     └─callmethod push  ««"$_"
    ║ │       │   │       │       │       ├○ lexical @out
    ║ │       │   │       │       │       └○ lexical $_
    ║ │       │   │       │       └◙ IVal 1 :named("nohandler")
    ║ │       │   │       └─:Stmts  ««"{\n            @out.push($_);\n        }"
    ║ │       │   │         ├─:Stmts
    ║ │       │   │         └─:Stmts  ««"\n            @out.push($_);\n        "
    ║ │       │   │           └─:Stmts
    ║ │       │   │             └─callmethod push  ««"$_"
    ║ │       │   │               ├○ lexical @out
    ║ │       │   │               └○ lexical $_
    ║ │       │   └◙ IVal 1 :named("nohandler")
    ║ │       └─:Stmts
    ║ │         └○ lexical @out
    ║ └─bind
    ║   ├○ lexical &MAIN :decl(var)
    ║   └─:Block  ««"{\n    @ARGS := flatten(@ARGS);\n\n    my $cwd := n"...
    ║     ╟─:Stmts
    ║     ║ ├○ lexical @ARGS :decl(param) :slurpy(1)
    ║     ║ ├○ lexical $cwd :decl(var)
    ║     ║ ├○ lexical $sep :decl(var)
    ║     ║ ├○ lexical $nqpc :decl(var)
    ║     ║ └○ lexical %opts :decl(var)
    ║     ╙─:Stmts  ««"\n    @ARGS := flatten(@ARGS);\n\n    my $cwd := nq"...
    ║       ├─:Stmts
    ║       │ └─bind &infix:<:=>  ««":="
    ║       │   ├○ lexical @ARGS
    ║       │   └─call &flatten  ««"@ARGS"
    ║       │     └○ lexical @ARGS
    ║       ├─:Stmts
    ║       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$cwd := nqp::cwd()"
    ║       │   ├○ lexical $cwd
    ║       │   └─cwd  ««"nqp::cwd()"
    ║       ├─:Stmts
    ║       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$sep := nqp::x('-', 29)"
    ║       │   ├○ lexical $sep
    ║       │   └─x  ««"nqp::x('-', 29)"
    ║       │     ├◙ SVal "-"
    ║       │     └◙ IVal 29
    ║       ├─:Stmts
    ║       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$nqpc := NQPCompiler.new()"
    ║       │   ├○ lexical $nqpc
    ║       │   └─callmethod new  ««""
    ║       │     └◙ WVal NQPCompiler
    ║       ├─:Stmts
    ║       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"%opts := hash()"
    ║       │   ├○ lexical %opts
    ║       │   └─call &hash  ««""
    ║       ├─:Stmts
    ║       │ └─callmethod shift  ««".shift"
    ║       │   └○ lexical @ARGS
    ║       ├─:Stmts
    ║       │ └─if  ««"nqp::elems(@ARGS) == 0 {\n        #@ARGS.push('L/LG"...
    ║       │   ├─iseq_n &infix:<==>  ««"=="
    ║       │   │ ├─elems  ««"nqp::elems(@ARGS)"
    ║       │   │ │ └○ lexical @ARGS
    ║       │   │ └◙ IVal 0
    ║       │   └─:Stmts  ««"{\n        #@ARGS.push('L/LGrammar.nqp');\n        "...
    ║       │     ├─:Stmts
    ║       │     └─:Stmts  ««"\n        #@ARGS.push('L/LGrammar.nqp');\n        #"...
    ║       │       └─:Stmts
    ║       │         └─callmethod push  ««"'lib/L/runtime.nqp'"
    ║       │           ├○ lexical @ARGS
    ║       │           └◙ SVal "lib/L/runtime.nqp"
    ║       ├─:Stmts
    ║       │ └─callmethod addstage  ««"'write_bytecode', :before<mbc>"
    ║       │   ├○ lexical $nqpc
    ║       │   ├◙ SVal "write_bytecode"
    ║       │   └◙ SVal "mbc" :named("before")
    ║       ├─:Stmts
    ║       │ └─for  ««"@ARGS {\n        my $file := $_;\n        \n       "...
    ║       │   ├○ lexical @ARGS
    ║       │   ├─:Block :annotations(#`{BOOTHash:}nqp::hash( "handlers", #`{BOOTHash:}nqp::hash( "CATCH", QAST::Stmts ) )) :blocktype(immediate)  ««"{\n        my $file := $_;\n        \n        my $r"...
    ║       │   │ ╟─:Stmts
    ║       │   │ ║ ├○ lexical $file :decl(var)
    ║       │   │ ║ ├○ lexical $result :decl(var)
    ║       │   │ ║ └○ lexical $_ :decl(param)
    ║       │   │ ╙─handle
    ║       │   │   ├─:Stmts  ««"\n        my $file := $_;\n        \n        my $re"...
    ║       │   │   │ ├─:Stmts
    ║       │   │   │ │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$file := $_"
    ║       │   │   │ │   ├○ lexical $file
    ║       │   │   │ │   └○ lexical $_
    ║       │   │   │ ├─:Stmts
    ║       │   │   │ │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$result := $nqpc.compileFile($file, |%opts)"
    ║       │   │   │ │   ├○ lexical $result
    ║       │   │   │ │   └─callmethod compileFile  ««"$file, |%opts"
    ║       │   │   │ │     ├○ lexical $nqpc
    ║       │   │   │ │     ├○ lexical $file
    ║       │   │   │ │     └○ lexical %opts :flat(1) :named(1)
    ║       │   │   │ ├─:Stmts
    ║       │   │   │ │ └─if  ««"nqp::isnull($result) {\n            $nqpc.log(\"upt"...
    ║       │   │   │ │   ├─isnull  ««"nqp::isnull($result)"
    ║       │   │   │ │   │ └○ lexical $result
    ║       │   │   │ │   ├─:Stmts  ««"{\n            $nqpc.log(\"uptodate: $file\");\n   "...
    ║       │   │   │ │   │ ├─:Stmts
    ║       │   │   │ │   │ └─:Stmts  ««"\n            $nqpc.log(\"uptodate: $file\");\n    "...
    ║       │   │   │ │   │   └─:Stmts
    ║       │   │   │ │   │     └─callmethod log  ««"\"uptodate: $file\""
    ║       │   │   │ │   │       ├○ lexical $nqpc
    ║       │   │   │ │   │       └─concat
    ║       │   │   │ │   │         ├◙ SVal "uptodate: "
    ║       │   │   │ │   │         └○ lexical $file
    ║       │   │   │ │   └─:Stmts  ««"{\n            $nqpc.log(\"compiled: $file ~> \" ~ "...
    ║       │   │   │ │     ├─:Stmts
    ║       │   │   │ │     └─:Stmts  ««"\n            $nqpc.log(\"compiled: $file ~> \" ~ d"...
    ║       │   │   │ │       └─:Stmts
    ║       │   │   │ │         └─callmethod log  ««"\"compiled: $file ~> \" ~ describe($result)"
    ║       │   │   │ │           ├○ lexical $nqpc
    ║       │   │   │ │           └─concat &infix:<~>  ««"~"
    ║       │   │   │ │             ├─concat
    ║       │   │   │ │             │ ├─concat
    ║       │   │   │ │             │ │ ├◙ SVal "compiled: "
    ║       │   │   │ │             │ │ └○ lexical $file
    ║       │   │   │ │             │ └◙ SVal " ~> "
    ║       │   │   │ │             └─call &describe  ««"$result"
    ║       │   │   │ │               └○ lexical $result
    ║       │   │   │ └─:Stmts
    ║       │   │   │   └◙ WVal NQPMu
    ║       │   │   ├► "CATCH" (str)
    ║       │   │   └─:Stmts
    ║       │   │     ├─call
    ║       │   │     │ ├─:Block  ««"{\n            $nqpc.log(\"ERROR: $file\");\n      "...
    ║       │   │     │ │ ╟○ lexical $_ :decl(param)
    ║       │   │     │ │ ╟─bind
    ║       │   │     │ │ ║ ├○ lexical $! :decl(var)
    ║       │   │     │ │ ║ └○ lexical $_
    ║       │   │     │ │ ╟─:Stmts
    ║       │   │     │ │ ╙─:Stmts  ««"\n            $nqpc.log(\"ERROR: $file\");\n       "...
    ║       │   │     │ │   ├─:Stmts
    ║       │   │     │ │   │ └─callmethod log  ««"\"ERROR: $file\""
    ║       │   │     │ │   │   ├○ lexical $nqpc
    ║       │   │     │ │   │   └─concat
    ║       │   │     │ │   │     ├◙ SVal "ERROR: "
    ║       │   │     │ │   │     └○ lexical $file
    ║       │   │     │ │   ├─:Stmts
    ║       │   │     │ │   │ └─callmethod log  ««"$sep"
    ║       │   │     │ │   │   ├○ lexical $nqpc
    ║       │   │     │ │   │   └○ lexical $sep
    ║       │   │     │ │   ├─:Stmts
    ║       │   │     │ │   │ └─callmethod log  ««"\"  CWD: $cwd\""
    ║       │   │     │ │   │   ├○ lexical $nqpc
    ║       │   │     │ │   │   └─concat
    ║       │   │     │ │   │     ├◙ SVal "  CWD: "
    ║       │   │     │ │   │     └○ lexical $cwd
    ║       │   │     │ │   ├─:Stmts
    ║       │   │     │ │   │ └─callmethod log  ««"' ARGS: ', nqp::join(' ', @ARGS)"
    ║       │   │     │ │   │   ├○ lexical $nqpc
    ║       │   │     │ │   │   ├◙ SVal " ARGS: "
    ║       │   │     │ │   │   └─join  ««"nqp::join(' ', @ARGS)"
    ║       │   │     │ │   │     ├◙ SVal " "
    ║       │   │     │ │   │     └○ lexical @ARGS
    ║       │   │     │ │   ├─:Stmts
    ║       │   │     │ │   │ └─callmethod log  ««"''"
    ║       │   │     │ │   │   ├○ lexical $nqpc
    ║       │   │     │ │   │   └◙ SVal ""
    ║       │   │     │ │   ├─:Stmts
    ║       │   │     │ │   │ └─callmethod log  ««"~$_"
    ║       │   │     │ │   │   ├○ lexical $nqpc
    ║       │   │     │ │   │   └─stringify &prefix:<~>  ««"~"
    ║       │   │     │ │   │     └○ lexical $_
    ║       │   │     │ │   └─:Stmts
    ║       │   │     │ │     └─exit  ««"nqp::exit(1)"
    ║       │   │     │ │       └◙ IVal 1
    ║       │   │     │ └─exception
    ║       │   │     ├─:VM
    ║       │   │     └◙ WVal NQPMu
    ║       │   └◙ IVal 1 :named("nohandler")
    ║       └─:Stmts
    ║         └─call &say  ««"$sep"
    ║           └○ lexical $sep
    ╟─:Stmts
    ║ ├─bind
    ║ │ ├○ local ctxsave :decl(var)
    ║ │ └○ contextual $*CTXSAVE
    ║ └─unless
    ║   ├─isnull
    ║   │ └○ local ctxsave
    ║   └─if
    ║     ├─can
    ║     │ ├○ local ctxsave
    ║     │ └◙ SVal "ctxsave"
    ║     └─callmethod ctxsave
    ║       └○ local ctxsave
    ╟─:Stmts  ««"#!nqp\nuse nqp;\nuse NQPHLL;\n\nuse Util;\nuse Util"...
    ║ ├─:Stmts
    ║ │ └─:Stmts :annotations(#`{BOOTHash:}nqp::hash( "use", "nqp" (str) ))  ««"use nqp"
    ║ ├─:Stmts
    ║ │ └─:Stmts :annotations(#`{BOOTHash:}nqp::hash( "use", "NQPHLL" (str) ))  ««"use NQPHLL"
    ║ ├─:Stmts
    ║ │ └─:Stmts :annotations(#`{BOOTHash:}nqp::hash( "use", "Util" (str) ))  ««"use Util"
    ║ ├─:Stmts
    ║ │ └─:Stmts :annotations(#`{BOOTHash:}nqp::hash( "use", "Util::QAST" (str) ))  ««"use Util::QAST"
    ║ ├─:Stmts
    ║ │ └○ lexical &drop_takeclosure
    ║ ├─:Stmts
    ║ │ └○ lexical &isinResultPosition
    ║ ├─:Stmts
    ║ │ └○ lexical &drop_bogusVars
    ║ ├─:Stmts
    ║ │ └○ lexical &remove_bogusOpNames
    ║ ├─:Stmts
    ║ │ └○ lexical &remove_MAIN
    ║ ├─:Stmts
    ║ │ └○ lexical &findDef
    ║ ├─:Stmts
    ║ │ └○ lexical &findDefs
    ║ ├─:Stmts
    ║ │ └○ lexical &findValueNodeInHash
    ║ ├─:Stmts
    ║ │ └○ lexical &cloneAndSubst
    ║ ├─:Stmts
    ║ │ └○ lexical &collect_params_and_body
    ║ ├─:Stmts
    ║ │ └○ lexical &inline_simple_subs
    ║ ├─:Stmts
    ║ │ └○ lexical &inline_simple_methods
    ║ ├─:Stmts
    ║ │ └○ lexical &replace_assoc_and_pos_scoped
    ║ ├─:Stmts
    ║ │ └○ lexical &renameVars
    ║ ├─:Stmts
    ║ │ └─:Block :blocktype(immediate)  ««"{\n\n    # Where to search for user source files.\n"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $?PACKAGE :decl(static) :default((SmartCompiler, Type object))
    ║ │   ║ └○ lexical $?CLASS :decl(static) :default((SmartCompiler, Type object))
    ║ │   ╙─:Stmts  ««"\n\n    # Where to search for user source files.\n "...
    ║ │     ├─:Stmts
    ║ │     │ └─:Stmts
    ║ │     ├─:Stmts
    ║ │     │ └─:Stmts
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        # in this order (!):\n        self.addst"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ └○ lexical @clo :decl(var)
    ║ │     │   ╙─:Stmts  ««"\n        # in this order (!):\n        self.addsta"...
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─callmethod addstage  ««"'ast_save',           :after<ast>"
    ║ │     │     │   ├─decont
    ║ │     │     │   │ └○ lexical self
    ║ │     │     │   ├◙ SVal "ast_save"
    ║ │     │     │   └◙ SVal "ast" :named("after")
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─callmethod addstage  ««"'fix_var_attrs',      :after<ast>"
    ║ │     │     │   ├─decont
    ║ │     │     │   │ └○ lexical self
    ║ │     │     │   ├◙ SVal "fix_var_attrs"
    ║ │     │     │   └◙ SVal "ast" :named("after")
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@clo := self.commandline_options()"
    ║ │     │     │   ├○ lexical @clo
    ║ │     │     │   └─callmethod commandline_options  ««""
    ║ │     │     │     └─decont
    ║ │     │     │       └○ lexical self
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─callmethod push  ««"'parsetrace'"
    ║ │     │     │   ├○ lexical @clo
    ║ │     │     │   └◙ SVal "parsetrace"
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─callmethod push  ««"'setting=s'"
    ║ │     │     │   ├○ lexical @clo
    ║ │     │     │   └◙ SVal "setting=s"
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─callmethod push  ««"'setting-path=s'"
    ║ │     │     │   ├○ lexical @clo
    ║ │     │     │   └◙ SVal "setting-path=s"
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─callmethod push  ««"'module-path=s'"
    ║ │     │     │   ├○ lexical @clo
    ║ │     │     │   └◙ SVal "module-path=s"
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─callmethod push  ««"'no-regex-lib'"
    ║ │     │     │   ├○ lexical @clo
    ║ │     │     │   └◙ SVal "no-regex-lib"
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─callmethod push  ««"'stable-sc'"
    ║ │     │     │   ├○ lexical @clo
    ║ │     │     │   └◙ SVal "stable-sc"
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─callmethod push  ««"'optimize=s'"
    ║ │     │     │   ├○ lexical @clo
    ║ │     │     │   └◙ SVal "optimize=s"
    ║ │     │     └─:Stmts
    ║ │     │       └─bind &infix:<:=>  ««":="
    ║ │     │         ├○ attribute @!user_srcpaths
    ║ │     │         │ ├─decont
    ║ │     │         │ │ └○ lexical self
    ║ │     │         │ └◙ WVal SmartCompiler
    ║ │     │         └─list  ««"<. lib lib/L>"
    ║ │     │           ├◙ SVal "."
    ║ │     │           ├◙ SVal "lib"
    ║ │     │           └◙ SVal "lib/L"
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        self.user-progname();\n    }"
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ └○ lexical self :decl(param)
    ║ │     │   ╙─:Stmts  ««"\n        self.user-progname();\n    "
    ║ │     │     └─:Stmts
    ║ │     │       └─callmethod user-progname  ««""
    ║ │     │         └─decont
    ║ │     │           └○ lexical self
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        $!user_binname := $v unless $v =:= NO_VA"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ └○ lexical $v :decl(param) :default((┬VarWithFallback associative  :decl() :fallback((ifnull) ((atkey) ((who) (WVal GLOBALish)) (SVal "NO_VALUE")) (WVal NQPMu))) ((who) ( lexical $?PACKAGE :decl())) (SVal "NO_VALUE"))
    ║ │     │   ╙─:Stmts  ««"\n        $!user_binname := $v unless $v =:= NO_VAL"...
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─unless  ««"$!user_binname := $v unless $v =:= NO_VALUE"
    ║ │     │     │   ├─eqaddr &infix:<=:=>  ««"=:="
    ║ │     │     │   │ ├○ lexical $v
    ║ │     │     │   │ └○┬VarWithFallback associative  :fallback((ifnull) ((atkey) ((who) (WVal GLOBALish)) (SVal "NO_VALUE")) (WVal NQPMu))
    ║ │     │     │   │   ├─who
    ║ │     │     │   │   │ └○ lexical $?PACKAGE
    ║ │     │     │   │   └◙ SVal "NO_VALUE"
    ║ │     │     │   └─bind &infix:<:=>  ««":="
    ║ │     │     │     ├○ attribute $!user_binname
    ║ │     │     │     │ ├─decont
    ║ │     │     │     │ │ └○ lexical self
    ║ │     │     │     │ └◙ WVal SmartCompiler
    ║ │     │     │     └○ lexical $v
    ║ │     │     └─:Stmts
    ║ │     │       └○ attribute $!user_binname
    ║ │     │         ├─decont
    ║ │     │         │ └○ lexical self
    ║ │     │         └◙ WVal SmartCompiler
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        @!user_srcpaths;\n    }"
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ └○ lexical self :decl(param)
    ║ │     │   ╙─:Stmts  ««"\n        @!user_srcpaths;\n    "
    ║ │     │     └─:Stmts
    ║ │     │       └○ attribute @!user_srcpaths
    ║ │     │         ├─decont
    ║ │     │         │ └○ lexical self
    ║ │     │         └◙ WVal SmartCompiler
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        my str $out := '# [' ~ self.compiler_pro"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ ├○ lexical $msg :decl(param)
    ║ │     │   ║ ├○ lexical @moreMsgPieces :decl(param) :slurpy(1)
    ║ │     │   ║ └○ lexical $out :decl(var)
    ║ │     │   ╙─:Stmts  ««"\n        my str $out := '# [' ~ self.compiler_prog"...
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"str $out := '# [' ~ self.compiler_progname ~ '] ' ~"...
    ║ │     │     │   ├○ lexical $out
    ║ │     │     │   └─concat &infix:<~>  ««"~"
    ║ │     │     │     ├─concat &infix:<~>  ««"~"
    ║ │     │     │     │ ├─concat &infix:<~>  ««"~"
    ║ │     │     │     │ │ ├◙ SVal "# ["
    ║ │     │     │     │ │ └─callmethod compiler_progname  ««".compiler_progname"
    ║ │     │     │     │ │   └─decont
    ║ │     │     │     │ │     └○ lexical self
    ║ │     │     │     │ └◙ SVal "] "
    ║ │     │     │     └○ lexical $msg
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─for  ««"@moreMsgPieces {\n            $out := $out ~ $_;\n "...
    ║ │     │     │   ├○ lexical @moreMsgPieces
    ║ │     │     │   ├─:Block :blocktype(immediate)  ««"{\n            $out := $out ~ $_;\n        }"
    ║ │     │     │   │ ╟─:Stmts
    ║ │     │     │   │ ║ └○ lexical $_ :decl(param)
    ║ │     │     │   │ ╙─:Stmts  ««"\n            $out := $out ~ $_;\n        "
    ║ │     │     │   │   └─:Stmts
    ║ │     │     │   │     └─bind &infix:<:=>  ««":="
    ║ │     │     │   │       ├○ lexical $out
    ║ │     │     │   │       └─concat &infix:<~>  ««"~"
    ║ │     │     │   │         ├○ lexical $out
    ║ │     │     │   │         └○ lexical $_
    ║ │     │     │   └◙ IVal 1 :named("nohandler")
    ║ │     │     └─:Stmts
    ║ │     │       └─call &say  ««"$out"
    ║ │     │         └○ lexical $out
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        my $path;\n        my $file_name := nqp:"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ ├○ lexical $module_name :decl(param)
    ║ │     │   ║ ├○ lexical @search_paths :decl(param)
    ║ │     │   ║ ├○ lexical $ext :decl(param) :named("ext")
    ║ │     │   ║ ├─bind  ««"$path"
    ║ │     │   ║ │ ├○ lexical $path :decl(var)
    ║ │     │   ║ │ └◙ WVal NQPMu
    ║ │     │   ║ └○ lexical $file_name :decl(var)
    ║ │     │   ╙─:Stmts  ««"\n        my $path;\n        my $file_name := nqp::"...
    ║ │     │     ├─:Stmts
    ║ │     │     │ └○ lexical $path
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$file_name := nqp::join('/', nqp::split('::', $modu"...
    ║ │     │     │   ├○ lexical $file_name
    ║ │     │     │   └─concat &infix:<~>  ««"~"
    ║ │     │     │     ├─join  ««"nqp::join('/', nqp::split('::', $module_name))"
    ║ │     │     │     │ ├◙ SVal "/"
    ║ │     │     │     │ └─split  ««"nqp::split('::', $module_name)"
    ║ │     │     │     │   ├◙ SVal "::"
    ║ │     │     │     │   └○ lexical $module_name
    ║ │     │     │     └─concat
    ║ │     │     │       ├◙ SVal "."
    ║ │     │     │       └○ lexical $ext
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─for  ««"@search_paths {\n            $path := \"$_/$file_na"...
    ║ │     │     │   ├○ lexical @search_paths
    ║ │     │     │   └─:Block :blocktype(immediate)  ««"{\n            $path := \"$_/$file_name\";\n       "...
    ║ │     │     │     ╟─:Stmts
    ║ │     │     │     ║ └○ lexical $_ :decl(param)
    ║ │     │     │     ╙─:Stmts  ««"\n            $path := \"$_/$file_name\";\n        "...
    ║ │     │     │       ├─:Stmts
    ║ │     │     │       │ └─bind &infix:<:=>  ««":="
    ║ │     │     │       │   ├○ lexical $path
    ║ │     │     │       │   └─concat
    ║ │     │     │       │     ├─concat
    ║ │     │     │       │     │ ├○ lexical $_
    ║ │     │     │       │     │ └◙ SVal "/"
    ║ │     │     │       │     └○ lexical $file_name
    ║ │     │     │       ├─:Stmts
    ║ │     │     │       │ └─if  ««"last if nqp::stat($path, nqp::const::STAT_EXISTS)\n"...
    ║ │     │     │       │   ├─stat  ««"nqp::stat($path, nqp::const::STAT_EXISTS)"
    ║ │     │     │       │   │ ├○ lexical $path
    ║ │     │     │       │   │ └─const STAT_EXISTS
    ║ │     │     │       │   └─control last
    ║ │     │     │       └─:Stmts
    ║ │     │     │         └─bind &infix:<:=>  ««":="
    ║ │     │     │           ├○ lexical $path
    ║ │     │     │           └─null  ««"nqp::null"
    ║ │     │     └─:Stmts
    ║ │     │       └○ lexical $path
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        self.find_file($module_name, @!user_srcp"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ ├○ lexical $module_name :decl(param)
    ║ │     │   ║ └○ lexical $ext :decl(param) :named("ext")
    ║ │     │   ╙─:Stmts  ««"\n        self.find_file($module_name, @!user_srcpa"...
    ║ │     │     └─:Stmts
    ║ │     │       └─callmethod find_file  ««"$module_name, @!user_srcpaths, :$ext"
    ║ │     │         ├─decont
    ║ │     │         │ └○ lexical self
    ║ │     │         ├○ lexical $module_name
    ║ │     │         ├○ attribute @!user_srcpaths
    ║ │     │         │ ├─decont
    ║ │     │         │ │ └○ lexical self
    ║ │     │         │ └◙ WVal SmartCompiler
    ║ │     │         └○ lexical $ext :named("ext")
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n            my $loader := nqp::getcurhllsym('Mod"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ ├○ lexical $module_name :decl(param)
    ║ │     │   ║ ├○ lexical $ext :decl(param) :named("ext")
    ║ │     │   ║ ├○ lexical $with-nqplib :decl(param) :named("with-nqplib") :default(WVal NQPMu)
    ║ │     │   ║ ├○ lexical $loader :decl(var)
    ║ │     │   ║ └○ lexical @module_paths :decl(var)
    ║ │     │   ╙─:Stmts  ««"\n            my $loader := nqp::getcurhllsym('Modu"...
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$loader := nqp::getcurhllsym('ModuleLoader')"
    ║ │     │     │   ├○ lexical $loader
    ║ │     │     │   └─getcurhllsym  ««"nqp::getcurhllsym('ModuleLoader')"
    ║ │     │     │     └◙ SVal "ModuleLoader"
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@module_paths := $loader.search_path('module-path')"
    ║ │     │     │   ├○ lexical @module_paths
    ║ │     │     │   └─callmethod search_path  ««"'module-path'"
    ║ │     │     │     ├○ lexical $loader
    ║ │     │     │     └◙ SVal "module-path"
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─if  ««"$with-nqplib {\n                @module_paths.unshi"...
    ║ │     │     │   ├○ lexical $with-nqplib
    ║ │     │     │   └─:Stmts  ««"{\n                @module_paths.unshift(nqp::backe"...
    ║ │     │     │     ├─:Stmts
    ║ │     │     │     └─:Stmts  ««"\n                @module_paths.unshift(nqp::backen"...
    ║ │     │     │       └─:Stmts
    ║ │     │     │         └─callmethod unshift  ««"nqp::backendconfig()<prefix> ~ '/languages/nqp/lib'"
    ║ │     │     │           ├○ lexical @module_paths
    ║ │     │     │           └─concat &infix:<~>  ««"~"
    ║ │     │     │             ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     │             │ ├─backendconfig  ««"nqp::backendconfig()"
    ║ │     │     │             │ └◙ SVal "prefix"
    ║ │     │     │             └◙ SVal "/languages/nqp/lib"
    ║ │     │     └─:Stmts
    ║ │     │       └─callmethod find_file  ««"$module_name, @module_paths, :$ext"
    ║ │     │         ├─decont
    ║ │     │         │ └○ lexical self
    ║ │     │         ├○ lexical $module_name
    ║ │     │         ├○ lexical @module_paths
    ║ │     │         └○ lexical $ext :named("ext")
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        my $out;\n        my $src_path := self.f"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ ├○ lexical $module_name :decl(param)
    ║ │     │   ║ ├○ lexical @on_behalf :decl(param)
    ║ │     │   ║ ├─bind  ««"$out"
    ║ │     │   ║ │ ├○ lexical $out :decl(var)
    ║ │     │   ║ │ └◙ WVal NQPMu
    ║ │     │   ║ └○ lexical $src_path :decl(var)
    ║ │     │   ╙─lexotic RETURN
    ║ │     │     └─:Stmts  ««"\n        my $out;\n        my $src_path := self.fi"...
    ║ │     │       ├─:Stmts
    ║ │     │       │ └○ lexical $out
    ║ │     │       ├─:Stmts
    ║ │     │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$src_path := self.find_src($module_name, :ext<nqp>)"
    ║ │     │       │   ├○ lexical $src_path
    ║ │     │       │   └─callmethod find_src  ««"$module_name, :ext<nqp>"
    ║ │     │       │     ├─decont
    ║ │     │       │     │ └○ lexical self
    ║ │     │       │     ├○ lexical $module_name
    ║ │     │       │     └◙ SVal "nqp" :named("ext")
    ║ │     │       └─:Stmts
    ║ │     │         └─if  ««"$src_path {\n            my $bc_path := self.find_b"...
    ║ │     │           ├○ lexical $src_path
    ║ │     │           ├─:Block :blocktype(immediate)  ««"{\n            my $bc_path := self.find_bytecode($m"...
    ║ │     │           │ ╟─:Stmts
    ║ │     │           │ ║ ├○ lexical $bc_path :decl(var)
    ║ │     │           │ ║ └○ lexical $clone :decl(var)
    ║ │     │           │ ╙─:Stmts  ««"\n            my $bc_path := self.find_bytecode($mo"...
    ║ │     │           │   ├─:Stmts
    ║ │     │           │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$bc_path := self.find_bytecode($module_name, :ext<m"...
    ║ │     │           │   │   ├○ lexical $bc_path
    ║ │     │           │   │   └─callmethod find_bytecode  ««"$module_name, :ext<moarvm>"
    ║ │     │           │   │     ├─decont
    ║ │     │           │   │     │ └○ lexical self
    ║ │     │           │   │     ├○ lexical $module_name
    ║ │     │           │   │     └◙ SVal "moarvm" :named("ext")
    ║ │     │           │   ├─:Stmts
    ║ │     │           │   │ └─if  ««"$bc_path {\n                my $src_time := nqp::st"...
    ║ │     │           │   │   ├○ lexical $bc_path
    ║ │     │           │   │   └─:Block :blocktype(immediate)  ««"{\n                my $src_time := nqp::stat($src_p"...
    ║ │     │           │   │     ╟─:Stmts
    ║ │     │           │   │     ║ ├○ lexical $src_time :decl(var)
    ║ │     │           │   │     ║ └○ lexical $bc_time :decl(var)
    ║ │     │           │   │     ╙─:Stmts  ««"\n                my $src_time := nqp::stat($src_pa"...
    ║ │     │           │   │       ├─:Stmts
    ║ │     │           │   │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$src_time := nqp::stat($src_path, nqp::const::STAT_"...
    ║ │     │           │   │       │   ├○ lexical $src_time
    ║ │     │           │   │       │   └─stat  ««"nqp::stat($src_path, nqp::const::STAT_MODIFYTIME)"
    ║ │     │           │   │       │     ├○ lexical $src_path
    ║ │     │           │   │       │     └─const STAT_MODIFYTIME
    ║ │     │           │   │       ├─:Stmts
    ║ │     │           │   │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$bc_time  := nqp::stat($bc_path,  nqp::const::STAT_"...
    ║ │     │           │   │       │   ├○ lexical $bc_time
    ║ │     │           │   │       │   └─stat  ««"nqp::stat($bc_path,  nqp::const::STAT_MODIFYTIME)"
    ║ │     │           │   │       │     ├○ lexical $bc_path
    ║ │     │           │   │       │     └─const STAT_MODIFYTIME
    ║ │     │           │   │       └─:Stmts
    ║ │     │           │   │         └─if  ««"$src_time < $bc_time {\n                    return "...
    ║ │     │           │   │           ├─islt_n &infix:<<>  ««"<"
    ║ │     │           │   │           │ ├○ lexical $src_time
    ║ │     │           │   │           │ └○ lexical $bc_time
    ║ │     │           │   │           └─:Stmts  ««"{\n                    return $bc_path; # up-to-dat"...
    ║ │     │           │   │             ├─:Stmts
    ║ │     │           │   │             └─:Stmts  ««"\n                    return $bc_path; # up-to-date"...
    ║ │     │           │   │               └─:Stmts
    ║ │     │           │   │                 └─call RETURN
    ║ │     │           │   │                   └○ lexical $bc_path
    ║ │     │           │   ├─:Stmts
    ║ │     │           │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$clone := nqp::clone(self)"
    ║ │     │           │   │   ├○ lexical $clone
    ║ │     │           │   │   └─clone  ««"nqp::clone(self)"
    ║ │     │           │   │     └─decont
    ║ │     │           │   │       └○ lexical self
    ║ │     │           │   └─:Stmts
    ║ │     │           │     └─call RETURN
    ║ │     │           │       └─callmethod compileFile  ««"$src_path, :target<mbc>"
    ║ │     │           │         ├○ lexical $clone
    ║ │     │           │         ├○ lexical $src_path
    ║ │     │           │         └◙ SVal "mbc" :named("target")
    ║ │     │           └─:Stmts  ««"{ # no src file, so maybe it's a module from the NQ"...
    ║ │     │             ├─:Stmts
    ║ │     │             └─:Stmts  ««" # no src file, so maybe it's a module from the NQP"...
    ║ │     │               └─:Stmts
    ║ │     │                 └─call RETURN
    ║ │     │                   └─callmethod find_bytecode  ««"$module_name, :ext<moarvm>, :with-nqplib"
    ║ │     │                     ├─decont
    ║ │     │                     │ └○ lexical self
    ║ │     │                     ├○ lexical $module_name
    ║ │     │                     ├◙ SVal "moarvm" :named("ext")
    ║ │     │                     └◙ IVal 1 :named("with-nqplib")
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        my %results := {};\n        my sub doit("...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ ├○ lexical $node :decl(param)
    ║ │     │   ║ ├○ lexical %results :decl(var)
    ║ │     │   ║ └─bind
    ║ │     │   ║   ├○ lexical &doit :decl(var)
    ║ │     │   ║   └─:Block  ««"{\n            nqp::die(\"collect_stats expects a Q"...
    ║ │     │   ║     ╟─:Stmts
    ║ │     │   ║     ║ ├○ lexical $node :decl(param)
    ║ │     │   ║     ║ └○ lexical $HOWname :decl(var)
    ║ │     │   ║     ╙─:Stmts  ««"\n            nqp::die(\"collect_stats expects a QA"...
    ║ │     │   ║       ├─:Stmts
    ║ │     │   ║       │ └─unless  ««"nqp::die(\"collect_stats expects a QAST::Node - got"...
    ║ │     │   ║       │   ├─call &istype  ««"$node, QAST::Node"
    ║ │     │   ║       │   │ ├○ lexical $node
    ║ │     │   ║       │   │ └◙ WVal QAST::Node
    ║ │     │   ║       │   └─die  ««"nqp::die(\"collect_stats expects a QAST::Node - got"...
    ║ │     │   ║       │     └─concat &infix:<~>  ««"~"
    ║ │     │   ║       │       ├◙ SVal "collect_stats expects a QAST::Node - got "
    ║ │     │   ║       │       └─call &describe  ««"$node"
    ║ │     │   ║       │         └○ lexical $node
    ║ │     │   ║       ├─:Stmts
    ║ │     │   ║       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$HOWname := $node.HOW.name($node)"
    ║ │     │   ║       │   ├○ lexical $HOWname
    ║ │     │   ║       │   └─callmethod name  ««"$node"
    ║ │     │   ║       │     ├─how  ««".HOW"
    ║ │     │   ║       │     │ └○ lexical $node
    ║ │     │   ║       │     └○ lexical $node
    ║ │     │   ║       ├─:Stmts
    ║ │     │   ║       │ └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │   └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │     ├○ lexical %results
    ║ │     │   ║       │     └◙ SVal "Node"
    ║ │     │   ║       ├─:Stmts
    ║ │     │   ║       │ └─if  ««"istype($node, QAST::Block) {\n                %resu"...
    ║ │     │   ║       │   ├─call &istype  ««"$node, QAST::Block"
    ║ │     │   ║       │   │ ├○ lexical $node
    ║ │     │   ║       │   │ └◙ WVal QAST::Block
    ║ │     │   ║       │   ├─:Stmts  ««"{\n                %results<Block>++;\n            }"
    ║ │     │   ║       │   │ ├─:Stmts
    ║ │     │   ║       │   │ └─:Stmts  ««"\n                %results<Block>++;\n            "
    ║ │     │   ║       │   │   └─:Stmts
    ║ │     │   ║       │   │     └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │   │       └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │   │         ├○ lexical %results
    ║ │     │   ║       │   │         └◙ SVal "Block"
    ║ │     │   ║       │   └─if  ««"istype($node, QAST::Stmt, QAST::Stmts) {\n         "...
    ║ │     │   ║       │     ├─call &istype  ««"$node, QAST::Stmt, QAST::Stmts"
    ║ │     │   ║       │     │ ├○ lexical $node
    ║ │     │   ║       │     │ ├◙ WVal QAST::Stmt
    ║ │     │   ║       │     │ └◙ WVal QAST::Stmts
    ║ │     │   ║       │     ├─:Stmts  ««"{\n                %results<Stmt(s)>++;\n            }"
    ║ │     │   ║       │     │ ├─:Stmts
    ║ │     │   ║       │     │ └─:Stmts  ««"\n                %results<Stmt(s)>++;\n            "
    ║ │     │   ║       │     │   └─:Stmts
    ║ │     │   ║       │     │     └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │     │       └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │     │         ├○ lexical %results
    ║ │     │   ║       │     │         └◙ SVal "Stmt(s)"
    ║ │     │   ║       │     └─if  ««"istype($node, QAST::Op) {\n                my $op :"...
    ║ │     │   ║       │       ├─call &istype  ««"$node, QAST::Op"
    ║ │     │   ║       │       │ ├○ lexical $node
    ║ │     │   ║       │       │ └◙ WVal QAST::Op
    ║ │     │   ║       │       ├─:Block :blocktype(immediate)  ««"{\n                my $op := $node.op;\n    #      "...
    ║ │     │   ║       │       │ ╟─:Stmts
    ║ │     │   ║       │       │ ║ └○ lexical $op :decl(var)
    ║ │     │   ║       │       │ ╙─:Stmts  ««"\n                my $op := $node.op;\n    #       "...
    ║ │     │   ║       │       │   ├─:Stmts
    ║ │     │   ║       │       │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$op := $node.op"
    ║ │     │   ║       │       │   │   ├○ lexical $op
    ║ │     │   ║       │       │   │   └─callmethod op  ««".op"
    ║ │     │   ║       │       │   │     └○ lexical $node
    ║ │     │   ║       │       │   ├─:Stmts
    ║ │     │   ║       │       │   │ └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │       │   │   └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │       │   │     ├○ lexical %results
    ║ │     │   ║       │       │   │     └◙ SVal "op"
    ║ │     │   ║       │       │   ├─:Stmts
    ║ │     │   ║       │       │   │ └─if  ««"%results<list>++        if  $op eq 'list'"
    ║ │     │   ║       │       │   │   ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   ║       │       │   │   │ ├○ lexical $op
    ║ │     │   ║       │       │   │   │ └◙ SVal "list"
    ║ │     │   ║       │       │   │   └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │       │   │     └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │       │   │       ├○ lexical %results
    ║ │     │   ║       │       │   │       └◙ SVal "list"
    ║ │     │   ║       │       │   ├─:Stmts
    ║ │     │   ║       │       │   │ └─if  ««"%results<hash>++        if  $op eq 'hash'"
    ║ │     │   ║       │       │   │   ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   ║       │       │   │   │ ├○ lexical $op
    ║ │     │   ║       │       │   │   │ └◙ SVal "hash"
    ║ │     │   ║       │       │   │   └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │       │   │     └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │       │   │       ├○ lexical %results
    ║ │     │   ║       │       │   │       └◙ SVal "hash"
    ║ │     │   ║       │       │   ├─:Stmts
    ║ │     │   ║       │       │   │ └─if  ««"%results<bind>++        if  $op eq 'bind'"
    ║ │     │   ║       │       │   │   ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   ║       │       │   │   │ ├○ lexical $op
    ║ │     │   ║       │       │   │   │ └◙ SVal "bind"
    ║ │     │   ║       │       │   │   └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │       │   │     └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │       │   │       ├○ lexical %results
    ║ │     │   ║       │       │   │       └◙ SVal "bind"
    ║ │     │   ║       │       │   ├─:Stmts
    ║ │     │   ║       │       │   │ └─if  ««"%results<call>++        if  $op eq 'call'"
    ║ │     │   ║       │       │   │   ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   ║       │       │   │   │ ├○ lexical $op
    ║ │     │   ║       │       │   │   │ └◙ SVal "call"
    ║ │     │   ║       │       │   │   └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │       │   │     └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │       │   │       ├○ lexical %results
    ║ │     │   ║       │       │   │       └◙ SVal "call"
    ║ │     │   ║       │       │   ├─:Stmts
    ║ │     │   ║       │       │   │ └─if  ««"%results<callstatic>++  if  $op eq 'callstatic'"
    ║ │     │   ║       │       │   │   ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   ║       │       │   │   │ ├○ lexical $op
    ║ │     │   ║       │       │   │   │ └◙ SVal "callstatic"
    ║ │     │   ║       │       │   │   └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │       │   │     └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │       │   │       ├○ lexical %results
    ║ │     │   ║       │       │   │       └◙ SVal "callstatic"
    ║ │     │   ║       │       │   ├─:Stmts
    ║ │     │   ║       │       │   │ └─if  ««"%results<callmethod>++  if  $op eq 'callmethod'"
    ║ │     │   ║       │       │   │   ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   ║       │       │   │   │ ├○ lexical $op
    ║ │     │   ║       │       │   │   │ └◙ SVal "callmethod"
    ║ │     │   ║       │       │   │   └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │       │   │     └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │       │   │       ├○ lexical %results
    ║ │     │   ║       │       │   │       └◙ SVal "callmethod"
    ║ │     │   ║       │       │   └─:Stmts
    ║ │     │   ║       │       │     └─if  ««"%results<takeclosure>++ if  $op eq 'takeclosure'"
    ║ │     │   ║       │       │       ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   ║       │       │       │ ├○ lexical $op
    ║ │     │   ║       │       │       │ └◙ SVal "takeclosure"
    ║ │     │   ║       │       │       └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │       │         └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │       │           ├○ lexical %results
    ║ │     │   ║       │       │           └◙ SVal "takeclosure"
    ║ │     │   ║       │       └─if  ««"istype($node, QAST::Var) {\n                %result"...
    ║ │     │   ║       │         ├─call &istype  ««"$node, QAST::Var"
    ║ │     │   ║       │         │ ├○ lexical $node
    ║ │     │   ║       │         │ └◙ WVal QAST::Var
    ║ │     │   ║       │         ├─:Stmts  ««"{\n                %results<Var>++;\n            }"
    ║ │     │   ║       │         │ ├─:Stmts
    ║ │     │   ║       │         │ └─:Stmts  ««"\n                %results<Var>++;\n            "
    ║ │     │   ║       │         │   └─:Stmts
    ║ │     │   ║       │         │     └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │         │       └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │         │         ├○ lexical %results
    ║ │     │   ║       │         │         └◙ SVal "Var"
    ║ │     │   ║       │         └─if  ««"istype($node, QAST::IVal) {\n                %resul"...
    ║ │     │   ║       │           ├─call &istype  ««"$node, QAST::IVal"
    ║ │     │   ║       │           │ ├○ lexical $node
    ║ │     │   ║       │           │ └◙ WVal QAST::IVal
    ║ │     │   ║       │           ├─:Stmts  ««"{\n                %results<IVal>++;\n            }"
    ║ │     │   ║       │           │ ├─:Stmts
    ║ │     │   ║       │           │ └─:Stmts  ««"\n                %results<IVal>++;\n            "
    ║ │     │   ║       │           │   └─:Stmts
    ║ │     │   ║       │           │     └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │           │       └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │           │         ├○ lexical %results
    ║ │     │   ║       │           │         └◙ SVal "IVal"
    ║ │     │   ║       │           └─if  ««"istype($node, QAST::NVal) {\n                %resul"...
    ║ │     │   ║       │             ├─call &istype  ««"$node, QAST::NVal"
    ║ │     │   ║       │             │ ├○ lexical $node
    ║ │     │   ║       │             │ └◙ WVal QAST::NVal
    ║ │     │   ║       │             ├─:Stmts  ««"{\n                %results<NVal>++;\n            }"
    ║ │     │   ║       │             │ ├─:Stmts
    ║ │     │   ║       │             │ └─:Stmts  ««"\n                %results<NVal>++;\n            "
    ║ │     │   ║       │             │   └─:Stmts
    ║ │     │   ║       │             │     └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │             │       └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │             │         ├○ lexical %results
    ║ │     │   ║       │             │         └◙ SVal "NVal"
    ║ │     │   ║       │             └─if  ««"istype($node, QAST::SVal) {\n                %resul"...
    ║ │     │   ║       │               ├─call &istype  ««"$node, QAST::SVal"
    ║ │     │   ║       │               │ ├○ lexical $node
    ║ │     │   ║       │               │ └◙ WVal QAST::SVal
    ║ │     │   ║       │               └─:Stmts  ««"{\n                %results<SVal>++;\n             "...
    ║ │     │   ║       │                 ├─:Stmts
    ║ │     │   ║       │                 └─:Stmts  ««"\n                %results<SVal>++;\n              "...
    ║ │     │   ║       │                   ├─:Stmts
    ║ │     │   ║       │                   │ └─postinc &postfix:<++>  ««"++"
    ║ │     │   ║       │                   │   └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │                   │     ├○ lexical %results
    ║ │     │   ║       │                   │     └◙ SVal "SVal"
    ║ │     │   ║       │                   └─:Stmts
    ║ │     │   ║       │                     └─bind &infix:<:=>  ««":="
    ║ │     │   ║       │                       ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │                       │ ├○ lexical %results
    ║ │     │   ║       │                       │ └◙ SVal "SValChars"
    ║ │     │   ║       │                       └─add_n &infix:<+>  ««"+"
    ║ │     │   ║       │                         ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │   ║       │                         │ ├○ lexical %results
    ║ │     │   ║       │                         │ └◙ SVal "SValChars"
    ║ │     │   ║       │                         └─chars  ««"nqp::chars($node.value)"
    ║ │     │   ║       │                           └─callmethod value  ««".value"
    ║ │     │   ║       │                             └○ lexical $node
    ║ │     │   ║       └─:Stmts
    ║ │     │   ║         └─for  ««"$node.list {\n                doit($_);\n            }"
    ║ │     │   ║           ├─callmethod list  ««".list"
    ║ │     │   ║           │ └○ lexical $node
    ║ │     │   ║           ├─:Block :blocktype(immediate)  ««"{\n                doit($_);\n            }"
    ║ │     │   ║           │ ╟─:Stmts
    ║ │     │   ║           │ ║ └○ lexical $_ :decl(param)
    ║ │     │   ║           │ ╙─:Stmts  ««"\n                doit($_);\n            "
    ║ │     │   ║           │   └─:Stmts
    ║ │     │   ║           │     └─call &doit  ««"$_"
    ║ │     │   ║           │       └○ lexical $_
    ║ │     │   ║           └◙ IVal 1 :named("nohandler")
    ║ │     │   ╙─:Stmts  ««"\n        my %results := {};\n        my sub doit($"...
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"%results := {}"
    ║ │     │     │   ├○ lexical %results
    ║ │     │     │   └─hash
    ║ │     │     ├─:Stmts
    ║ │     │     │ └○ lexical &doit
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─call &doit  ««"$node"
    ║ │     │     │   └○ lexical $node
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind &infix:<:=>  ««":="
    ║ │     │     │   ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     │   │ ├○ lexical %results
    ║ │     │     │   │ └◙ SVal "callish"
    ║ │     │     │   └─add_n &infix:<+>  ««"+"
    ║ │     │     │     ├─add_n &infix:<+>  ««"+"
    ║ │     │     │     │ ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     │     │ │ ├○ lexical %results
    ║ │     │     │     │ │ └◙ SVal "call"
    ║ │     │     │     │ └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     │     │   ├○ lexical %results
    ║ │     │     │     │   └◙ SVal "callstatic"
    ║ │     │     │     └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     │       ├○ lexical %results
    ║ │     │     │       └◙ SVal "callmethod"
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind &infix:<:=>  ««":="
    ║ │     │     │   ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     │   │ ├○ lexical %results
    ║ │     │     │   │ └◙ SVal "val"
    ║ │     │     │   └─add_n &infix:<+>  ««"+"
    ║ │     │     │     ├─add_n &infix:<+>  ««"+"
    ║ │     │     │     │ ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     │     │ │ ├○ lexical %results
    ║ │     │     │     │ │ └◙ SVal "IVal"
    ║ │     │     │     │ └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     │     │   ├○ lexical %results
    ║ │     │     │     │   └◙ SVal "NVal"
    ║ │     │     │     └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     │       ├○ lexical %results
    ║ │     │     │       └◙ SVal "SVal"
    ║ │     │     └─:Stmts
    ║ │     │       └○ lexical %results
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        my $ast := $source.ast();\n        self."...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ ├○ lexical $source :decl(param)
    ║ │     │   ║ ├○ lexical %adverbs :decl(param) :named(1) :slurpy(1)
    ║ │     │   ║ └○ lexical $ast :decl(var)
    ║ │     │   ╙─:Stmts  ««"\n        my $ast := $source.ast();\n        self.p"...
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$ast := $source.ast()"
    ║ │     │     │   ├○ lexical $ast
    ║ │     │     │   └─callmethod ast  ««""
    ║ │     │     │     └○ lexical $source
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─unless  ««"self.panic(\"Unable to obtain AST from \" ~ $source"...
    ║ │     │     │   ├─callmethod ACCEPTS  ««"~~"
    ║ │     │     │   │ ├◙ WVal QAST::Node
    ║ │     │     │   │ └○ lexical $ast
    ║ │     │     │   └─callmethod panic  ««"\"Unable to obtain AST from \" ~ $source.HOW.name($"...
    ║ │     │     │     ├─decont
    ║ │     │     │     │ └○ lexical self
    ║ │     │     │     └─concat &infix:<~>  ««"~"
    ║ │     │     │       ├◙ SVal "Unable to obtain AST from "
    ║ │     │     │       └─callmethod name  ««"$source"
    ║ │     │     │         ├─how  ««".HOW"
    ║ │     │     │         │ └○ lexical $source
    ║ │     │     │         └○ lexical $source
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─callmethod mixin  ««"$ast, StrByDump"
    ║ │     │     │   ├─how  ««".HOW"
    ║ │     │     │   │ └○ lexical $ast
    ║ │     │     │   ├○ lexical $ast
    ║ │     │     │   └◙ WVal StrByDump
    ║ │     │     └─:Stmts
    ║ │     │       └○ lexical $ast
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        fix_var_attrs($ast);\n    }"
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ └○ lexical $ast :decl(param)
    ║ │     │   ╙─:Stmts  ««"\n        fix_var_attrs($ast);\n    "
    ║ │     │     └─:Stmts
    ║ │     │       └─call &fix_var_attrs  ««"$ast"
    ║ │     │         └○ lexical $ast
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        self.log('ast_clean: ', self.user-progna"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ ├○ lexical $ast :decl(param)
    ║ │     │   ║ ├○ lexical %adverbs :decl(param) :named(1) :slurpy(1)
    ║ │     │   ║ └─bind  ««"@inlinecandidates"
    ║ │     │   ║   ├○ lexical @inlinecandidates :decl(var)
    ║ │     │   ║   └─list
    ║ │     │   ╙─:Stmts  ««"\n        self.log('ast_clean: ', self.user-prognam"...
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─callmethod log  ««"'ast_clean: ', self.user-progname, '...'"
    ║ │     │     │   ├─decont
    ║ │     │     │   │ └○ lexical self
    ║ │     │     │   ├◙ SVal "ast_clean: "
    ║ │     │     │   ├─callmethod user-progname  ««".user-progname"
    ║ │     │     │   │ └─decont
    ║ │     │     │   │   └○ lexical self
    ║ │     │     │   └◙ SVal "..."
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind &infix:<:=>  ««":="
    ║ │     │     │   ├○ lexical $ast
    ║ │     │     │   └─call &drop_takeclosure  ««"$ast"
    ║ │     │     │     └○ lexical $ast
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind &infix:<:=>  ««":="
    ║ │     │     │   ├○ lexical $ast
    ║ │     │     │   └─call &drop_Stmts  ««"$ast"
    ║ │     │     │     └○ lexical $ast
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind &infix:<:=>  ««":="
    ║ │     │     │   ├○ lexical $ast
    ║ │     │     │   └─call &drop_bogusVars  ««"$ast"
    ║ │     │     │     └○ lexical $ast
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind &infix:<:=>  ««":="
    ║ │     │     │   ├○ lexical $ast
    ║ │     │     │   └─call &remove_bogusOpNames  ««"$ast"
    ║ │     │     │     └○ lexical $ast
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind &infix:<:=>  ««":="
    ║ │     │     │   ├○ lexical $ast
    ║ │     │     │   └─call &replace_assoc_and_pos_scoped  ««"$ast"
    ║ │     │     │     └○ lexical $ast
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind &infix:<:=>  ««":="
    ║ │     │     │   ├○ lexical $ast
    ║ │     │     │   └─call &inline_simple_methods  ««"$ast"
    ║ │     │     │     └○ lexical $ast
    ║ │     │     ├─:Stmts
    ║ │     │     │ └○ lexical @inlinecandidates
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind &infix:<:=>  ««":="
    ║ │     │     │   ├○ lexical @inlinecandidates
    ║ │     │     │   └─call &findDefs  ««"$ast, -> $var, @pathUp {\n               (nqp::inde"...
    ║ │     │     │     ├○ lexical $ast
    ║ │     │     │     └─takeclosure
    ║ │     │     │       └─:Block  ««"{\n               (nqp::index($var.name, '&STATS_')"...
    ║ │     │     │         ╟─:Stmts
    ║ │     │     │         ║ ├○ lexical $var :decl(param)
    ║ │     │     │         ║ └○ lexical @pathUp :decl(param)
    ║ │     │     │         ╙─:Stmts  ««"\n               (nqp::index($var.name, '&STATS_') "...
    ║ │     │     │           └─:Stmts
    ║ │     │     │             └─unless &infix:<||>  ««"||"
    ║ │     │     │               ├─unless &infix:<||>  ««"||"
    ║ │     │     │               │ ├─isgt_n &infix:<>>  ««">"
    ║ │     │     │               │ │ ├─index  ««"nqp::index($var.name, '&STATS_')"
    ║ │     │     │               │ │ │ ├─callmethod name  ««".name"
    ║ │     │     │               │ │ │ │ └○ lexical $var
    ║ │     │     │               │ │ │ └◙ SVal "&STATS_"
    ║ │     │     │               │ │ └◙ IVal -1
    ║ │     │     │               │ └─isgt_n &infix:<>>  ««">"
    ║ │     │     │               │   ├─index  ««"nqp::index($var.name, '&LAMFIELD_')"
    ║ │     │     │               │   │ ├─callmethod name  ««".name"
    ║ │     │     │               │   │ │ └○ lexical $var
    ║ │     │     │               │   │ └◙ SVal "&LAMFIELD_"
    ║ │     │     │               │   └◙ IVal -1
    ║ │     │     │               └─isgt_n &infix:<>>  ««">"
    ║ │     │     │                 ├─index  ««"nqp::index('&lam2id &lam2code &lam2fvs &int2str &nu"...
    ║ │     │     │                 │ ├◙ SVal "&lam2id &lam2code &lam2fvs &int2str &num2str"
    ║ │     │     │                 │ └─callmethod name  ««".name"
    ║ │     │     │                 │   └○ lexical $var
    ║ │     │     │                 └◙ IVal -1
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind &infix:<:=>  ««":="
    ║ │     │     │   ├○ lexical $ast
    ║ │     │     │   └─call &inline_simple_subs  ««"$ast, @inlinecandidates"
    ║ │     │     │     ├○ lexical $ast
    ║ │     │     │     └○ lexical @inlinecandidates
    ║ │     │     └─:Stmts
    ║ │     │       └○ lexical $ast
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        my %stats := self.collect_stats($ast);\n"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ ├○ lexical $ast :decl(param)
    ║ │     │   ║ ├○ lexical %adverbs :decl(param) :named(1) :slurpy(1)
    ║ │     │   ║ ├○ lexical %stats :decl(var)
    ║ │     │   ║ ├○ lexical @statskeyDefs :decl(var)
    ║ │     │   ║ ├○ lexical @statskeys :decl(var)
    ║ │     │   ║ ├─bind
    ║ │     │   ║ │ ├○ lexical &svalPred :decl(var)
    ║ │     │   ║ │ └─:Block  ««"{\n            -> $node { istype($node, QAST::SVal)"...
    ║ │     │   ║ │   ╟─:Stmts
    ║ │     │   ║ │   ║ └○ lexical $value :decl(param) :default((┬VarWithFallback associative  :decl() :fallback((ifnull) ((atkey) ((who) (WVal GLOBALish)) (SVal "NO_VALUE")) (WVal NQPMu))) ((who) ( lexical $?PACKAGE :decl())) (SVal "NO_VALUE"))
    ║ │     │   ║ │   ╙─:Stmts  ««"\n            -> $node { istype($node, QAST::SVal) "...
    ║ │     │   ║ │     └─:Stmts
    ║ │     │   ║ │       └─takeclosure
    ║ │     │   ║ │         └─:Block  ««"{ istype($node, QAST::SVal) && ($value =:= NO_VALUE"...
    ║ │     │   ║ │           ╟─:Stmts
    ║ │     │   ║ │           ║ └○ lexical $node :decl(param)
    ║ │     │   ║ │           ╙─:Stmts  ««" istype($node, QAST::SVal) && ($value =:= NO_VALUE "...
    ║ │     │   ║ │             └─:Stmts
    ║ │     │   ║ │               └─if &infix:<&&>  ««"&&"
    ║ │     │   ║ │                 ├─call &istype  ««"$node, QAST::SVal"
    ║ │     │   ║ │                 │ ├○ lexical $node
    ║ │     │   ║ │                 │ └◙ WVal QAST::SVal
    ║ │     │   ║ │                 └─unless &infix:<||>  ««"||"
    ║ │     │   ║ │                   ├─eqaddr &infix:<=:=>  ««"=:="
    ║ │     │   ║ │                   │ ├○ lexical $value
    ║ │     │   ║ │                   │ └○┬VarWithFallback associative  :fallback((ifnull) ((atkey) ((who) (WVal GLOBALish)) (SVal "NO_VALUE")) (WVal NQPMu))
    ║ │     │   ║ │                   │   ├─who
    ║ │     │   ║ │                   │   │ └○ lexical $?PACKAGE
    ║ │     │   ║ │                   │   └◙ SVal "NO_VALUE"
    ║ │     │   ║ │                   └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   ║ │                     ├─callmethod value  ««".value"
    ║ │     │   ║ │                     │ └○ lexical $node
    ║ │     │   ║ │                     └○ lexical $value
    ║ │     │   ║ ├─bind
    ║ │     │   ║ │ ├○ lexical &ivalPred :decl(var)
    ║ │     │   ║ │ └─:Block  ««"{\n            -> $node { istype($node, QAST::IVal)"...
    ║ │     │   ║ │   ╟─:Stmts
    ║ │     │   ║ │   ║ └○ lexical $value :decl(param) :default((┬VarWithFallback associative  :decl() :fallback((ifnull) ((atkey) ((who) (WVal GLOBALish)) (SVal "NO_VALUE")) (WVal NQPMu))) ((who) ( lexical $?PACKAGE :decl())) (SVal "NO_VALUE"))
    ║ │     │   ║ │   ╙─:Stmts  ««"\n            -> $node { istype($node, QAST::IVal) "...
    ║ │     │   ║ │     └─:Stmts
    ║ │     │   ║ │       └─takeclosure
    ║ │     │   ║ │         └─:Block  ««"{ istype($node, QAST::IVal) && ($value =:= NO_VALUE"...
    ║ │     │   ║ │           ╟─:Stmts
    ║ │     │   ║ │           ║ └○ lexical $node :decl(param)
    ║ │     │   ║ │           ╙─:Stmts  ««" istype($node, QAST::IVal) && ($value =:= NO_VALUE "...
    ║ │     │   ║ │             └─:Stmts
    ║ │     │   ║ │               └─if &infix:<&&>  ««"&&"
    ║ │     │   ║ │                 ├─call &istype  ««"$node, QAST::IVal"
    ║ │     │   ║ │                 │ ├○ lexical $node
    ║ │     │   ║ │                 │ └◙ WVal QAST::IVal
    ║ │     │   ║ │                 └─unless &infix:<||>  ««"||"
    ║ │     │   ║ │                   ├─eqaddr &infix:<=:=>  ««"=:="
    ║ │     │   ║ │                   │ ├○ lexical $value
    ║ │     │   ║ │                   │ └○┬VarWithFallback associative  :fallback((ifnull) ((atkey) ((who) (WVal GLOBALish)) (SVal "NO_VALUE")) (WVal NQPMu))
    ║ │     │   ║ │                   │   ├─who
    ║ │     │   ║ │                   │   │ └○ lexical $?PACKAGE
    ║ │     │   ║ │                   │   └◙ SVal "NO_VALUE"
    ║ │     │   ║ │                   └─iseq_n &infix:<==>  ««"=="
    ║ │     │   ║ │                     ├─callmethod value  ««".value"
    ║ │     │   ║ │                     │ └○ lexical $node
    ║ │     │   ║ │                     └○ lexical $value
    ║ │     │   ║ ├─bind
    ║ │     │   ║ │ ├○ lexical &opPred :decl(var)
    ║ │     │   ║ │ └─:Block  ««"{\n            -> $node { istype($node, QAST::Op) &"...
    ║ │     │   ║ │   ╟─:Stmts
    ║ │     │   ║ │   ║ └○ lexical $op :decl(param) :default((┬VarWithFallback associative  :decl() :fallback((ifnull) ((atkey) ((who) (WVal GLOBALish)) (SVal "NO_VALUE")) (WVal NQPMu))) ((who) ( lexical $?PACKAGE :decl())) (SVal "NO_VALUE"))
    ║ │     │   ║ │   ╙─:Stmts  ««"\n            -> $node { istype($node, QAST::Op) &&"...
    ║ │     │   ║ │     └─:Stmts
    ║ │     │   ║ │       └─takeclosure
    ║ │     │   ║ │         └─:Block  ««"{ istype($node, QAST::Op) && ($op =:= NO_VALUE || $"...
    ║ │     │   ║ │           ╟─:Stmts
    ║ │     │   ║ │           ║ └○ lexical $node :decl(param)
    ║ │     │   ║ │           ╙─:Stmts  ««" istype($node, QAST::Op) && ($op =:= NO_VALUE || $n"...
    ║ │     │   ║ │             └─:Stmts
    ║ │     │   ║ │               └─if &infix:<&&>  ««"&&"
    ║ │     │   ║ │                 ├─call &istype  ««"$node, QAST::Op"
    ║ │     │   ║ │                 │ ├○ lexical $node
    ║ │     │   ║ │                 │ └◙ WVal QAST::Op
    ║ │     │   ║ │                 └─unless &infix:<||>  ««"||"
    ║ │     │   ║ │                   ├─eqaddr &infix:<=:=>  ««"=:="
    ║ │     │   ║ │                   │ ├○ lexical $op
    ║ │     │   ║ │                   │ └○┬VarWithFallback associative  :fallback((ifnull) ((atkey) ((who) (WVal GLOBALish)) (SVal "NO_VALUE")) (WVal NQPMu))
    ║ │     │   ║ │                   │   ├─who
    ║ │     │   ║ │                   │   │ └○ lexical $?PACKAGE
    ║ │     │   ║ │                   │   └◙ SVal "NO_VALUE"
    ║ │     │   ║ │                   └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │   ║ │                     ├─callmethod op  ««".op"
    ║ │     │   ║ │                     │ └○ lexical $node
    ║ │     │   ║ │                     └○ lexical $op
    ║ │     │   ║ ├○ lexical $findStatsHash :decl(var)
    ║ │     │   ║ ├○ lexical $infoHashDef :decl(var)
    ║ │     │   ║ └○ lexical $infoHash :decl(var)
    ║ │     │   ╙─:Stmts  ««"\n        my %stats := self.collect_stats($ast);\n\"...
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"%stats := self.collect_stats($ast)"
    ║ │     │     │   ├○ lexical %stats
    ║ │     │     │   └─callmethod collect_stats  ««"$ast"
    ║ │     │     │     ├─decont
    ║ │     │     │     │ └○ lexical self
    ║ │     │     │     └○ lexical $ast
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@statskeyDefs := findDefs($ast, -> $var, @pathUp {\"...
    ║ │     │     │   ├○ lexical @statskeyDefs
    ║ │     │     │   └─call &findDefs  ««"$ast, -> $var, @pathUp {\n            nqp::index($v"...
    ║ │     │     │     ├○ lexical $ast
    ║ │     │     │     └─takeclosure
    ║ │     │     │       └─:Block  ««"{\n            nqp::index($var.name, 'STATS_') > -1"...
    ║ │     │     │         ╟─:Stmts
    ║ │     │     │         ║ ├○ lexical $var :decl(param)
    ║ │     │     │         ║ └○ lexical @pathUp :decl(param)
    ║ │     │     │         ╙─:Stmts  ««"\n            nqp::index($var.name, 'STATS_') > -1;"...
    ║ │     │     │           └─:Stmts
    ║ │     │     │             └─isgt_n &infix:<>>  ««">"
    ║ │     │     │               ├─index  ««"nqp::index($var.name, 'STATS_')"
    ║ │     │     │               │ ├─callmethod name  ««".name"
    ║ │     │     │               │ │ └○ lexical $var
    ║ │     │     │               │ └◙ SVal "STATS_"
    ║ │     │     │               └◙ IVal -1
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@statskeys := []"
    ║ │     │     │   ├○ lexical @statskeys
    ║ │     │     │   └─list &circumfix:<[ ]>
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─for  ««"@statskeyDefs {\n            my $v := $_[1][0];\n  "...
    ║ │     │     │   ├○ lexical @statskeyDefs
    ║ │     │     │   ├─:Block :blocktype(immediate)  ««"{\n            my $v := $_[1][0];\n            if i"...
    ║ │     │     │   │ ╟─:Stmts
    ║ │     │     │   │ ║ ├○ lexical $v :decl(var)
    ║ │     │     │   │ ║ └○ lexical $_ :decl(param)
    ║ │     │     │   │ ╙─:Stmts  ««"\n            my $v := $_[1][0];\n            if is"...
    ║ │     │     │   │   ├─:Stmts
    ║ │     │     │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$v := $_[1][0]"
    ║ │     │     │   │   │   ├○ lexical $v
    ║ │     │     │   │   │   └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │     │   │   │     ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │     │   │   │     │ ├○ lexical $_
    ║ │     │     │   │   │     │ └◙ IVal 1
    ║ │     │     │   │   │     └◙ IVal 0
    ║ │     │     │   │   └─:Stmts
    ║ │     │     │   │     └─if  ««"istype($v, QAST::SVal, QAST::IVal, QAST::NVal) {\n "...
    ║ │     │     │   │       ├─call &istype  ««"$v, QAST::SVal, QAST::IVal, QAST::NVal"
    ║ │     │     │   │       │ ├○ lexical $v
    ║ │     │     │   │       │ ├◙ WVal QAST::SVal
    ║ │     │     │   │       │ ├◙ WVal QAST::IVal
    ║ │     │     │   │       │ └◙ WVal QAST::NVal
    ║ │     │     │   │       └─:Stmts  ««"{\n                 @statskeys.push($v.value);\n   "...
    ║ │     │     │   │         ├─:Stmts
    ║ │     │     │   │         └─:Stmts  ««"\n                 @statskeys.push($v.value);\n    "...
    ║ │     │     │   │           └─:Stmts
    ║ │     │     │   │             └─callmethod push  ««"$v.value"
    ║ │     │     │   │               ├○ lexical @statskeys
    ║ │     │     │   │               └─callmethod value  ««".value"
    ║ │     │     │   │                 └○ lexical $v
    ║ │     │     │   └◙ IVal 1 :named("nohandler")
    ║ │     │     ├─:Stmts
    ║ │     │     │ └○ lexical &svalPred
    ║ │     │     ├─:Stmts
    ║ │     │     │ └○ lexical &ivalPred
    ║ │     │     ├─:Stmts
    ║ │     │     │ └○ lexical &opPred
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$findStatsHash := findValueNodeInHash(svalPred('sta"...
    ║ │     │     │   ├○ lexical $findStatsHash
    ║ │     │     │   └─call &findValueNodeInHash  ««"svalPred('stats'), opPred('hash')"
    ║ │     │     │     ├─call &svalPred  ««"'stats'"
    ║ │     │     │     │ └◙ SVal "stats"
    ║ │     │     │     └─call &opPred  ««"'hash'"
    ║ │     │     │       └◙ SVal "hash"
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$infoHashDef := findDef($ast, -> $var, @pathUp {\n "...
    ║ │     │     │   ├○ lexical $infoHashDef
    ║ │     │     │   └─call &findDef  ««"$ast, -> $var, @pathUp {\n            if $var.name "...
    ║ │     │     │     ├○ lexical $ast
    ║ │     │     │     └─takeclosure
    ║ │     │     │       └─:Block  ««"{\n            if $var.name eq '%info' {\n         "...
    ║ │     │     │         ╟─:Stmts
    ║ │     │     │         ║ ├○ lexical $var :decl(param)
    ║ │     │     │         ║ └○ lexical @pathUp :decl(param)
    ║ │     │     │         ╙─:Stmts  ««"\n            if $var.name eq '%info' {\n          "...
    ║ │     │     │           └─:Stmts
    ║ │     │     │             └─if  ««"$var.name eq '%info' {\n                $findStatsH"...
    ║ │     │     │               ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │     │               │ ├─callmethod name  ««".name"
    ║ │     │     │               │ │ └○ lexical $var
    ║ │     │     │               │ └◙ SVal "%info"
    ║ │     │     │               └─:Stmts  ««"{\n                $findStatsHash(@pathUp[0][1]);\n"...
    ║ │     │     │                 ├─:Stmts
    ║ │     │     │                 └─:Stmts  ««"\n                $findStatsHash(@pathUp[0][1]);\n "...
    ║ │     │     │                   └─:Stmts
    ║ │     │     │                     └─call  ««"@pathUp[0][1]"
    ║ │     │     │                       ├○ lexical $findStatsHash
    ║ │     │     │                       └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │     │                         ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │     │                         │ ├○ lexical @pathUp
    ║ │     │     │                         │ └◙ IVal 0
    ║ │     │     │                         └◙ IVal 1
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$infoHash := $findStatsHash($infoHashDef[1])"
    ║ │     │     │   ├○ lexical $infoHash
    ║ │     │     │   └─call  ««"$infoHashDef[1]"
    ║ │     │     │     ├○ lexical $findStatsHash
    ║ │     │     │     └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │     │       ├○ lexical $infoHashDef
    ║ │     │     │       └◙ IVal 1
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─call &say  ««"'>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>' ~ istype($in"...
    ║ │     │     │   └─concat &infix:<~>  ««"~"
    ║ │     │     │     ├◙ SVal ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
    ║ │     │     │     └─call &istype  ««"$infoHash, QAST::Op"
    ║ │     │     │       ├○ lexical $infoHash
    ║ │     │     │       └◙ WVal QAST::Op
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─if  ««"istype($infoHash, QAST::Op) && ($infoHash.op eq 'ha"...
    ║ │     │     │   ├─if &infix:<&&>  ««"&&"
    ║ │     │     │   │ ├─call &istype  ««"$infoHash, QAST::Op"
    ║ │     │     │   │ │ ├○ lexical $infoHash
    ║ │     │     │   │ │ └◙ WVal QAST::Op
    ║ │     │     │   │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │     │     │   │   ├─callmethod op  ««".op"
    ║ │     │     │   │   │ └○ lexical $infoHash
    ║ │     │     │   │   └◙ SVal "hash"
    ║ │     │     │   ├─:Block :blocktype(immediate)  ««"{\n            my $findStatNode := -> $statKey {\n "...
    ║ │     │     │   │ ╟─:Stmts
    ║ │     │     │   │ ║ └○ lexical $findStatNode :decl(var)
    ║ │     │     │   │ ╙─:Stmts  ««"\n            my $findStatNode := -> $statKey {\n  "...
    ║ │     │     │   │   ├─:Stmts
    ║ │     │     │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$findStatNode := -> $statKey {\n                fin"...
    ║ │     │     │   │   │   ├○ lexical $findStatNode
    ║ │     │     │   │   │   └─takeclosure
    ║ │     │     │   │   │     └─:Block  ««"{\n                findValueNodeInHash(svalPred($st"...
    ║ │     │     │   │   │       ╟─:Stmts
    ║ │     │     │   │   │       ║ └○ lexical $statKey :decl(param)
    ║ │     │     │   │   │       ╙─:Stmts  ««"\n                findValueNodeInHash(svalPred($sta"...
    ║ │     │     │   │   │         └─:Stmts
    ║ │     │     │   │   │           └─call &findValueNodeInHash  ««"svalPred($statKey), ivalPred(), $infoHash"
    ║ │     │     │   │   │             ├─call &svalPred  ««"$statKey"
    ║ │     │     │   │   │             │ └○ lexical $statKey
    ║ │     │     │   │   │             ├─call &ivalPred  ««""
    ║ │     │     │   │   │             └○ lexical $infoHash
    ║ │     │     │   │   ├─:Stmts
    ║ │     │     │   │   │ └─for  ««"@statskeys {\n                my $node := $findStat"...
    ║ │     │     │   │   │   ├○ lexical @statskeys
    ║ │     │     │   │   │   ├─:Block :blocktype(immediate)  ««"{\n                my $node := $findStatNode($_);\n"...
    ║ │     │     │   │   │   │ ╟─:Stmts
    ║ │     │     │   │   │   │ ║ ├○ lexical $node :decl(var)
    ║ │     │     │   │   │   │ ║ └○ lexical $_ :decl(param)
    ║ │     │     │   │   │   │ ╙─:Stmts  ««"\n                my $node := $findStatNode($_);\n "...
    ║ │     │     │   │   │   │   ├─:Stmts
    ║ │     │     │   │   │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$node := $findStatNode($_)"
    ║ │     │     │   │   │   │   │   ├○ lexical $node
    ║ │     │     │   │   │   │   │   └─call  ««"$_"
    ║ │     │     │   │   │   │   │     ├○ lexical $findStatNode
    ║ │     │     │   │   │   │   │     └○ lexical $_
    ║ │     │     │   │   │   │   └─:Stmts
    ║ │     │     │   │   │   │     └─if  ««"$node && nqp::existskey(%stats, $_) {\n            "...
    ║ │     │     │   │   │   │       ├─if &infix:<&&>  ««"&&"
    ║ │     │     │   │   │   │       │ ├○ lexical $node
    ║ │     │     │   │   │   │       │ └─existskey  ««"nqp::existskey(%stats, $_)"
    ║ │     │     │   │   │   │       │   ├○ lexical %stats
    ║ │     │     │   │   │   │       │   └○ lexical $_
    ║ │     │     │   │   │   │       └─:Stmts  ««"{\n                    $node.value(%stats{$_});\n# "...
    ║ │     │     │   │   │   │         ├─:Stmts
    ║ │     │     │   │   │   │         └─:Stmts  ««"\n                    $node.value(%stats{$_});\n#  "...
    ║ │     │     │   │   │   │           └─:Stmts
    ║ │     │     │   │   │   │             └─callmethod value  ««"%stats{$_}"
    ║ │     │     │   │   │   │               ├○ lexical $node
    ║ │     │     │   │   │   │               └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │     │   │   │   │                 ├○ lexical %stats
    ║ │     │     │   │   │   │                 └○ lexical $_
    ║ │     │     │   │   │   └◙ IVal 1 :named("nohandler")
    ║ │     │     │   │   └─:Stmts
    ║ │     │     │   │     └─call &say  ««"dump($infoHashDef)"
    ║ │     │     │   │       └─call &dump  ««"$infoHashDef"
    ║ │     │     │   │         └○ lexical $infoHashDef
    ║ │     │     │   └─:Stmts  ««"{\n            self.log('ast_stats WARNING: no %inf"...
    ║ │     │     │     ├─:Stmts
    ║ │     │     │     └─:Stmts  ««"\n            self.log('ast_stats WARNING: no %info"...
    ║ │     │     │       ├─:Stmts
    ║ │     │     │       │ └─callmethod log  ««"'ast_stats WARNING: no %info hash found in AST of '"...
    ║ │     │     │       │   ├─decont
    ║ │     │     │       │   │ └○ lexical self
    ║ │     │     │       │   ├◙ SVal "ast_stats WARNING: no %info hash found in AST of "
    ║ │     │     │       │   └─callmethod user-progname  ««".user-progname"
    ║ │     │     │       │     └─decont
    ║ │     │     │       │       └○ lexical self
    ║ │     │     │       ├─:Stmts
    ║ │     │     │       │ └─callmethod log  ««"'ast_stats WARNING: ...dunno how to insert actual s"...
    ║ │     │     │       │   ├─decont
    ║ │     │     │       │   │ └○ lexical self
    ║ │     │     │       │   └◙ SVal "ast_stats WARNING: ...dunno how to insert actual stats - which are:"
    ║ │     │     │       └─:Stmts
    ║ │     │     │         └─for  ««"%stats {\n                self.log('    ', nqp::ite"...
    ║ │     │     │           ├○ lexical %stats
    ║ │     │     │           ├─:Block :blocktype(immediate)  ««"{\n                self.log('    ', nqp::iterkey_s("...
    ║ │     │     │           │ ╟─:Stmts
    ║ │     │     │           │ ║ └○ lexical $_ :decl(param)
    ║ │     │     │           │ ╙─:Stmts  ««"\n                self.log('    ', nqp::iterkey_s($"...
    ║ │     │     │           │   └─:Stmts
    ║ │     │     │           │     └─callmethod log  ««"'    ', nqp::iterkey_s($_), ' = ', nqp::iterval($_)"
    ║ │     │     │           │       ├─decont
    ║ │     │     │           │       │ └○ lexical self
    ║ │     │     │           │       ├◙ SVal "    "
    ║ │     │     │           │       ├─iterkey_s  ««"nqp::iterkey_s($_)"
    ║ │     │     │           │       │ └○ lexical $_
    ║ │     │     │           │       ├◙ SVal " = "
    ║ │     │     │           │       └─iterval  ««"nqp::iterval($_)"
    ║ │     │     │           │         └○ lexical $_
    ║ │     │     │           └◙ IVal 1 :named("nohandler")
    ║ │     │     └─:Stmts
    ║ │     │       └○ lexical $ast
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        my $qastfileName := self.user-progname ~"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ ├○ lexical $ast :decl(param)
    ║ │     │   ║ ├○ lexical %adverbs :decl(param) :named(1) :slurpy(1)
    ║ │     │   ║ └○ lexical $qastfileName :decl(var)
    ║ │     │   ╙─lexotic RETURN
    ║ │     │     └─:Stmts  ««"\n        my $qastfileName := self.user-progname ~ "...
    ║ │     │       ├─:Stmts
    ║ │     │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$qastfileName := self.user-progname ~ '.qast'"
    ║ │     │       │   ├○ lexical $qastfileName
    ║ │     │       │   └─concat &infix:<~>  ««"~"
    ║ │     │       │     ├─callmethod user-progname  ««".user-progname"
    ║ │     │       │     │ └─decont
    ║ │     │       │     │   └○ lexical self
    ║ │     │       │     └◙ SVal ".qast"
    ║ │     │       ├─:Stmts
    ║ │     │       │ └─if  ««"return $ast\n            if %adverbs<output> eq $qa"...
    ║ │     │       │   ├─iseq_s &infix:<eq>  ««"eq"
    ║ │     │       │   │ ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │     │       │   │ │ ├○ lexical %adverbs
    ║ │     │       │   │ │ └◙ SVal "output"
    ║ │     │       │   │ └○ lexical $qastfileName
    ║ │     │       │   └─call RETURN
    ║ │     │       │     └○ lexical $ast
    ║ │     │       ├─:Stmts
    ║ │     │       │ └─call &spew  ««"$qastfileName, ~$ast"
    ║ │     │       │   ├○ lexical $qastfileName
    ║ │     │       │   └─stringify &prefix:<~>  ««"~"
    ║ │     │       │     └○ lexical $ast
    ║ │     │       └─:Stmts
    ║ │     │         └○ lexical $ast
    ║ │     └─:Stmts
    ║ │       └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        #self.log('write_bytecode: adverbs=' ~ d"...
    ║ │         ╟─:Stmts
    ║ │         ║ ├○ lexical self :decl(param)
    ║ │         ║ ├○ lexical $mast :decl(param)
    ║ │         ║ └○ lexical %adverbs :decl(param) :named(1) :slurpy(1)
    ║ │         ╙─:Stmts  ««"\n        #self.log('write_bytecode: adverbs=' ~ de"...
    ║ │           ├─:Stmts
    ║ │           │ └─if  ««"%adverbs<target> eq 'mbc' && %adverbs<output> {\n  "...
    ║ │           │   ├─if &infix:<&&>  ««"&&"
    ║ │           │   │ ├─iseq_s &infix:<eq>  ««"eq"
    ║ │           │   │ │ ├○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │           │   │ │ │ ├○ lexical %adverbs
    ║ │           │   │ │ │ └◙ SVal "target"
    ║ │           │   │ │ └◙ SVal "mbc"
    ║ │           │   │ └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │           │   │   ├○ lexical %adverbs
    ║ │           │   │   └◙ SVal "output"
    ║ │           │   ├─:Stmts  ««"{\n            self.log('write_bytecode: omitted be"...
    ║ │           │   │ ├─:Stmts
    ║ │           │   │ └─:Stmts  ««"\n            self.log('write_bytecode: omitted bec"...
    ║ │           │   │   └─:Stmts
    ║ │           │   │     └─callmethod log  ««"'write_bytecode: omitted because of'\n             "...
    ║ │           │   │       ├─decont
    ║ │           │   │       │ └○ lexical self
    ║ │           │   │       └─concat &infix:<~>  ««"~"
    ║ │           │   │         ├─concat &infix:<~>  ««"~"
    ║ │           │   │         │ ├─concat &infix:<~>  ««"~"
    ║ │           │   │         │ │ ├─concat &infix:<~>  ««"~"
    ║ │           │   │         │ │ │ ├─concat &infix:<~>  ««"~"
    ║ │           │   │         │ │ │ │ ├─concat &infix:<~>  ««"~"
    ║ │           │   │         │ │ │ │ │ ├◙ SVal "write_bytecode: omitted because of"
    ║ │           │   │         │ │ │ │ │ └◙ SVal " :target(\""
    ║ │           │   │         │ │ │ │ └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │           │   │         │ │ │ │   ├○ lexical %adverbs
    ║ │           │   │         │ │ │ │   └◙ SVal "target"
    ║ │           │   │         │ │ │ └◙ SVal "\")"
    ║ │           │   │         │ │ └◙ SVal " and :output(\""
    ║ │           │   │         │ └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │           │   │         │   ├○ lexical %adverbs
    ║ │           │   │         │   └◙ SVal "output"
    ║ │           │   │         └◙ SVal "\")"
    ║ │           │   └─:Block :blocktype(immediate)  ««"{\n            my $assmbler := nqp::getcomp('MAST')"...
    ║ │           │     ╟─:Stmts
    ║ │           │     ║ └○ lexical $assmbler :decl(var)
    ║ │           │     ╙─:Stmts  ««"\n            my $assmbler := nqp::getcomp('MAST');"...
    ║ │           │       ├─:Stmts
    ║ │           │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$assmbler := nqp::getcomp('MAST')"
    ║ │           │       │   ├○ lexical $assmbler
    ║ │           │       │   └─getcomp  ««"nqp::getcomp('MAST')"
    ║ │           │       │     └◙ SVal "MAST"
    ║ │           │       ├─:Stmts
    ║ │           │       │ └─callmethod assemble_to_file  ««"$mast, self.user_binname"
    ║ │           │       │   ├○ lexical $assmbler
    ║ │           │       │   ├○ lexical $mast
    ║ │           │       │   └─callmethod user_binname  ««".user_binname"
    ║ │           │       │     └─decont
    ║ │           │       │       └○ lexical self
    ║ │           │       └─:Stmts
    ║ │           │         └─callmethod log  ««"'write_bytecode: ' ~ describe($mast) ~ ' ~> ' ~ sel"...
    ║ │           │           ├─decont
    ║ │           │           │ └○ lexical self
    ║ │           │           └─concat &infix:<~>  ««"~"
    ║ │           │             ├─concat &infix:<~>  ««"~"
    ║ │           │             │ ├─concat &infix:<~>  ««"~"
    ║ │           │             │ │ ├◙ SVal "write_bytecode: "
    ║ │           │             │ │ └─call &describe  ««"$mast"
    ║ │           │             │ │   └○ lexical $mast
    ║ │           │             │ └◙ SVal " ~> "
    ║ │           │             └─callmethod user_binname  ««".user_binname"
    ║ │           │               └─decont
    ║ │           │                 └○ lexical self
    ║ │           └─:Stmts
    ║ │             └○ lexical $mast
    ║ ├─:Stmts
    ║ │ └─:Block :blocktype(immediate)  ««"{\n    \n    method statement_control:sym<use>($/) "...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $?PACKAGE :decl(static) :default((NQPActions, Type object))
    ║ │   ║ └○ lexical $?CLASS :decl(static) :default((NQPActions, Type object))
    ║ │   ╙─:Stmts  ««"\n    \n    method statement_control:sym<use>($/) {"...
    ║ │     └─:Stmts
    ║ │       └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        my $out;\n\n        my @expPathUp := [];"...
    ║ │         ╟─:Stmts
    ║ │         ║ ├○ lexical self :decl(param)
    ║ │         ║ ├○ lexical $/ :decl(param)
    ║ │         ║ ├─bind  ««"$out"
    ║ │         ║ │ ├○ lexical $out :decl(var)
    ║ │         ║ │ └◙ WVal NQPMu
    ║ │         ║ ├○ lexical @expPathUp :decl(var)
    ║ │         ║ ├○ lexical $export :decl(var)
    ║ │         ║ └○ lexical $super :decl(var)
    ║ │         ╙─:Stmts  ««"\n        my $out;\n\n        my @expPathUp := [];\"...
    ║ │           ├─:Stmts
    ║ │           │ └○ lexical $out
    ║ │           ├─:Stmts
    ║ │           │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@expPathUp := []"
    ║ │           │   ├○ lexical @expPathUp
    ║ │           │   └─list &circumfix:<[ ]>
    ║ │           ├─:Stmts
    ║ │           │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$export := findPath(-> $node, @pathUp {\n          "...
    ║ │           │   ├○ lexical $export
    ║ │           │   └─call &findPath  ««"-> $node, @pathUp {\n            istype($node, QAST"...
    ║ │           │     ├─takeclosure
    ║ │           │     │ └─:Block  ««"{\n            istype($node, QAST::Var) && ($node.n"...
    ║ │           │     │   ╟─:Stmts
    ║ │           │     │   ║ ├○ lexical $node :decl(param)
    ║ │           │     │   ║ └○ lexical @pathUp :decl(param)
    ║ │           │     │   ╙─:Stmts  ««"\n            istype($node, QAST::Var) && ($node.na"...
    ║ │           │     │     └─:Stmts
    ║ │           │     │       └─unless &infix:<||>  ««"||"
    ║ │           │     │         ├─if &infix:<&&>  ««"&&"
    ║ │           │     │         │ ├─if &infix:<&&>  ««"&&"
    ║ │           │     │         │ │ ├─call &istype  ««"$node, QAST::Var"
    ║ │           │     │         │ │ │ ├○ lexical $node
    ║ │           │     │         │ │ │ └◙ WVal QAST::Var
    ║ │           │     │         │ │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │           │     │         │ │   ├─callmethod name  ««".name"
    ║ │           │     │         │ │   │ └○ lexical $node
    ║ │           │     │         │ │   └◙ SVal "EXPORT"
    ║ │           │     │         │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │           │     │         │   ├─callmethod decl  ««".decl"
    ║ │           │     │         │   │ └○ lexical $node
    ║ │           │     │         │   └◙ SVal "static"
    ║ │           │     │         └─callmethod list  ««".list"
    ║ │           │     │           └○ lexical $node
    ║ │           │     ├○┬VarWithFallback contextual $*UNIT :fallback((ifnull) ((┬VarWithFallback associative  :decl() :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$UNIT")) ((die_s) (SVal "Contextual $*UNIT not found")))
    ║ │           │     └○ lexical @expPathUp
    ║ │           ├─:Stmts
    ║ │           │ └─if  ««"$export {\n            my $deps := findPath(-> $nod"...
    ║ │           │   ├○ lexical $export
    ║ │           │   └─:Block :blocktype(immediate)  ««"{\n            my $deps := findPath(-> $node, @path"...
    ║ │           │     ╟─:Stmts
    ║ │           │     ║ ├○ lexical $deps :decl(var)
    ║ │           │     ║ └○ lexical $depOut :decl(var)
    ║ │           │     ╙─:Stmts  ««"\n            my $deps := findPath(-> $node, @pathU"...
    ║ │           │       ├─:Stmts
    ║ │           │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$deps := findPath(-> $node, @pathUp {\n            "...
    ║ │           │       │   ├○ lexical $deps
    ║ │           │       │   └─call &findPath  ««"-> $node, @pathUp {\n                if (+@pathUp >"...
    ║ │           │       │     ├─takeclosure
    ║ │           │       │     │ └─:Block  ««"{\n                if (+@pathUp > 1) && @pathUp[1] "...
    ║ │           │       │     │   ╟─:Stmts
    ║ │           │       │     │   ║ ├○ lexical $node :decl(param)
    ║ │           │       │     │   ║ └○ lexical @pathUp :decl(param)
    ║ │           │       │     │   ╙─:Stmts  ««"\n                if (+@pathUp > 1) && @pathUp[1] ="...
    ║ │           │       │     │     └─:Stmts
    ║ │           │       │     │       └─if  ««"(+@pathUp > 1) && @pathUp[1] =:= @expPathUp[0] {\n "...
    ║ │           │       │     │         ├─if &infix:<&&>  ««"&&"
    ║ │           │       │     │         │ ├─isgt_n &infix:<>>  ««">"
    ║ │           │       │     │         │ │ ├─numify &prefix:<+>  ««"+"
    ║ │           │       │     │         │ │ │ └○ lexical @pathUp
    ║ │           │       │     │         │ │ └◙ IVal 1
    ║ │           │       │     │         │ └─eqaddr &infix:<=:=>  ««"=:="
    ║ │           │       │     │         │   ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │           │       │     │         │   │ ├○ lexical @pathUp
    ║ │           │       │     │         │   │ └◙ IVal 1
    ║ │           │       │     │         │   └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │           │       │     │         │     ├○ lexical @expPathUp
    ║ │           │       │     │         │     └◙ IVal 0
    ║ │           │       │     │         ├─:Block :blocktype(immediate)  ««"{\n                    my $parent := @pathUp[0];\n "...
    ║ │           │       │     │         │ ╟─:Stmts
    ║ │           │       │     │         │ ║ ├○ lexical $parent :decl(var)
    ║ │           │       │     │         │ ║ └○ lexical $brother :decl(var)
    ║ │           │       │     │         │ ╙─:Stmts  ««"\n                    my $parent := @pathUp[0];\n  "...
    ║ │           │       │     │         │   ├─:Stmts
    ║ │           │       │     │         │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$parent := @pathUp[0]"
    ║ │           │       │     │         │   │   ├○ lexical $parent
    ║ │           │       │     │         │   │   └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │           │       │     │         │   │     ├○ lexical @pathUp
    ║ │           │       │     │         │   │     └◙ IVal 0
    ║ │           │       │     │         │   ├─:Stmts
    ║ │           │       │     │         │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$brother := $parent[0]"
    ║ │           │       │     │         │   │   ├○ lexical $brother
    ║ │           │       │     │         │   │   └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │           │       │     │         │   │     ├○ lexical $parent
    ║ │           │       │     │         │   │     └◙ IVal 0
    ║ │           │       │     │         │   └─:Stmts
    ║ │           │       │     │         │     └─unless &infix:<||>  ««"||"
    ║ │           │       │     │         │       ├─if &infix:<&&>  ««"&&"
    ║ │           │       │     │         │       │ ├─if &infix:<&&>  ««"&&"
    ║ │           │       │     │         │       │ │ ├─if &infix:<&&>  ««"&&"
    ║ │           │       │     │         │       │ │ │ ├─if &infix:<&&>  ««"&&"
    ║ │           │       │     │         │       │ │ │ │ ├─if &infix:<&&>  ««"&&"
    ║ │           │       │     │         │       │ │ │ │ │ ├─call &istype  ««"$node, QAST::Op"
    ║ │           │       │     │         │       │ │ │ │ │ │ ├○ lexical $node
    ║ │           │       │     │         │       │ │ │ │ │ │ └◙ WVal QAST::Op
    ║ │           │       │     │         │       │ │ │ │ │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │           │       │     │         │       │ │ │ │ │   ├─callmethod op  ««".op"
    ║ │           │       │     │         │       │ │ │ │ │   │ └○ lexical $node
    ║ │           │       │     │         │       │ │ │ │ │   └◙ SVal "list"
    ║ │           │       │     │         │       │ │ │ │ └─call &istype  ««"$parent, QAST::Op"
    ║ │           │       │     │         │       │ │ │ │   ├○ lexical $parent
    ║ │           │       │     │         │       │ │ │ │   └◙ WVal QAST::Op
    ║ │           │       │     │         │       │ │ │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │           │       │     │         │       │ │ │   ├─callmethod op  ««".op"
    ║ │           │       │     │         │       │ │ │   │ └○ lexical $parent
    ║ │           │       │     │         │       │ │ │   └◙ SVal "bind"
    ║ │           │       │     │         │       │ │ └─call &istype  ««"$brother, QAST::Var"
    ║ │           │       │     │         │       │ │   ├○ lexical $brother
    ║ │           │       │     │         │       │ │   └◙ WVal QAST::Var
    ║ │           │       │     │         │       │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │           │       │     │         │       │   ├─callmethod name  ««".name"
    ║ │           │       │     │         │       │   │ └○ lexical $brother
    ║ │           │       │     │         │       │   └◙ SVal "@?DEPENDENCIES"
    ║ │           │       │     │         │       └─callmethod list  ««".list"
    ║ │           │       │     │         │         └○ lexical $node
    ║ │           │       │     │         └─:Stmts  ««"{\n                    $node.list\n                }"
    ║ │           │       │     │           ├─:Stmts
    ║ │           │       │     │           └─:Stmts  ««"\n                    $node.list\n                "
    ║ │           │       │     │             └─:Stmts
    ║ │           │       │     │               └─callmethod list  ««".list"
    ║ │           │       │     │                 └○ lexical $node
    ║ │           │       │     └○┬VarWithFallback contextual $*UNIT :fallback((ifnull) ((┬VarWithFallback associative  :decl() :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$UNIT")) ((die_s) (SVal "Contextual $*UNIT not found")))
    ║ │           │       ├─:Stmts
    ║ │           │       │ └─unless  ««"$deps {\n                $deps := QAST::Op.new(:op<"...
    ║ │           │       │   ├○ lexical $deps
    ║ │           │       │   └─:Block :blocktype(immediate)  ««"{\n                $deps := QAST::Op.new(:op<list>)"...
    ║ │           │       │     ╟─:Stmts
    ║ │           │       │     ║ └○ lexical $depsBinding :decl(var)
    ║ │           │       │     ╙─:Stmts  ««"\n                $deps := QAST::Op.new(:op<list>);"...
    ║ │           │       │       ├─:Stmts
    ║ │           │       │       │ └─bind &infix:<:=>  ««":="
    ║ │           │       │       │   ├○ lexical $deps
    ║ │           │       │       │   └─callmethod new  ««":op<list>"
    ║ │           │       │       │     ├◙ WVal QAST::Op
    ║ │           │       │       │     └◙ SVal "list" :named("op")
    ║ │           │       │       ├─:Stmts
    ║ │           │       │       │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$depsBinding := QAST::Op.new(:op<bind>,\n          "...
    ║ │           │       │       │   ├○ lexical $depsBinding
    ║ │           │       │       │   └─callmethod new  ««":op<bind>,\n                    QAST::Var.new(\n   "...
    ║ │           │       │       │     ├◙ WVal QAST::Op
    ║ │           │       │       │     ├◙ SVal "bind" :named("op")
    ║ │           │       │       │     ├─callmethod new  ««"\n                        :name('@?DEPENDENCIES'),\"...
    ║ │           │       │       │     │ ├◙ WVal QAST::Var
    ║ │           │       │       │     │ ├◙ SVal "@?DEPENDENCIES" :named("name")
    ║ │           │       │       │     │ ├◙ SVal "lexical" :named("scope")
    ║ │           │       │       │     │ └◙ SVal "static" :named("decl")
    ║ │           │       │       │     └○ lexical $deps
    ║ │           │       │       └─:Stmts
    ║ │           │       │         └─callmethod push  ««"$depsBinding"
    ║ │           │       │           ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │           │       │           │ ├○ lexical @expPathUp
    ║ │           │       │           │ └◙ IVal 0
    ║ │           │       │           └○ lexical $depsBinding
    ║ │           │       ├─:Stmts
    ║ │           │       │ └─callmethod push  ««"QAST::SVal.new(:value($/<name>), :node($/))"
    ║ │           │       │   ├○ lexical $deps
    ║ │           │       │   └─callmethod new  ««":value($/<name>), :node($/)"
    ║ │           │       │     ├◙ WVal QAST::SVal
    ║ │           │       │     ├○┬VarWithFallback associative  :named("value") :fallback(WVal NQPMu)
    ║ │           │       │     │ ├○ lexical $/
    ║ │           │       │     │ └◙ SVal "name"
    ║ │           │       │     └○ lexical $/ :named("node")
    ║ │           │       ├─:Stmts
    ║ │           │       │ └─callmethod log  ««"$*COMPILER.user_progname, ' dependency: \"' ~ $/<na"...
    ║ │           │       │   ├○┬VarWithFallback contextual $*COMPILER :fallback((ifnull) ((┬VarWithFallback associative  :decl() :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$COMPILER")) ((die_s) (SVal "Contextual $*COMPILER not found")))
    ║ │           │       │   ├─callmethod user_progname  ««".user_progname"
    ║ │           │       │   │ └○┬VarWithFallback contextual $*COMPILER :fallback((ifnull) ((┬VarWithFallback associative  :decl() :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$COMPILER")) ((die_s) (SVal "Contextual $*COMPILER not found")))
    ║ │           │       │   └─concat &infix:<~>  ««"~"
    ║ │           │       │     ├─concat &infix:<~>  ««"~"
    ║ │           │       │     │ ├◙ SVal " dependency: \""
    ║ │           │       │     │ └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │           │       │     │   ├○ lexical $/
    ║ │           │       │     │   └◙ SVal "name"
    ║ │           │       │     └◙ SVal "\""
    ║ │           │       └─:Stmts
    ║ │           │         └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$depOut := $*COMPILER.compileDependency(~$/<name>, [])"
    ║ │           │           ├○ lexical $depOut
    ║ │           │           └─callmethod compileDependency  ««"~$/<name>, []"
    ║ │           │             ├○┬VarWithFallback contextual $*COMPILER :fallback((ifnull) ((┬VarWithFallback associative  :decl() :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$COMPILER")) ((die_s) (SVal "Contextual $*COMPILER not found")))
    ║ │           │             ├─stringify &prefix:<~>  ««"~"
    ║ │           │             │ └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │           │             │   ├○ lexical $/
    ║ │           │             │   └◙ SVal "name"
    ║ │           │             └─list &circumfix:<[ ]>
    ║ │           ├─:Stmts
    ║ │           │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$super := nqp::findmethod(self.HOW.mro(self)[1], 's"...
    ║ │           │   ├○ lexical $super
    ║ │           │   └─findmethod  ««"nqp::findmethod(self.HOW.mro(self)[1], 'statement_c"...
    ║ │           │     ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │           │     │ ├─callmethod mro  ««"self"
    ║ │           │     │ │ ├─how  ««".HOW"
    ║ │           │     │ │ │ └─decont
    ║ │           │     │ │ │   └○ lexical self
    ║ │           │     │ │ └─decont
    ║ │           │     │ │   └○ lexical self
    ║ │           │     │ └◙ IVal 1
    ║ │           │     └◙ SVal "statement_control:sym<use>"
    ║ │           ├─:Stmts
    ║ │           │ └─bind &infix:<:=>  ««":="
    ║ │           │   ├○ lexical $out
    ║ │           │   └─call  ««"self, $/"
    ║ │           │     ├○ lexical $super
    ║ │           │     ├─decont
    ║ │           │     │ └○ lexical self
    ║ │           │     └○ lexical $/
    ║ │           ├─:Stmts
    ║ │           │ └─callmethod node  ««"$/"
    ║ │           │   ├○ lexical $out
    ║ │           │   └○ lexical $/
    ║ │           ├─:Stmts
    ║ │           │ └─callmethod annotate  ««"'use', ~$/<name>"
    ║ │           │   ├○ lexical $out
    ║ │           │   ├◙ SVal "use"
    ║ │           │   └─stringify &prefix:<~>  ««"~"
    ║ │           │     └○┬VarWithFallback associative  :fallback(WVal NQPMu)
    ║ │           │       ├○ lexical $/
    ║ │           │       └◙ SVal "name"
    ║ │           └─:Stmts
    ║ │             └─callmethod make  ««"make "
    ║ │               ├○ lexical $/
    ║ │               └○ lexical $out
    ║ ├─:Stmts
    ║ │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$needsCompilation := 0"
    ║ │   ├○ lexical $needsCompilation
    ║ │   └◙ IVal 0
    ║ ├─:Stmts
    ║ │ └─:Block :blocktype(immediate)  ««"{\n\n    method BUILD() {\n        self.language('n"...
    ║ │   ╟─:Stmts
    ║ │   ║ ├○ lexical $?PACKAGE :decl(static) :default((NQPCompiler, Type object))
    ║ │   ║ └○ lexical $?CLASS :decl(static) :default((NQPCompiler, Type object))
    ║ │   ╙─:Stmts  ««"\n\n    method BUILD() {\n        self.language('nq"...
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        self.language('nqp');\n        self.pars"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ └○ lexical self :decl(param)
    ║ │     │   ╙─lexotic RETURN
    ║ │     │     └─:Stmts  ««"\n        self.language('nqp');\n        self.parse"...
    ║ │     │       ├─:Stmts
    ║ │     │       │ └─callmethod language  ««"'nqp'"
    ║ │     │       │   ├─decont
    ║ │     │       │   │ └○ lexical self
    ║ │     │       │   └◙ SVal "nqp"
    ║ │     │       ├─:Stmts
    ║ │     │       │ └─callmethod parsegrammar  ««"NQP::Grammar"
    ║ │     │       │   ├─decont
    ║ │     │       │   │ └○ lexical self
    ║ │     │       │   └◙ WVal NQP::Grammar
    ║ │     │       ├─:Stmts
    ║ │     │       │ └─callmethod parseactions  ««"NQPActions"
    ║ │     │       │   ├─decont
    ║ │     │       │   │ └○ lexical self
    ║ │     │       │   └◙ WVal NQPActions
    ║ │     │       └─:Stmts
    ║ │     │         └─call RETURN
    ║ │     │           └─decont
    ║ │     │             └○ lexical self
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        my $*COMPILER := self;\n        my $pars"...
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ ├○ lexical $source :decl(param)
    ║ │     │   ║ ├○ lexical %adverbs :decl(param) :named(1) :slurpy(1)
    ║ │     │   ║ ├○ lexical $*COMPILER :decl(var)
    ║ │     │   ║ └○ lexical $parse :decl(var)
    ║ │     │   ╙─:Stmts  ««"\n        my $*COMPILER := self;\n        my $parse"...
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$*COMPILER := self"
    ║ │     │     │   ├○┬VarWithFallback contextual $*COMPILER :fallback((ifnull) ((┬VarWithFallback associative  :decl() :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$COMPILER")) ((die_s) (SVal "Contextual $*COMPILER not found")))
    ║ │     │     │   └─decont
    ║ │     │     │     └○ lexical self
    ║ │     │     ├─:Stmts
    ║ │     │     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$parse := nqp::findmethod(self.HOW.mro(self)[1], 'p"...
    ║ │     │     │   ├○ lexical $parse
    ║ │     │     │   └─findmethod  ««"nqp::findmethod(self.HOW.mro(self)[1], 'parse')"
    ║ │     │     │     ├○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │     │     │     │ ├─callmethod mro  ««"self"
    ║ │     │     │     │ │ ├─how  ««".HOW"
    ║ │     │     │     │ │ │ └─decont
    ║ │     │     │     │ │ │   └○ lexical self
    ║ │     │     │     │ │ └─decont
    ║ │     │     │     │ │   └○ lexical self
    ║ │     │     │     │ └◙ IVal 1
    ║ │     │     │     └◙ SVal "parse"
    ║ │     │     └─:Stmts
    ║ │     │       └─call  ««"self, $source, |%adverbs"
    ║ │     │         ├○ lexical $parse
    ║ │     │         ├─decont
    ║ │     │         │ └○ lexical self
    ║ │     │         ├○ lexical $source
    ║ │     │         └○ lexical %adverbs :flat(1) :named(1)
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{ 'nqpc' }"
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ └○ lexical $value :decl(param) :default((┬VarWithFallback associative  :decl() :fallback((ifnull) ((atkey) ((who) (WVal GLOBALish)) (SVal "NO_VALUE")) (WVal NQPMu))) ((who) ( lexical $?PACKAGE :decl())) (SVal "NO_VALUE"))
    ║ │     │   ╙─:Stmts  ««" 'nqpc' "
    ║ │     │     └─:Stmts
    ║ │     │       └◙ SVal "nqpc"
    ║ │     ├─:Stmts
    ║ │     │ └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        nqp::rethrow($error);\n    }"
    ║ │     │   ╟─:Stmts
    ║ │     │   ║ ├○ lexical self :decl(param)
    ║ │     │   ║ └○ lexical $error :decl(param)
    ║ │     │   ╙─:Stmts  ««"\n        nqp::rethrow($error);\n    "
    ║ │     │     └─:Stmts
    ║ │     │       └─rethrow  ««"nqp::rethrow($error)"
    ║ │     │         └○ lexical $error
    ║ │     └─:Stmts
    ║ │       └─:Block :annotations(#`{BOOTHash:}nqp::hash( "compile_time_dummy", (BOOTCode, invokable), "code_obj", (NQPRoutine, invokable) )) :blocktype(declaration_static)  ««"{\n        # replace all backslashes with slashes\n"...
    ║ │         ╟─:Stmts
    ║ │         ║ ├○ lexical self :decl(param)
    ║ │         ║ ├○ lexical $src_path :decl(param)
    ║ │         ║ ├○ lexical $target :decl(param) :named("target") :default(SVal "mbc")
    ║ │         ║ ├○ lexical $stagestats :decl(param) :named("stagestats") :default(WVal NQPMu)
    ║ │         ║ ├○ lexical $cwd :decl(var)
    ║ │         ║ ├○ lexical $l :decl(var)
    ║ │         ║ ├○ lexical $x :decl(var)
    ║ │         ║ ├○ lexical $src_ext :decl(var)
    ║ │         ║ ├○ lexical $i :decl(var)
    ║ │         ║ ├○ lexical $src_name :decl(var)
    ║ │         ║ ├○ lexical $src_dir :decl(var)
    ║ │         ║ ├○ lexical $src_lib :decl(var)
    ║ │         ║ ├○ lexical $vm_ext :decl(var)
    ║ │         ║ ├○ lexical $vm_dir :decl(var)
    ║ │         ║ ├─bind  ««"$vm_path"
    ║ │         ║ │ ├○ lexical $vm_path :decl(var)
    ║ │         ║ │ └◙ WVal NQPMu
    ║ │         ║ └○ lexical $ast_path :decl(var)
    ║ │         ╙─lexotic RETURN
    ║ │           └─:Stmts  ««"\n        # replace all backslashes with slashes\n "...
    ║ │             ├─:Stmts
    ║ │             │ └─bind &infix:<:=>  ««":="
    ║ │             │   ├○ lexical $src_path
    ║ │             │   └─join  ««"nqp::join('/', nqp::split('\\\\', $src_path))"
    ║ │             │     ├◙ SVal "/"
    ║ │             │     └─split  ««"nqp::split('\\\\', $src_path)"
    ║ │             │       ├◙ SVal "\\"
    ║ │             │       └○ lexical $src_path
    ║ │             ├─:Stmts
    ║ │             │ └─if  ««"!nqp::filereadable($src_path) {\n            #self."...
    ║ │             │   ├─falsey &prefix:<!>  ««"!"
    ║ │             │   │ └─filereadable  ««"nqp::filereadable($src_path)"
    ║ │             │   │   └○ lexical $src_path
    ║ │             │   └─:Stmts  ««"{\n            #self.panic(\"no such file: $src_pat"...
    ║ │             │     ├─:Stmts
    ║ │             │     └─:Stmts  ««"\n            #self.panic(\"no such file: $src_path"...
    ║ │             │       └◙ WVal NQPMu
    ║ │             ├─:Stmts
    ║ │             │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$cwd := nqp::join('/', nqp::split('\\\\', nqp::cwd))"
    ║ │             │   ├○ lexical $cwd
    ║ │             │   └─join  ««"nqp::join('/', nqp::split('\\\\', nqp::cwd))"
    ║ │             │     ├◙ SVal "/"
    ║ │             │     └─split  ««"nqp::split('\\\\', nqp::cwd)"
    ║ │             │       ├◙ SVal "\\"
    ║ │             │       └─cwd  ««"nqp::cwd"
    ║ │             ├─:Stmts
    ║ │             │ └─if  ««"nqp::index($src_path, $cwd) == 0 {\n            $sr"...
    ║ │             │   ├─iseq_n &infix:<==>  ««"=="
    ║ │             │   │ ├─index  ««"nqp::index($src_path, $cwd)"
    ║ │             │   │ │ ├○ lexical $src_path
    ║ │             │   │ │ └○ lexical $cwd
    ║ │             │   │ └◙ IVal 0
    ║ │             │   └─:Stmts  ««"{\n            $src_path := nqp::substr($src_path, "...
    ║ │             │     ├─:Stmts
    ║ │             │     └─:Stmts  ««"\n            $src_path := nqp::substr($src_path, n"...
    ║ │             │       └─:Stmts
    ║ │             │         └─bind &infix:<:=>  ««":="
    ║ │             │           ├○ lexical $src_path
    ║ │             │           └─substr  ««"nqp::substr($src_path, nqp::chars($cwd) + 1)"
    ║ │             │             ├○ lexical $src_path
    ║ │             │             └─add_n &infix:<+>  ««"+"
    ║ │             │               ├─chars  ««"nqp::chars($cwd)"
    ║ │             │               │ └○ lexical $cwd
    ║ │             │               └◙ IVal 1
    ║ │             ├─:Stmts
    ║ │             │ └─if  ««"nqp::index($src_path, './') == 0 {\n            $sr"...
    ║ │             │   ├─iseq_n &infix:<==>  ««"=="
    ║ │             │   │ ├─index  ««"nqp::index($src_path, './')"
    ║ │             │   │ │ ├○ lexical $src_path
    ║ │             │   │ │ └◙ SVal "./"
    ║ │             │   │ └◙ IVal 0
    ║ │             │   └─:Stmts  ««"{\n            $src_path := nqp::substr($src_path, "...
    ║ │             │     ├─:Stmts
    ║ │             │     └─:Stmts  ««"\n            $src_path := nqp::substr($src_path, 2"...
    ║ │             │       └─:Stmts
    ║ │             │         └─bind &infix:<:=>  ««":="
    ║ │             │           ├○ lexical $src_path
    ║ │             │           └─substr  ««"nqp::substr($src_path, 2)"
    ║ │             │             ├○ lexical $src_path
    ║ │             │             └◙ IVal 2
    ║ │             ├─:Stmts
    ║ │             │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$l := nqp::chars($src_path)"
    ║ │             │   ├○ lexical $l
    ║ │             │   └─chars  ««"nqp::chars($src_path)"
    ║ │             │     └○ lexical $src_path
    ║ │             ├─:Stmts
    ║ │             │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$x := nqp::rindex($src_path, '.')"
    ║ │             │   ├○ lexical $x
    ║ │             │   └─rindex  ««"nqp::rindex($src_path, '.')"
    ║ │             │     ├○ lexical $src_path
    ║ │             │     └◙ SVal "."
    ║ │             ├─:Stmts
    ║ │             │ └─if  ««"$x <= 0 {    # yes, also files like \".gitignore\","...
    ║ │             │   ├─isle_n &infix:<<=>  ««"<="
    ║ │             │   │ ├○ lexical $x
    ║ │             │   │ └◙ IVal 0
    ║ │             │   └─:Stmts  ««"{    # yes, also files like \".gitignore\", for exa"...
    ║ │             │     ├─:Stmts
    ║ │             │     └─:Stmts  ««"    # yes, also files like \".gitignore\", for exam"...
    ║ │             │       └─:Stmts
    ║ │             │         └─callmethod panic  ««"\"invalid source file (no extension): $src_path\""
    ║ │             │           ├─decont
    ║ │             │           │ └○ lexical self
    ║ │             │           └─concat
    ║ │             │             ├◙ SVal "invalid source file (no extension): "
    ║ │             │             └○ lexical $src_path
    ║ │             ├─:Stmts
    ║ │             │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$src_ext := nqp::substr($src_path, $x + 1)"
    ║ │             │   ├○ lexical $src_ext
    ║ │             │   └─substr  ««"nqp::substr($src_path, $x + 1)"
    ║ │             │     ├○ lexical $src_path
    ║ │             │     └─add_n &infix:<+>  ««"+"
    ║ │             │       ├○ lexical $x
    ║ │             │       └◙ IVal 1
    ║ │             ├─:Stmts
    ║ │             │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$i := nqp::rindex($src_path, '/')"
    ║ │             │   ├○ lexical $i
    ║ │             │   └─rindex  ««"nqp::rindex($src_path, '/')"
    ║ │             │     ├○ lexical $src_path
    ║ │             │     └◙ SVal "/"
    ║ │             ├─:Stmts
    ║ │             │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$src_name := nqp::substr($src_path, $i + 1, $x - $i"...
    ║ │             │   ├○ lexical $src_name
    ║ │             │   └─substr  ««"nqp::substr($src_path, $i + 1, $x - $i - 1)"
    ║ │             │     ├○ lexical $src_path
    ║ │             │     ├─add_n &infix:<+>  ««"+"
    ║ │             │     │ ├○ lexical $i
    ║ │             │     │ └◙ IVal 1
    ║ │             │     └─sub_n &infix:<->  ««"-"
    ║ │             │       ├─sub_n &infix:<->  ««"-"
    ║ │             │       │ ├○ lexical $x
    ║ │             │       │ └○ lexical $i
    ║ │             │       └◙ IVal 1
    ║ │             ├─:Stmts
    ║ │             │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$src_dir := nqp::substr($src_path, 0, max(0, $i))"
    ║ │             │   ├○ lexical $src_dir
    ║ │             │   └─substr  ««"nqp::substr($src_path, 0, max(0, $i))"
    ║ │             │     ├○ lexical $src_path
    ║ │             │     ├◙ IVal 0
    ║ │             │     └─call &max  ««"0, $i"
    ║ │             │       ├◙ IVal 0
    ║ │             │       └○ lexical $i
    ║ │             ├─:Stmts
    ║ │             │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$src_lib := ''"
    ║ │             │   ├○ lexical $src_lib
    ║ │             │   └◙ SVal ""
    ║ │             ├─:Stmts
    ║ │             │ └─for  ««"self.user_srcpaths {\n            if nqp::index($sr"...
    ║ │             │   ├─callmethod user_srcpaths  ««".user_srcpaths"
    ║ │             │   │ └─decont
    ║ │             │   │   └○ lexical self
    ║ │             │   └─:Block :blocktype(immediate)  ««"{\n            if nqp::index($src_dir, $_) == 0 {\n"...
    ║ │             │     ╟─:Stmts
    ║ │             │     ║ └○ lexical $_ :decl(param)
    ║ │             │     ╙─:Stmts  ««"\n            if nqp::index($src_dir, $_) == 0 {\n "...
    ║ │             │       └─:Stmts
    ║ │             │         └─if  ««"nqp::index($src_dir, $_) == 0 {\n                $s"...
    ║ │             │           ├─iseq_n &infix:<==>  ««"=="
    ║ │             │           │ ├─index  ««"nqp::index($src_dir, $_)"
    ║ │             │           │ │ ├○ lexical $src_dir
    ║ │             │           │ │ └○ lexical $_
    ║ │             │           │ └◙ IVal 0
    ║ │             │           └─:Stmts  ««"{\n                $src_lib := nqp::substr($src_dir"...
    ║ │             │             ├─:Stmts
    ║ │             │             └─:Stmts  ««"\n                $src_lib := nqp::substr($src_dir,"...
    ║ │             │               ├─:Stmts
    ║ │             │               │ └─bind &infix:<:=>  ««":="
    ║ │             │               │   ├○ lexical $src_lib
    ║ │             │               │   └─substr  ««"nqp::substr($src_dir, nqp::chars($_) + 1)"
    ║ │             │               │     ├○ lexical $src_dir
    ║ │             │               │     └─add_n &infix:<+>  ««"+"
    ║ │             │               │       ├─chars  ««"nqp::chars($_)"
    ║ │             │               │       │ └○ lexical $_
    ║ │             │               │       └◙ IVal 1
    ║ │             │               ├─:Stmts
    ║ │             │               │ └─bind &infix:<:=>  ««":="
    ║ │             │               │   ├○ lexical $src_dir
    ║ │             │               │   └○ lexical $_
    ║ │             │               └─:Stmts
    ║ │             │                 └─control last
    ║ │             ├─:Stmts
    ║ │             │ └─unless  ««"$src_dir {\n            $src_dir := '.';\n        }"
    ║ │             │   ├○ lexical $src_dir
    ║ │             │   └─:Stmts  ««"{\n            $src_dir := '.';\n        }"
    ║ │             │     ├─:Stmts
    ║ │             │     └─:Stmts  ««"\n            $src_dir := '.';\n        "
    ║ │             │       └─:Stmts
    ║ │             │         └─bind &infix:<:=>  ««":="
    ║ │             │           ├○ lexical $src_dir
    ║ │             │           └◙ SVal "."
    ║ │             ├─:Stmts
    ║ │             │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$vm_ext  := 'moarvm'"
    ║ │             │   ├○ lexical $vm_ext
    ║ │             │   └◙ SVal "moarvm"
    ║ │             ├─:Stmts
    ║ │             │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$vm_dir  := 'blib'"
    ║ │             │   ├○ lexical $vm_dir
    ║ │             │   └◙ SVal "blib"
    ║ │             ├─:Stmts
    ║ │             │ └○ lexical $vm_path
    ║ │             ├─:Stmts
    ║ │             │ └─if  ««"$src_lib {\n            $src_path := \"$src_dir/$sr"...
    ║ │             │   ├○ lexical $src_lib
    ║ │             │   ├─:Stmts  ««"{\n            $src_path := \"$src_dir/$src_lib/$sr"...
    ║ │             │   │ ├─:Stmts
    ║ │             │   │ └─:Stmts  ««"\n            $src_path := \"$src_dir/$src_lib/$src"...
    ║ │             │   │   ├─:Stmts
    ║ │             │   │   │ └─bind &infix:<:=>  ««":="
    ║ │             │   │   │   ├○ lexical $src_path
    ║ │             │   │   │   └─concat
    ║ │             │   │   │     ├─concat
    ║ │             │   │   │     │ ├─concat
    ║ │             │   │   │     │ │ ├─concat
    ║ │             │   │   │     │ │ │ ├─concat
    ║ │             │   │   │     │ │ │ │ ├─concat
    ║ │             │   │   │     │ │ │ │ │ ├○ lexical $src_dir
    ║ │             │   │   │     │ │ │ │ │ └◙ SVal "/"
    ║ │             │   │   │     │ │ │ │ └○ lexical $src_lib
    ║ │             │   │   │     │ │ │ └◙ SVal "/"
    ║ │             │   │   │     │ │ └○ lexical $src_name
    ║ │             │   │   │     │ └◙ SVal "."
    ║ │             │   │   │     └○ lexical $src_ext
    ║ │             │   │   └─:Stmts
    ║ │             │   │     └─bind &infix:<:=>  ««":="
    ║ │             │   │       ├○ lexical $vm_path
    ║ │             │   │       └─concat
    ║ │             │   │         ├─concat
    ║ │             │   │         │ ├─concat
    ║ │             │   │         │ │ ├─concat
    ║ │             │   │         │ │ │ ├─concat
    ║ │             │   │         │ │ │ │ ├─concat
    ║ │             │   │         │ │ │ │ │ ├○ lexical $vm_dir
    ║ │             │   │         │ │ │ │ │ └◙ SVal "/"
    ║ │             │   │         │ │ │ │ └○ lexical $src_lib
    ║ │             │   │         │ │ │ └◙ SVal "/"
    ║ │             │   │         │ │ └○ lexical $src_name
    ║ │             │   │         │ └◙ SVal "."
    ║ │             │   │         └○ lexical $vm_ext
    ║ │             │   └─:Stmts  ««"{\n            $src_path := \"$src_dir/$src_name.$s"...
    ║ │             │     ├─:Stmts
    ║ │             │     └─:Stmts  ««"\n            $src_path := \"$src_dir/$src_name.$sr"...
    ║ │             │       ├─:Stmts
    ║ │             │       │ └─bind &infix:<:=>  ««":="
    ║ │             │       │   ├○ lexical $src_path
    ║ │             │       │   └─concat
    ║ │             │       │     ├─concat
    ║ │             │       │     │ ├─concat
    ║ │             │       │     │ │ ├─concat
    ║ │             │       │     │ │ │ ├○ lexical $src_dir
    ║ │             │       │     │ │ │ └◙ SVal "/"
    ║ │             │       │     │ │ └○ lexical $src_name
    ║ │             │       │     │ └◙ SVal "."
    ║ │             │       │     └○ lexical $src_ext
    ║ │             │       └─:Stmts
    ║ │             │         └─bind &infix:<:=>  ««":="
    ║ │             │           ├○ lexical $vm_path
    ║ │             │           └─concat
    ║ │             │             ├─concat
    ║ │             │             │ ├─concat
    ║ │             │             │ │ ├─concat
    ║ │             │             │ │ │ ├○ lexical $vm_dir
    ║ │             │             │ │ │ └◙ SVal "/"
    ║ │             │             │ │ └○ lexical $src_name
    ║ │             │             │ └◙ SVal "."
    ║ │             │             └○ lexical $vm_ext
    ║ │             ├─:Stmts
    ║ │             │ └─callmethod user_binname  ««"$vm_path"
    ║ │             │   ├─decont
    ║ │             │   │ └○ lexical self
    ║ │             │   └○ lexical $vm_path
    ║ │             ├─:Stmts
    ║ │             │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$ast_path := \"$src_path.qast\""
    ║ │             │   ├○ lexical $ast_path
    ║ │             │   └─concat
    ║ │             │     ├○ lexical $src_path
    ║ │             │     └◙ SVal ".qast"
    ║ │             ├─:Stmts
    ║ │             │ └─bind &infix:<:=>  ««":="
    ║ │             │   ├○ lexical $needsCompilation
    ║ │             │   └◙ IVal 1
    ║ │             └─:Stmts
    ║ │               └─if  ««"!$needsCompilation {\n            return nqp::null;"...
    ║ │                 ├─falsey &prefix:<!>  ««"!"
    ║ │                 │ └○ lexical $needsCompilation
    ║ │                 ├─:Stmts  ««"{\n            return nqp::null;   # means: \"not c"...
    ║ │                 │ ├─:Stmts
    ║ │                 │ └─:Stmts  ««"\n            return nqp::null;   # means: \"not co"...
    ║ │                 │   └─:Stmts
    ║ │                 │     └─call RETURN
    ║ │                 │       └─null  ««"nqp::null"
    ║ │                 └─:Block :blocktype(immediate)  ««"{\n            my @opts := [\n                #'--m"...
    ║ │                   ╟─:Stmts
    ║ │                   ║ ├○ lexical @opts :decl(var)
    ║ │                   ║ ├○ lexical @args :decl(var)
    ║ │                   ║ ├○ lexical $*USER_FILE :decl(var)
    ║ │                   ║ ├─bind  ««"$result"
    ║ │                   ║ │ ├○ lexical $result :decl(var)
    ║ │                   ║ │ └◙ WVal NQPMu
    ║ │                   ║ ├─bind  ««"$error"
    ║ │                   ║ │ ├○ lexical $error :decl(var)
    ║ │                   ║ │ └◙ WVal NQPMu
    ║ │                   ║ ├○ lexical $msg :decl(var)
    ║ │                   ║ ├○ lexical $msglc :decl(var)
    ║ │                   ║ ├─bind  ««"$from"
    ║ │                   ║ │ ├○ lexical $from :decl(var)
    ║ │                   ║ │ └◙ WVal NQPMu
    ║ │                   ║ └─bind  ««"$to"
    ║ │                   ║   ├○ lexical $to :decl(var)
    ║ │                   ║   └◙ WVal NQPMu
    ║ │                   ╙─:Stmts  ««"\n            my @opts := [\n                #'--mo"...
    ║ │                     ├─:Stmts
    ║ │                     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@opts := [\n                #'--module-path=L',\n  "...
    ║ │                     │   ├○ lexical @opts
    ║ │                     │   └─list &circumfix:<[ ]>
    ║ │                     ├─:Stmts
    ║ │                     │ └─if  ««"@opts.push(\"--target=$target\") if $target"
    ║ │                     │   ├○ lexical $target
    ║ │                     │   └─callmethod push  ««"\"--target=$target\""
    ║ │                     │     ├○ lexical @opts
    ║ │                     │     └─concat
    ║ │                     │       ├◙ SVal "--target="
    ║ │                     │       └○ lexical $target
    ║ │                     ├─:Stmts
    ║ │                     │ └─if  ««"$target eq 'mbc' {\n                if nqp::stat($v"...
    ║ │                     │   ├─iseq_s &infix:<eq>  ««"eq"
    ║ │                     │   │ ├○ lexical $target
    ║ │                     │   │ └◙ SVal "mbc"
    ║ │                     │   ├─:Stmts  ««"{\n                if nqp::stat($vm_path, nqp::cons"...
    ║ │                     │   │ ├─:Stmts
    ║ │                     │   │ └─:Stmts  ««"\n                if nqp::stat($vm_path, nqp::const"...
    ║ │                     │   │   ├─:Stmts
    ║ │                     │   │   │ └─if  ««"nqp::stat($vm_path, nqp::const::STAT_EXISTS) && !nq"...
    ║ │                     │   │   │   ├─if &infix:<&&>  ««"&&"
    ║ │                     │   │   │   │ ├─stat  ««"nqp::stat($vm_path, nqp::const::STAT_EXISTS)"
    ║ │                     │   │   │   │ │ ├○ lexical $vm_path
    ║ │                     │   │   │   │ │ └─const STAT_EXISTS
    ║ │                     │   │   │   │ └─falsey &prefix:<!>  ««"!"
    ║ │                     │   │   │   │   └─filewritable  ««"nqp::filewritable($vm_path)"
    ║ │                     │   │   │   │     └○ lexical $vm_path
    ║ │                     │   │   │   └─:Stmts  ««"{\n                    nqp::die(\"cannot write to f"...
    ║ │                     │   │   │     ├─:Stmts
    ║ │                     │   │   │     └─:Stmts  ««"\n                    nqp::die(\"cannot write to fi"...
    ║ │                     │   │   │       └─:Stmts
    ║ │                     │   │   │         └─die  ««"nqp::die(\"cannot write to file: $vm_path\")"
    ║ │                     │   │   │           └─concat
    ║ │                     │   │   │             ├◙ SVal "cannot write to file: "
    ║ │                     │   │   │             └○ lexical $vm_path
    ║ │                     │   │   └─:Stmts
    ║ │                     │   │     └─callmethod push  ««"'--output=' ~ $vm_path"
    ║ │                     │   │       ├○ lexical @opts
    ║ │                     │   │       └─concat &infix:<~>  ««"~"
    ║ │                     │   │         ├◙ SVal "--output="
    ║ │                     │   │         └○ lexical $vm_path
    ║ │                     │   └─if  ««"$target eq 'ast' || $target eq 'ast_clean' || $targ"...
    ║ │                     │     ├─unless &infix:<||>  ««"||"
    ║ │                     │     │ ├─unless &infix:<||>  ««"||"
    ║ │                     │     │ │ ├─iseq_s &infix:<eq>  ««"eq"
    ║ │                     │     │ │ │ ├○ lexical $target
    ║ │                     │     │ │ │ └◙ SVal "ast"
    ║ │                     │     │ │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │                     │     │ │   ├○ lexical $target
    ║ │                     │     │ │   └◙ SVal "ast_clean"
    ║ │                     │     │ └─iseq_s &infix:<eq>  ««"eq"
    ║ │                     │     │   ├○ lexical $target
    ║ │                     │     │   └◙ SVal "ast_save"
    ║ │                     │     └─:Stmts  ««"{\n                @opts.push('--output=' ~ $ast_pa"...
    ║ │                     │       ├─:Stmts
    ║ │                     │       └─:Stmts  ««"\n                @opts.push('--output=' ~ $ast_pat"...
    ║ │                     │         └─:Stmts
    ║ │                     │           └─callmethod push  ««"'--output=' ~ $ast_path"
    ║ │                     │             ├○ lexical @opts
    ║ │                     │             └─concat &infix:<~>  ««"~"
    ║ │                     │               ├◙ SVal "--output="
    ║ │                     │               └○ lexical $ast_path
    ║ │                     ├─:Stmts
    ║ │                     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@args := nqp::clone(@opts)"
    ║ │                     │   ├○ lexical @args
    ║ │                     │   └─clone  ««"nqp::clone(@opts)"
    ║ │                     │     └○ lexical @opts
    ║ │                     ├─:Stmts
    ║ │                     │ └─callmethod unshift  ««"'nqpc'"
    ║ │                     │   ├○ lexical @args
    ║ │                     │   └◙ SVal "nqpc"
    ║ │                     ├─:Stmts
    ║ │                     │ └─callmethod push  ««"$src_path"
    ║ │                     │   ├○ lexical @args
    ║ │                     │   └○ lexical $src_path
    ║ │                     ├─:Stmts
    ║ │                     │ └─callmethod log  ««"'$ ', nqp::join(' ', @args)"
    ║ │                     │   ├─decont
    ║ │                     │   │ └○ lexical self
    ║ │                     │   ├◙ SVal "$ "
    ║ │                     │   └─join  ««"nqp::join(' ', @args)"
    ║ │                     │     ├◙ SVal " "
    ║ │                     │     └○ lexical @args
    ║ │                     ├─:Stmts
    ║ │                     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$*USER_FILE := $src_path"
    ║ │                     │   ├○┬VarWithFallback contextual $*USER_FILE :fallback((ifnull) ((┬VarWithFallback associative  :decl() :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$USER_FILE")) ((die_s) (SVal "Contextual $*USER_FILE not found")))
    ║ │                     │   └○ lexical $src_path
    ║ │                     ├─:Stmts
    ║ │                     │ └○ lexical $result
    ║ │                     ├─:Stmts
    ║ │                     │ └○ lexical $error
    ║ │                     ├─:Stmts
    ║ │                     │ └─handle
    ║ │                     │   ├─:Stmts  ««"{\n                $result := self.command_line(@ar"...
    ║ │                     │   │ ├─:Stmts
    ║ │                     │   │ └─handle
    ║ │                     │   │   ├─:Stmts  ««"\n                $result := self.command_line(@arg"...
    ║ │                     │   │   │ ├─:Stmts
    ║ │                     │   │   │ │ └─bind &infix:<:=>  ««":="
    ║ │                     │   │   │ │   ├○ lexical $result
    ║ │                     │   │   │ │   └─callmethod command_line  ««"@args, \n                    :encoding('utf8'), \n "...
    ║ │                     │   │   │ │     ├─decont
    ║ │                     │   │   │ │     │ └○ lexical self
    ║ │                     │   │   │ │     ├○ lexical @args
    ║ │                     │   │   │ │     ├◙ SVal "utf8" :named("encoding")
    ║ │                     │   │   │ │     ├◙ SVal "ascii iso-8859-1" :named("transcode")
    ║ │                     │   │   │ │     └○ lexical $stagestats :named("stagestats")
    ║ │                     │   │   │ └─:Stmts
    ║ │                     │   │   │   └◙ WVal NQPMu
    ║ │                     │   │   ├► "CATCH" (str)
    ║ │                     │   │   └─:Stmts
    ║ │                     │   │     ├─call
    ║ │                     │   │     │ ├─:Block  ««"{\n                    $error := $_;\n             "...
    ║ │                     │   │     │ │ ╟○ lexical $_ :decl(param)
    ║ │                     │   │     │ │ ╟─bind
    ║ │                     │   │     │ │ ║ ├○ lexical $! :decl(var)
    ║ │                     │   │     │ │ ║ └○ lexical $_
    ║ │                     │   │     │ │ ╟─:Stmts
    ║ │                     │   │     │ │ ╙─:Stmts  ««"\n                    $error := $_;\n                "
    ║ │                     │   │     │ │   └─:Stmts
    ║ │                     │   │     │ │     └─bind &infix:<:=>  ««":="
    ║ │                     │   │     │ │       ├○ lexical $error
    ║ │                     │   │     │ │       └○ lexical $_
    ║ │                     │   │     │ └─exception
    ║ │                     │   │     ├─:VM
    ║ │                     │   │     └◙ WVal NQPMu
    ║ │                     │   ├► "CATCH" (str)
    ║ │                     │   └─:Stmts
    ║ │                     │     ├─:VM
    ║ │                     │     └◙ WVal NQPMu
    ║ │                     ├─:Stmts
    ║ │                     │ └─unless  ««"$error {\n                if nqp::isnull($result) {"...
    ║ │                     │   ├○ lexical $error
    ║ │                     │   └─:Stmts  ««"{\n                if nqp::isnull($result) {   # re"...
    ║ │                     │     ├─:Stmts
    ║ │                     │     └─:Stmts  ««"\n                if nqp::isnull($result) {   # ret"...
    ║ │                     │       ├─:Stmts
    ║ │                     │       │ └─if  ««"nqp::isnull($result) {   # returning non-null means"...
    ║ │                     │       │   ├─isnull  ««"nqp::isnull($result)"
    ║ │                     │       │   │ └○ lexical $result
    ║ │                     │       │   └─:Stmts  ««"{   # returning non-null means: \"yes, we did compi"...
    ║ │                     │       │     ├─:Stmts
    ║ │                     │       │     └─:Stmts  ««"   # returning non-null means: \"yes, we did compil"...
    ║ │                     │       │       └─:Stmts
    ║ │                     │       │         └─if  ««"$target eq 'mbc' {\n                        $result"...
    ║ │                     │       │           ├─iseq_s &infix:<eq>  ««"eq"
    ║ │                     │       │           │ ├○ lexical $target
    ║ │                     │       │           │ └◙ SVal "mbc"
    ║ │                     │       │           ├─:Stmts  ««"{\n                        $result := $vm_path;\n  "...
    ║ │                     │       │           │ ├─:Stmts
    ║ │                     │       │           │ └─:Stmts  ««"\n                        $result := $vm_path;\n   "...
    ║ │                     │       │           │   └─:Stmts
    ║ │                     │       │           │     └─bind &infix:<:=>  ««":="
    ║ │                     │       │           │       ├○ lexical $result
    ║ │                     │       │           │       └○ lexical $vm_path
    ║ │                     │       │           └─:Stmts  ««"{\n                        nqp::die(\"??? - success"...
    ║ │                     │       │             ├─:Stmts
    ║ │                     │       │             └─:Stmts  ««"\n                        nqp::die(\"??? - successf"...
    ║ │                     │       │               └─:Stmts
    ║ │                     │       │                 └─die  ««"nqp::die(\"??? - successfully compiled $src_path to"...
    ║ │                     │       │                   └─concat
    ║ │                     │       │                     ├─concat
    ║ │                     │       │                     │ ├─concat
    ║ │                     │       │                     │ │ ├─concat
    ║ │                     │       │                     │ │ │ ├◙ SVal "??? - successfully compiled "
    ║ │                     │       │                     │ │ │ └○ lexical $src_path
    ║ │                     │       │                     │ │ └◙ SVal " to target "
    ║ │                     │       │                     │ └○ lexical $target
    ║ │                     │       │                     └◙ SVal " - but got null result...!?"
    ║ │                     │       └─:Stmts
    ║ │                     │         └─call RETURN
    ║ │                     │           └○ lexical $result
    ║ │                     ├─:Stmts
    ║ │                     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$msg := nqp::getmessage($error)"
    ║ │                     │   ├○ lexical $msg
    ║ │                     │   └─getmessage  ««"nqp::getmessage($error)"
    ║ │                     │     └○ lexical $error
    ║ │                     ├─:Stmts
    ║ │                     │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$msglc := nqp::lc($msg)"
    ║ │                     │   ├○ lexical $msglc
    ║ │                     │   └─lc  ««"nqp::lc($msg)"
    ║ │                     │     └○ lexical $msg
    ║ │                     ├─:Stmts
    ║ │                     │ └○ lexical $from
    ║ │                     ├─:Stmts
    ║ │                     │ └○ lexical $to
    ║ │                     ├─:Stmts
    ║ │                     │ └─if  ««"nqp::index($msglc, 'no such file') > -1 {\n        "...
    ║ │                     │   ├─isgt_n &infix:<>>  ««">"
    ║ │                     │   │ ├─index  ««"nqp::index($msglc, 'no such file')"
    ║ │                     │   │ │ ├○ lexical $msglc
    ║ │                     │   │ │ └◙ SVal "no such file"
    ║ │                     │   │ └◙ IVal -1
    ║ │                     │   ├─:Block :blocktype(immediate)  ««"{\n                $from := nqp::index($msglc, '\\'"...
    ║ │                     │   │ ╟─:Stmts
    ║ │                     │   │ ║ └○ lexical $file :decl(var)
    ║ │                     │   │ ╙─:Stmts  ««"\n                $from := nqp::index($msglc, '\\''"...
    ║ │                     │   │   ├─:Stmts
    ║ │                     │   │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │   │   │   ├○ lexical $from
    ║ │                     │   │   │   └─add_n &infix:<+>  ««"+"
    ║ │                     │   │   │     ├─index  ««"nqp::index($msglc, '\\'')"
    ║ │                     │   │   │     │ ├○ lexical $msglc
    ║ │                     │   │   │     │ └◙ SVal "'"
    ║ │                     │   │   │     └◙ IVal 1
    ║ │                     │   │   ├─:Stmts
    ║ │                     │   │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │   │   │   ├○ lexical $to
    ║ │                     │   │   │   └─index  ««"nqp::index($msglc, '\\'', $from)"
    ║ │                     │   │   │     ├○ lexical $msglc
    ║ │                     │   │   │     ├◙ SVal "'"
    ║ │                     │   │   │     └○ lexical $from
    ║ │                     │   │   ├─:Stmts
    ║ │                     │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$file := nqp::substr($msg, $from, $to - $from)"
    ║ │                     │   │   │   ├○ lexical $file
    ║ │                     │   │   │   └─substr  ««"nqp::substr($msg, $from, $to - $from)"
    ║ │                     │   │   │     ├○ lexical $msg
    ║ │                     │   │   │     ├○ lexical $from
    ║ │                     │   │   │     └─sub_n &infix:<->  ««"-"
    ║ │                     │   │   │       ├○ lexical $to
    ║ │                     │   │   │       └○ lexical $from
    ║ │                     │   │   └─:Stmts
    ║ │                     │   │     └─call &say  ««"'Error: missing module \"', $file ~ '\" (original e"...
    ║ │                     │   │       ├◙ SVal "Error: missing module \""
    ║ │                     │   │       └─concat &infix:<~>  ««"~"
    ║ │                     │   │         ├─concat &infix:<~>  ««"~"
    ║ │                     │   │         │ ├─concat &infix:<~>  ««"~"
    ║ │                     │   │         │ │ ├○ lexical $file
    ║ │                     │   │         │ │ └◙ SVal "\" (original error: \""
    ║ │                     │   │         │ └─escape  ««"nqp::escape($msg)"
    ║ │                     │   │         │   └○ lexical $msg
    ║ │                     │   │         └◙ SVal "\")"
    ║ │                     │   └─if  ««"nqp::index($msglc, 'unable to write bytecode') > -1"...
    ║ │                     │     ├─isgt_n &infix:<>>  ««">"
    ║ │                     │     │ ├─index  ««"nqp::index($msglc, 'unable to write bytecode')"
    ║ │                     │     │ │ ├○ lexical $msglc
    ║ │                     │     │ │ └◙ SVal "unable to write bytecode"
    ║ │                     │     │ └◙ IVal -1
    ║ │                     │     ├─:Block :blocktype(immediate)  ««"{\n                $from := nqp::index($msglc, '\\'"...
    ║ │                     │     │ ╟─:Stmts
    ║ │                     │     │ ║ ├○ lexical $file :decl(var)
    ║ │                     │     │ ║ └○ lexical $line :decl(var)
    ║ │                     │     │ ╙─:Stmts  ««"\n                $from := nqp::index($msglc, '\\''"...
    ║ │                     │     │   ├─:Stmts
    ║ │                     │     │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │     │   │   ├○ lexical $from
    ║ │                     │     │   │   └─add_n &infix:<+>  ««"+"
    ║ │                     │     │   │     ├─index  ««"nqp::index($msglc, '\\'')"
    ║ │                     │     │   │     │ ├○ lexical $msglc
    ║ │                     │     │   │     │ └◙ SVal "'"
    ║ │                     │     │   │     └◙ IVal 1
    ║ │                     │     │   ├─:Stmts
    ║ │                     │     │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │     │   │   ├○ lexical $to
    ║ │                     │     │   │   └─index  ««"nqp::index($msglc, '\\'', $from)"
    ║ │                     │     │   │     ├○ lexical $msglc
    ║ │                     │     │   │     ├◙ SVal "'"
    ║ │                     │     │   │     └○ lexical $from
    ║ │                     │     │   ├─:Stmts
    ║ │                     │     │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$file := nqp::substr($msg, $from, $to - $from)"
    ║ │                     │     │   │   ├○ lexical $file
    ║ │                     │     │   │   └─substr  ««"nqp::substr($msg, $from, $to - $from)"
    ║ │                     │     │   │     ├○ lexical $msg
    ║ │                     │     │   │     ├○ lexical $from
    ║ │                     │     │   │     └─sub_n &infix:<->  ««"-"
    ║ │                     │     │   │       ├○ lexical $to
    ║ │                     │     │   │       └○ lexical $from
    ║ │                     │     │   ├─:Stmts
    ║ │                     │     │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$line := 1"
    ║ │                     │     │   │   ├○ lexical $line
    ║ │                     │     │   │   └◙ IVal 1
    ║ │                     │     │   └─:Stmts
    ║ │                     │     │     └─bind &infix:<:=>  ««":="
    ║ │                     │     │       ├○ lexical $msg
    ║ │                     │     │       └─join  ««"nqp::join('', [\n                          'Error: "...
    ║ │                     │     │         ├◙ SVal ""
    ║ │                     │     │         └─list &circumfix:<[ ]>  ««","
    ║ │                     │     │           ├◙ SVal "Error: "
    ║ │                     │     │           ├○ lexical $msg
    ║ │                     │     │           ├◙ SVal "\n"
    ║ │                     │     │           ├◙ SVal "  at "
    ║ │                     │     │           ├○ lexical $src_path
    ║ │                     │     │           ├◙ SVal ":"
    ║ │                     │     │           ├─stringify &prefix:<~>  ««"~"
    ║ │                     │     │           │ └○ lexical $line
    ║ │                     │     │           └◙ SVal "\n"
    ║ │                     │     └─if  ««"nqp::index($msglc, 'confused') > -1 {\n            "...
    ║ │                     │       ├─isgt_n &infix:<>>  ««">"
    ║ │                     │       │ ├─index  ««"nqp::index($msglc, 'confused')"
    ║ │                     │       │ │ ├○ lexical $msglc
    ║ │                     │       │ │ └◙ SVal "confused"
    ║ │                     │       │ └◙ IVal -1
    ║ │                     │       ├─:Block :blocktype(immediate)  ««"{\n                $from := nqp::index($msglc, 'at "...
    ║ │                     │       │ ╟─:Stmts
    ║ │                     │       │ ║ └○ lexical $line :decl(var)
    ║ │                     │       │ ╙─:Stmts  ««"\n                $from := nqp::index($msglc, 'at l"...
    ║ │                     │       │   ├─:Stmts
    ║ │                     │       │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │       │   │   ├○ lexical $from
    ║ │                     │       │   │   └─add_n &infix:<+>  ««"+"
    ║ │                     │       │   │     ├─index  ««"nqp::index($msglc, 'at line')"
    ║ │                     │       │   │     │ ├○ lexical $msglc
    ║ │                     │       │   │     │ └◙ SVal "at line"
    ║ │                     │       │   │     └◙ IVal 1
    ║ │                     │       │   ├─:Stmts
    ║ │                     │       │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │       │   │   ├○ lexical $from
    ║ │                     │       │   │   └─findcclass  ««"nqp::findcclass(nqp::const::CCLASS_NUMERIC, $msglc,"...
    ║ │                     │       │   │     ├─const CCLASS_NUMERIC
    ║ │                     │       │   │     ├○ lexical $msglc
    ║ │                     │       │   │     ├○ lexical $from
    ║ │                     │       │   │     └─sub_n &infix:<->  ««"-"
    ║ │                     │       │   │       ├─chars  ««"nqp::chars($msglc)"
    ║ │                     │       │   │       │ └○ lexical $msglc
    ║ │                     │       │   │       └○ lexical $from
    ║ │                     │       │   ├─:Stmts
    ║ │                     │       │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │       │   │   ├○ lexical $to
    ║ │                     │       │   │   └─findnotcclass  ««"nqp::findnotcclass(nqp::const::CCLASS_NUMERIC, $msg"...
    ║ │                     │       │   │     ├─const CCLASS_NUMERIC
    ║ │                     │       │   │     ├○ lexical $msglc
    ║ │                     │       │   │     ├○ lexical $from
    ║ │                     │       │   │     └─sub_n &infix:<->  ««"-"
    ║ │                     │       │   │       ├─chars  ««"nqp::chars($msglc)"
    ║ │                     │       │   │       │ └○ lexical $msglc
    ║ │                     │       │   │       └○ lexical $from
    ║ │                     │       │   ├─:Stmts
    ║ │                     │       │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$line := nqp::substr($msg, $from, $to - $from)"
    ║ │                     │       │   │   ├○ lexical $line
    ║ │                     │       │   │   └─substr  ««"nqp::substr($msg, $from, $to - $from)"
    ║ │                     │       │   │     ├○ lexical $msg
    ║ │                     │       │   │     ├○ lexical $from
    ║ │                     │       │   │     └─sub_n &infix:<->  ««"-"
    ║ │                     │       │   │       ├○ lexical $to
    ║ │                     │       │   │       └○ lexical $from
    ║ │                     │       │   ├─:Stmts
    ║ │                     │       │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │       │   │   ├○ lexical $line
    ║ │                     │       │   │   └─call &max  ««"1, $line - 1"
    ║ │                     │       │   │     ├◙ IVal 1
    ║ │                     │       │   │     └─sub_n &infix:<->  ««"-"
    ║ │                     │       │   │       ├○ lexical $line
    ║ │                     │       │   │       └◙ IVal 1
    ║ │                     │       │   ├─:Stmts
    ║ │                     │       │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │       │   │   ├○ lexical $msg
    ║ │                     │       │   │   └─concat &infix:<~>  ««"~"
    ║ │                     │       │   │     ├─concat &infix:<~>  ««"~"
    ║ │                     │       │   │     │ ├─substr  ««"nqp::substr($msg, 0, $from)"
    ║ │                     │       │   │     │ │ ├○ lexical $msg
    ║ │                     │       │   │     │ │ ├◙ IVal 0
    ║ │                     │       │   │     │ │ └○ lexical $from
    ║ │                     │       │   │     │ └○ lexical $line
    ║ │                     │       │   │     └─substr  ««"nqp::substr($msg, $to)"
    ║ │                     │       │   │       ├○ lexical $msg
    ║ │                     │       │   │       └○ lexical $to
    ║ │                     │       │   └─:Stmts
    ║ │                     │       │     └─bind &infix:<:=>  ««":="
    ║ │                     │       │       ├○ lexical $msg
    ║ │                     │       │       └─join  ««"nqp::join('', [\n                          'Error: "...
    ║ │                     │       │         ├◙ SVal ""
    ║ │                     │       │         └─list &circumfix:<[ ]>  ««","
    ║ │                     │       │           ├◙ SVal "Error: "
    ║ │                     │       │           ├○ lexical $msg
    ║ │                     │       │           ├◙ SVal "\n"
    ║ │                     │       │           ├◙ SVal "  at "
    ║ │                     │       │           ├○ lexical $src_path
    ║ │                     │       │           ├◙ SVal ":"
    ║ │                     │       │           ├─stringify &prefix:<~>  ««"~"
    ║ │                     │       │           │ └○ lexical $line
    ║ │                     │       │           └◙ SVal "\n"
    ║ │                     │       └─if  ««"nqp::index($msglc, 'assignment (\"=\") not supporte"...
    ║ │                     │         ├─isgt_n &infix:<>>  ««">"
    ║ │                     │         │ ├─index  ««"nqp::index($msglc, 'assignment (\"=\") not supporte"...
    ║ │                     │         │ │ ├○ lexical $msglc
    ║ │                     │         │ │ └◙ SVal "assignment (\"=\") not supported "
    ║ │                     │         │ └◙ IVal -1
    ║ │                     │         ├─:Block :blocktype(immediate)  ««"{\n                $from := nqp::index($msglc, 'at "...
    ║ │                     │         │ ╟─:Stmts
    ║ │                     │         │ ║ ├○ lexical $line :decl(var)
    ║ │                     │         │ ║ ├○ lexical @lines :decl(var)
    ║ │                     │         │ ║ ├○ lexical $i :decl(var)
    ║ │                     │         │ ║ ├○ lexical $n :decl(var)
    ║ │                     │         │ ║ └─bind  ««"$column"
    ║ │                     │         │ ║   ├○ lexical $column :decl(var)
    ║ │                     │         │ ║   └◙ WVal NQPMu
    ║ │                     │         │ ╙─:Stmts  ««"\n                $from := nqp::index($msglc, 'at l"...
    ║ │                     │         │   ├─:Stmts
    ║ │                     │         │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │         │   │   ├○ lexical $from
    ║ │                     │         │   │   └─add_n &infix:<+>  ««"+"
    ║ │                     │         │   │     ├─index  ««"nqp::index($msglc, 'at line')"
    ║ │                     │         │   │     │ ├○ lexical $msglc
    ║ │                     │         │   │     │ └◙ SVal "at line"
    ║ │                     │         │   │     └◙ IVal 1
    ║ │                     │         │   ├─:Stmts
    ║ │                     │         │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │         │   │   ├○ lexical $from
    ║ │                     │         │   │   └─findcclass  ««"nqp::findcclass(nqp::const::CCLASS_NUMERIC, $msglc,"...
    ║ │                     │         │   │     ├─const CCLASS_NUMERIC
    ║ │                     │         │   │     ├○ lexical $msglc
    ║ │                     │         │   │     ├○ lexical $from
    ║ │                     │         │   │     └─sub_n &infix:<->  ««"-"
    ║ │                     │         │   │       ├─chars  ««"nqp::chars($msglc)"
    ║ │                     │         │   │       │ └○ lexical $msglc
    ║ │                     │         │   │       └○ lexical $from
    ║ │                     │         │   ├─:Stmts
    ║ │                     │         │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │         │   │   ├○ lexical $to
    ║ │                     │         │   │   └─findnotcclass  ««"nqp::findnotcclass(nqp::const::CCLASS_NUMERIC, $msg"...
    ║ │                     │         │   │     ├─const CCLASS_NUMERIC
    ║ │                     │         │   │     ├○ lexical $msglc
    ║ │                     │         │   │     ├○ lexical $from
    ║ │                     │         │   │     └─sub_n &infix:<->  ««"-"
    ║ │                     │         │   │       ├─chars  ««"nqp::chars($msglc)"
    ║ │                     │         │   │       │ └○ lexical $msglc
    ║ │                     │         │   │       └○ lexical $from
    ║ │                     │         │   ├─:Stmts
    ║ │                     │         │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$line := nqp::substr($msg, $from, $to - $from)"
    ║ │                     │         │   │   ├○ lexical $line
    ║ │                     │         │   │   └─substr  ««"nqp::substr($msg, $from, $to - $from)"
    ║ │                     │         │   │     ├○ lexical $msg
    ║ │                     │         │   │     ├○ lexical $from
    ║ │                     │         │   │     └─sub_n &infix:<->  ««"-"
    ║ │                     │         │   │       ├○ lexical $to
    ║ │                     │         │   │       └○ lexical $from
    ║ │                     │         │   ├─:Stmts
    ║ │                     │         │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │         │   │   ├○ lexical $line
    ║ │                     │         │   │   └─call &max  ««"1, $line - 1"
    ║ │                     │         │   │     ├◙ IVal 1
    ║ │                     │         │   │     └─sub_n &infix:<->  ««"-"
    ║ │                     │         │   │       ├○ lexical $line
    ║ │                     │         │   │       └◙ IVal 1
    ║ │                     │         │   ├─:Stmts
    ║ │                     │         │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"@lines := linesFrom($src_path, $line, 2)"
    ║ │                     │         │   │   ├○ lexical @lines
    ║ │                     │         │   │   └─call &linesFrom  ««"$src_path, $line, 2"
    ║ │                     │         │   │     ├○ lexical $src_path
    ║ │                     │         │   │     ├○ lexical $line
    ║ │                     │         │   │     └◙ IVal 2
    ║ │                     │         │   ├─:Stmts
    ║ │                     │         │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$i := 0"
    ║ │                     │         │   │   ├○ lexical $i
    ║ │                     │         │   │   └◙ IVal 0
    ║ │                     │         │   ├─:Stmts
    ║ │                     │         │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$n := nqp::elems(@lines)"
    ║ │                     │         │   │   ├○ lexical $n
    ║ │                     │         │   │   └─elems  ««"nqp::elems(@lines)"
    ║ │                     │         │   │     └○ lexical @lines
    ║ │                     │         │   ├─:Stmts
    ║ │                     │         │   │ └○ lexical $column
    ║ │                     │         │   ├─:Stmts
    ║ │                     │         │   │ └─while  ««"$i < $n {\n                    my $line := @lines[$"...
    ║ │                     │         │   │   ├─islt_n &infix:<<>  ««"<"
    ║ │                     │         │   │   │ ├○ lexical $i
    ║ │                     │         │   │   │ └○ lexical $n
    ║ │                     │         │   │   ├─:Block :blocktype(immediate)  ««"{\n                    my $line := @lines[$i];\n   "...
    ║ │                     │         │   │   │ ╟─:Stmts
    ║ │                     │         │   │   │ ║ ├○ lexical $line :decl(var)
    ║ │                     │         │   │   │ ║ └○ lexical $at :decl(var)
    ║ │                     │         │   │   │ ╙─:Stmts  ««"\n                    my $line := @lines[$i];\n    "...
    ║ │                     │         │   │   │   ├─:Stmts
    ║ │                     │         │   │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$line := @lines[$i]"
    ║ │                     │         │   │   │   │   ├○ lexical $line
    ║ │                     │         │   │   │   │   └○┬VarWithFallback positional  :fallback(WVal NQPMu)
    ║ │                     │         │   │   │   │     ├○ lexical @lines
    ║ │                     │         │   │   │   │     └○ lexical $i
    ║ │                     │         │   │   │   ├─:Stmts
    ║ │                     │         │   │   │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$at := nqp::index($line, '=')"
    ║ │                     │         │   │   │   │   ├○ lexical $at
    ║ │                     │         │   │   │   │   └─index  ««"nqp::index($line, '=')"
    ║ │                     │         │   │   │   │     ├○ lexical $line
    ║ │                     │         │   │   │   │     └◙ SVal "="
    ║ │                     │         │   │   │   └─:Stmts
    ║ │                     │         │   │   │     └─if  ««"$at > -1 {\n                        $column := $at "...
    ║ │                     │         │   │   │       ├─isgt_n &infix:<>>  ««">"
    ║ │                     │         │   │   │       │ ├○ lexical $at
    ║ │                     │         │   │   │       │ └◙ IVal -1
    ║ │                     │         │   │   │       ├─:Stmts  ««"{\n                        $column := $at + 1;\n   "...
    ║ │                     │         │   │   │       │ ├─:Stmts
    ║ │                     │         │   │   │       │ └─:Stmts  ««"\n                        $column := $at + 1;\n    "...
    ║ │                     │         │   │   │       │   ├─:Stmts
    ║ │                     │         │   │   │       │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │         │   │   │       │   │   ├○ lexical $column
    ║ │                     │         │   │   │       │   │   └─add_n &infix:<+>  ««"+"
    ║ │                     │         │   │   │       │   │     ├○ lexical $at
    ║ │                     │         │   │   │       │   │     └◙ IVal 1
    ║ │                     │         │   │   │       │   └─:Stmts
    ║ │                     │         │   │   │       │     └─bind &infix:<:=>  ««":="
    ║ │                     │         │   │   │       │       ├○ lexical $i
    ║ │                     │         │   │   │       │       └○ lexical $n
    ║ │                     │         │   │   │       └─:Stmts  ««"{\n                        $i++;\n                 "...
    ║ │                     │         │   │   │         ├─:Stmts
    ║ │                     │         │   │   │         └─:Stmts  ««"\n                        $i++;\n                  "...
    ║ │                     │         │   │   │           ├─:Stmts
    ║ │                     │         │   │   │           │ └─postinc &postfix:<++>  ««"++"
    ║ │                     │         │   │   │           │   └○ lexical $i
    ║ │                     │         │   │   │           └─:Stmts
    ║ │                     │         │   │   │             └─postinc &postfix:<++>  ««"++"
    ║ │                     │         │   │   │               └○ lexical $line
    ║ │                     │         │   │   └◙ IVal 1 :named("nohandler")
    ║ │                     │         │   ├─:Stmts
    ║ │                     │         │   │ └─bind &infix:<:=>  ««":="
    ║ │                     │         │   │   ├○ lexical $msg
    ║ │                     │         │   │   └─concat &infix:<~>  ««"~"
    ║ │                     │         │   │     ├─concat &infix:<~>  ««"~"
    ║ │                     │         │   │     │ ├─substr  ««"nqp::substr($msg, 0, $from)"
    ║ │                     │         │   │     │ │ ├○ lexical $msg
    ║ │                     │         │   │     │ │ ├◙ IVal 0
    ║ │                     │         │   │     │ │ └○ lexical $from
    ║ │                     │         │   │     │ └○ lexical $line
    ║ │                     │         │   │     └─substr  ««"nqp::substr($msg, $to)"
    ║ │                     │         │   │       ├○ lexical $msg
    ║ │                     │         │   │       └○ lexical $to
    ║ │                     │         │   └─:Stmts
    ║ │                     │         │     └─bind &infix:<:=>  ««":="
    ║ │                     │         │       ├○ lexical $msg
    ║ │                     │         │       └─join  ««"nqp::join('', [\n                          'Error: "...
    ║ │                     │         │         ├◙ SVal ""
    ║ │                     │         │         └─list &circumfix:<[ ]>  ««","
    ║ │                     │         │           ├◙ SVal "Error: "
    ║ │                     │         │           ├○ lexical $msg
    ║ │                     │         │           ├◙ SVal "\n"
    ║ │                     │         │           ├◙ SVal "   at "
    ║ │                     │         │           ├○ lexical $src_path
    ║ │                     │         │           ├◙ SVal ":"
    ║ │                     │         │           ├─stringify &prefix:<~>  ««"~"
    ║ │                     │         │           │ └○ lexical $line
    ║ │                     │         │           ├─if &infix:<>  ««"?? ':' ~ $column !!"
    ║ │                     │         │           │ ├○ lexical $column
    ║ │                     │         │           │ ├─concat &infix:<~>  ««"~"
    ║ │                     │         │           │ │ ├◙ SVal ":"
    ║ │                     │         │           │ │ └○ lexical $column
    ║ │                     │         │           │ └◙ SVal ""
    ║ │                     │         │           └◙ SVal "\n"
    ║ │                     │         └─if  ««"0 {\n                my $line := 1;\n              "...
    ║ │                     │           ├◙ IVal 0
    ║ │                     │           ├─:Block :blocktype(immediate)  ««"{\n                my $line := 1;\n                "...
    ║ │                     │           │ ╟─:Stmts
    ║ │                     │           │ ║ ├○ lexical $line :decl(var)
    ║ │                     │           │ ║ └─bind  ««"$column"
    ║ │                     │           │ ║   ├○ lexical $column :decl(var)
    ║ │                     │           │ ║   └◙ WVal NQPMu
    ║ │                     │           │ ╙─:Stmts  ««"\n                my $line := 1;\n                m"...
    ║ │                     │           │   ├─:Stmts
    ║ │                     │           │   │ └─bind :annotations(#`{BOOTHash:}nqp::hash( "var_initialized", 1 (int) ))  ««"$line := 1"
    ║ │                     │           │   │   ├○ lexical $line
    ║ │                     │           │   │   └◙ IVal 1
    ║ │                     │           │   ├─:Stmts
    ║ │                     │           │   │ └○ lexical $column
    ║ │                     │           │   └─:Stmts
    ║ │                     │           │     └─bind &infix:<:=>  ««":="
    ║ │                     │           │       ├○ lexical $msg
    ║ │                     │           │       └─join  ««"nqp::join('', [\n                          'ERROR: "...
    ║ │                     │           │         ├◙ SVal ""
    ║ │                     │           │         └─list &circumfix:<[ ]>  ««","
    ║ │                     │           │           ├◙ SVal "ERROR: "
    ║ │                     │           │           ├○ lexical $msg
    ║ │                     │           │           ├◙ SVal "\n"
    ║ │                     │           │           ├◙ SVal "   at "
    ║ │                     │           │           ├○ lexical $src_path
    ║ │                     │           │           ├◙ SVal ":"
    ║ │                     │           │           ├─stringify &prefix:<~>  ««"~"
    ║ │                     │           │           │ └○ lexical $line
    ║ │                     │           │           ├─if &infix:<>  ««"?? ':' ~ $column !!"
    ║ │                     │           │           │ ├○ lexical $column
    ║ │                     │           │           │ ├─concat &infix:<~>  ««"~"
    ║ │                     │           │           │ │ ├◙ SVal ":"
    ║ │                     │           │           │ │ └○ lexical $column
    ║ │                     │           │           │ └◙ SVal ""
    ║ │                     │           │           └◙ SVal "\n"
    ║ │                     │           └─:Stmts  ««"{\n                $msg := $msg ~ nqp::join(\"\\n\""...
    ║ │                     │             ├─:Stmts
    ║ │                     │             └─:Stmts  ««"\n                $msg := $msg ~ nqp::join(\"\\n\","...
    ║ │                     │               └─:Stmts
    ║ │                     │                 └─bind &infix:<:=>  ««":="
    ║ │                     │                   ├○ lexical $msg
    ║ │                     │                   └─concat &infix:<~>  ««"~"
    ║ │                     │                     ├○ lexical $msg
    ║ │                     │                     └─join  ««"nqp::join(\"\\n\", nqp::backtracestrings($error))"
    ║ │                     │                       ├◙ SVal "\n"
    ║ │                     │                       └─backtracestrings  ««"nqp::backtracestrings($error)"
    ║ │                     │                         └○ lexical $error
    ║ │                     ├─:Stmts
    ║ │                     │ └─flushfh  ««"nqp::flushfh(nqp::getstdout())"
    ║ │                     │   └─getstdout  ««"nqp::getstdout()"
    ║ │                     └─:Stmts
    ║ │                       └─die  ««"nqp::die($msg)"
    ║ │                         └○ lexical $msg
    ║ ├─:Stmts
    ║ │ └○ lexical &flatten
    ║ ├─:Stmts
    ║ │ └○ lexical &MAIN
    ║ └─if
    ║   ├○ lexical @ARGS
    ║   └─call &MAIN
    ║     └○ lexical @ARGS :flat(1)
    ╙─:Stmts