──:CompUnit+{StrByDump}
  └─:Block "<mainline>"
    ╟○ @ARGS :decl(param) :slurpy(1)
    ╟○ GLOBALish :decl(static) :default((GLOBALish, Type object))
    ╟○ $?PACKAGE :decl(static) :default((GLOBALish, Type object))
    ╟○ EXPORT :decl(static) :default((EXPORT, Type object))
    ╟─bind
    ║ ├○ @?DEPENDENCIES :decl(static)
    ║ └─list
    ║   ├◙ SVal "nqp"
    ║   ├◙ SVal "NQPHLL"
    ║   ├◙ SVal "Util"
    ║   └◙ SVal "Util::QAST"
    ╟○ &trim :decl(static) :default((NQPRoutine, invokable))
    ╟○ &istype :decl(static) :default((NQPRoutine, invokable))
    ╟○ &describe :decl(static) :default((NQPRoutine, invokable))
    ╟○ &insist-isa :decl(static) :default((NQPRoutine, invokable))
    ╟○ &min :decl(static) :default((NQPRoutine, invokable))
    ╟○ &max :decl(static) :default((NQPRoutine, invokable))
    ╟○ &say :decl(static) :default((NQPRoutine, invokable))
    ╟○ &flatten :decl(static) :default((NQPRoutine, invokable))
    ╟○ &super :decl(static) :default((NQPRoutine, invokable))
    ╟○ &unixify :decl(static) :default((NQPRoutine, invokable))
    ╟○ &howName :decl(static) :default((NQPRoutine, invokable))
    ╟○ &join :decl(static) :default((NQPRoutine, invokable))
    ╟○ &linesFrom :decl(static) :default((NQPRoutine, invokable))
    ╟○ &renameVars :decl(static) :default((NQPRoutine, invokable))
    ╟○ &isVar :decl(static) :default((NQPRoutine, invokable))
    ╟○ StrByDump :decl(static) :default((StrByDump, Type object))
    ╟○ &findPath :decl(static) :default((NQPRoutine, invokable))
    ╟○ &remove_bogusOpNames :decl(static) :default((NQPRoutine, invokable))
    ╟○ &cloneAndSubst :decl(static) :default((NQPRoutine, invokable))
    ╟○ &findPaths :decl(static) :default((NQPRoutine, invokable))
    ╟○ &fix_var_attrs :decl(static) :default((NQPRoutine, invokable))
    ╟○ &drop_takeclosure :decl(static) :default((NQPRoutine, invokable))
    ╟○ &collect_params_and_body :decl(static) :default((NQPRoutine, invokable))
    ╟○ &isVal :decl(static) :default((NQPRoutine, invokable))
    ╟○ &isOp :decl(static) :default((NQPRoutine, invokable))
    ╟○ &dump :decl(static) :default((NQPRoutine, invokable))
    ╟○ &removeChild :decl(static) :default((NQPRoutine, invokable))
    ╟○ &inline_simple_subs :decl(static) :default((NQPRoutine, invokable))
    ╟○ &isNVal :decl(static) :default((NQPRoutine, invokable))
    ╟○ &replace_assoc_and_pos_scoped :decl(static) :default((NQPRoutine, invokable))
    ╟○ &qastChildren :decl(static) :default((NQPRoutine, invokable))
    ╟○ &drop_Stmts :decl(static) :default((NQPRoutine, invokable))
    ╟○ &inline_simple_methods :decl(static) :default((NQPRoutine, invokable))
    ╟○ &isSVal :decl(static) :default((NQPRoutine, invokable))
    ╟○ &isIVal :decl(static) :default((NQPRoutine, invokable))
    ╟○ NO_VALUE :decl(static) :default((NO_VALUE, Type object))
    ╟─bind
    ║ ├○ &isinResultPosition :decl(var)
    ║ └─:Block "isinResultPosition"  ««"{\n    my $n := nqp::elems($parent) - 1;\n    if ($"...
    ║   ╟○ $node :decl(param)
    ║   ╟○ $parent :decl(param)
    ║   ╟○ $n :decl(var)
    ║   ╙─lexotic RETURN
    ║     └─:Stmts  ««"\n    my $n := nqp::elems($parent) - 1;\n    if ($p"...
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$n := nqp::elems($parent) - 1"
    ║       │ ├○ $n
    ║       │ └─sub_n  ««"-"
    ║       │   ├─elems  ««"nqp::elems($parent)"
    ║       │   │ └○ $parent
    ║       │   └◙ IVal 1
    ║       ├─if  ««"($parent[$n] =:= $node) || (nqp::can($parent, 'resu"...
    ║       │ ├─unless  ««"||"
    ║       │ │ ├─eqaddr  ««"=:="
    ║       │ │ │ ├─ifnull
    ║       │ │ │ │ ├─atpos
    ║       │ │ │ │ │ ├○ $parent
    ║       │ │ │ │ │ └○ $n
    ║       │ │ │ │ └◙ WVal NQPMu
    ║       │ │ │ └○ $node
    ║       │ │ └─if  ««"&&"
    ║       │ │   ├─can  ««"nqp::can($parent, 'resultchild')"
    ║       │ │   │ ├○ $parent
    ║       │ │   │ └◙ SVal "resultchild"
    ║       │ │   └─eqaddr  ««"=:="
    ║       │ │     ├─ifnull
    ║       │ │     │ ├─atpos
    ║       │ │     │ │ ├○ $parent
    ║       │ │     │ │ └─callmethod resultchild  ««".resultchild"
    ║       │ │     │ │   └○ $parent
    ║       │ │     │ └◙ WVal NQPMu
    ║       │ │     └○ $node
    ║       │ └─call RETURN
    ║       │   └◙ IVal 1
    ║       ├─while  ««"--$n >= 0 {\n        return 0 if $node =:= $parent["...
    ║       │ ├─isge_n  ««">="
    ║       │ │ ├─predec  ««"--"
    ║       │ │ │ └○ $n
    ║       │ │ └◙ IVal 0
    ║       │ ├─if  ««"return 0 if $node =:= $parent[$n]"
    ║       │ │ ├─eqaddr  ««"=:="
    ║       │ │ │ ├○ $node
    ║       │ │ │ └─ifnull
    ║       │ │ │   ├─atpos
    ║       │ │ │   │ ├○ $parent
    ║       │ │ │   │ └○ $n
    ║       │ │ │   └◙ WVal NQPMu
    ║       │ │ └─call RETURN
    ║       │ │   └◙ IVal 0
    ║       │ └◙ IVal 1 :named("nohandler")
    ║       └─die  ««"nqp::die(describe($node) ~ ' not a child of ' ~ des"...
    ║         └─concat  ««"~"
    ║           ├─concat  ««"~"
    ║           │ ├─call &describe  ««"$node"
    ║           │ │ └○ $node
    ║           │ └◙ SVal " not a child of "
    ║           └─call &describe  ««"$parent"
    ║             └○ $parent
    ╟─bind
    ║ ├○ &drop_bogusVars :decl(var)
    ║ └─:Block "drop_bogusVars"  ««"{\n    insist-isa($ast, QAST::CompUnit);\n    my $b"...
    ║   ╟○ $ast :decl(param)
    ║   ╟○ $block :decl(var)
    ║   ╟○ @children :decl(var)
    ║   ╟─call &insist-isa  ««"$ast, QAST::CompUnit"
    ║   ║ ├○ $ast
    ║   ║ └◙ WVal QAST::CompUnit
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$block := $ast[0]"
    ║   ║ ├○ $block
    ║   ║ └─ifnull
    ║   ║   ├─atpos
    ║   ║   │ ├○ $ast
    ║   ║   │ └◙ IVal 0
    ║   ║   └◙ WVal NQPMu
    ║   ╟─call &insist-isa  ««"$block, QAST::Block"
    ║   ║ ├○ $block
    ║   ║ └◙ WVal QAST::Block
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"@children := $block.list"
    ║   ║ ├○ @children
    ║   ║ └─callmethod list  ««".list"
    ║   ║   └○ $block
    ║   ╟─if  ««"+@children {\n        my $last := @children[+@child"...
    ║   ║ ├─numify  ««"+"
    ║   ║ │ └○ @children
    ║   ║ └─:Block :blocktype(immediate)  ««"{\n        my $last := @children[+@children - 1];\n"...
    ║   ║   ╟○ $last :decl(var)
    ║   ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$last := @children[+@children - 1]"
    ║   ║   ║ ├○ $last
    ║   ║   ║ └─ifnull
    ║   ║   ║   ├─atpos
    ║   ║   ║   │ ├○ @children
    ║   ║   ║   │ └─sub_n  ««"-"
    ║   ║   ║   │   ├─numify  ««"+"
    ║   ║   ║   │   │ └○ @children
    ║   ║   ║   │   └◙ IVal 1
    ║   ║   ║   └◙ WVal NQPMu
    ║   ║   ╙─callmethod dfs-up  ««"\n            -> $n, @p {\n                if $n =:"...
    ║   ║     ├◙ WVal TreeWalk
    ║   ║     ├─:Block  ««"{\n                if $n =:= $block {\n            "...
    ║   ║     │ ╟○ $n :decl(param)
    ║   ║     │ ╟○ @p :decl(param)
    ║   ║     │ ╙─if  ««"$n =:= $block {\n                    TreeWalkDo.rec"...
    ║   ║     │   ├─eqaddr  ««"=:="
    ║   ║     │   │ ├○ $n
    ║   ║     │   │ └○ $block
    ║   ║     │   ├─callmethod recurse  ««".recurse"
    ║   ║     │   │ └◙ WVal TreeWalkDo
    ║   ║     │   └─callmethod return  ««":take(\n                        !($n =:= $last) && "...
    ║   ║     │     ├◙ WVal TreeWalkDo
    ║   ║     │     └─if :named("take")  ««"&&"
    ║   ║     │       ├─if  ««"&&"
    ║   ║     │       │ ├─falsey  ««"!"
    ║   ║     │       │ │ └─eqaddr  ««"=:="
    ║   ║     │       │ │   ├○ $n
    ║   ║     │       │ │   └○ $last
    ║   ║     │       │ └─call &isVar  ««"$n"
    ║   ║     │       │   └○ $n
    ║   ║     │       └─falsey  ««"!"
    ║   ║     │         └─callmethod decl  ««".decl"
    ║   ║     │           └○ $n
    ║   ║     ├─:Block  ««"{ TreeWalk.remove }"
    ║   ║     │ ╟○ $n :decl(param)
    ║   ║     │ ╟○ @p :decl(param)
    ║   ║     │ ╙─callmethod remove  ««".remove"
    ║   ║     │   └◙ WVal TreeWalk
    ║   ║     └○ $block
    ║   ╙○ $ast
    ╟─bind
    ║ ├○ &remove_MAIN :decl(var)
    ║ └─:Block "remove_MAIN"  ««"{\n    say($ast[0].cuid);\n    say(\"CompUnit load:"...
    ║   ╟○ $ast :decl(param)
    ║   ╟○ @path :decl(var)
    ║   ╟○ $MAIN :decl(var)
    ║   ╟○ $MAINcall :decl(var)
    ║   ╟─call &say  ««"$ast[0].cuid"
    ║   ║ └─callmethod cuid  ««".cuid"
    ║   ║   └─ifnull
    ║   ║     ├─atpos
    ║   ║     │ ├○ $ast
    ║   ║     │ └◙ IVal 0
    ║   ║     └◙ WVal NQPMu
    ║   ╟─call &say  ««"\"CompUnit load: \\n\", dump($ast.load)"
    ║   ║ ├◙ SVal "CompUnit load: \n"
    ║   ║ └─call &dump  ««"$ast.load"
    ║   ║   └─callmethod load  ««".load"
    ║   ║     └○ $ast
    ║   ╟─call &say  ««"\"CompUnit main: \\n\", dump($ast.main)"
    ║   ║ ├◙ SVal "CompUnit main: \n"
    ║   ║ └─call &dump  ««"$ast.main"
    ║   ║   └─callmethod main  ««".main"
    ║   ║     └○ $ast
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"@path := []"
    ║   ║ ├○ @path
    ║   ║ └─list
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$MAIN := findDef($ast, '&MAIN', @path)"
    ║   ║ ├○ $MAIN
    ║   ║ └─call &findDef  ««"$ast, '&MAIN', @path"
    ║   ║   ├○ $ast
    ║   ║   ├◙ SVal "&MAIN"
    ║   ║   └○ @path
    ║   ╟─call &removeChild  ««"@path[0], $MAIN"
    ║   ║ ├─ifnull
    ║   ║ │ ├─atpos
    ║   ║ │ │ ├○ @path
    ║   ║ │ │ └◙ IVal 0
    ║   ║ │ └◙ WVal NQPMu
    ║   ║ └○ $MAIN
    ║   ╟─call &say  ««"describe(@path), \"\\n\", describe($MAIN)"
    ║   ║ ├─call &describe  ««"@path"
    ║   ║ │ └○ @path
    ║   ║ ├◙ SVal "\n"
    ║   ║ └─call &describe  ««"$MAIN"
    ║   ║   └○ $MAIN
    ║   ╟─bind  ««":="
    ║   ║ ├○ @path
    ║   ║ └─list
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$MAINcall := findPath(-> $node, @pathUp {\n        "...
    ║   ║ ├○ $MAINcall
    ║   ║ └─call &findPath  ««"-> $node, @pathUp {\n            if istype($node, Q"...
    ║   ║   ├─:Block  ««"{\n            if istype($node, QAST::Op) && ($node"...
    ║   ║   │ ╟○ $node :decl(param)
    ║   ║   │ ╟○ @pathUp :decl(param)
    ║   ║   │ ╙─if  ««"istype($node, QAST::Op) && ($node.op eq 'call') && "...
    ║   ║   │   ├─if  ««"&&"
    ║   ║   │   │ ├─if  ««"&&"
    ║   ║   │   │ │ ├─call &istype  ««"$node, QAST::Op"
    ║   ║   │   │ │ │ ├○ $node
    ║   ║   │   │ │ │ └◙ WVal QAST::Op
    ║   ║   │   │ │ └─iseq_s  ««"eq"
    ║   ║   │   │ │   ├─callmethod op  ««".op"
    ║   ║   │   │ │   │ └○ $node
    ║   ║   │   │ │   └◙ SVal "call"
    ║   ║   │   │ └─unless  ««"||"
    ║   ║   │   │   ├─iseq_s  ««"eq"
    ║   ║   │   │   │ ├─callmethod name  ««".name"
    ║   ║   │   │   │ │ └○ $node
    ║   ║   │   │   │ └◙ SVal "&MAIN"
    ║   ║   │   │   └─if  ««"&&"
    ║   ║   │   │     ├─call &istype  ««"$node[0], QAST::Var"
    ║   ║   │   │     │ ├─ifnull
    ║   ║   │   │     │ │ ├─atpos
    ║   ║   │   │     │ │ │ ├○ $node
    ║   ║   │   │     │ │ │ └◙ IVal 0
    ║   ║   │   │     │ │ └◙ WVal NQPMu
    ║   ║   │   │     │ └◙ WVal QAST::Var
    ║   ║   │   │     └─iseq_s  ««"eq"
    ║   ║   │   │       ├─callmethod name  ««".name"
    ║   ║   │   │       │ └─ifnull
    ║   ║   │   │       │   ├─atpos
    ║   ║   │   │       │   │ ├○ $node
    ║   ║   │   │       │   │ └◙ IVal 0
    ║   ║   │   │       │   └◙ WVal NQPMu
    ║   ║   │   │       └◙ SVal "&MAIN"
    ║   ║   │   ├─:Block :blocktype(immediate)  ««"{\n                my $parent := @pathUp[0];\n     "...
    ║   ║   │   │ ╟○ $parent :decl(var)
    ║   ║   │   │ ╟─bind :annotations({"var_initialized" => 1})  ««"$parent := @pathUp[0]"
    ║   ║   │   │ ║ ├○ $parent
    ║   ║   │   │ ║ └─ifnull
    ║   ║   │   │ ║   ├─atpos
    ║   ║   │   │ ║   │ ├○ @pathUp
    ║   ║   │   │ ║   │ └◙ IVal 0
    ║   ║   │   │ ║   └◙ WVal NQPMu
    ║   ║   │   │ ╙─if  ««"istype($parent, QAST::Op) && $parent.op eq 'if' {\n"...
    ║   ║   │   │   ├─if  ««"&&"
    ║   ║   │   │   │ ├─call &istype  ««"$parent, QAST::Op"
    ║   ║   │   │   │ │ ├○ $parent
    ║   ║   │   │   │ │ └◙ WVal QAST::Op
    ║   ║   │   │   │ └─iseq_s  ««"eq"
    ║   ║   │   │   │   ├─callmethod op  ««".op"
    ║   ║   │   │   │   │ └○ $parent
    ║   ║   │   │   │   └◙ SVal "if"
    ║   ║   │   │   ├○ $parent
    ║   ║   │   │   └─if  ««"istype($parent, QAST::Stmt, QAST::Stmts) {\n       "...
    ║   ║   │   │     ├─call &istype  ««"$parent, QAST::Stmt, QAST::Stmts"
    ║   ║   │   │     │ ├○ $parent
    ║   ║   │   │     │ ├◙ WVal QAST::Stmt
    ║   ║   │   │     │ └◙ WVal QAST::Stmts
    ║   ║   │   │     └─:Stmts  ««"{\n                    $parent := @pathUp[0];\n    "...
    ║   ║   │   │       ├─bind  ««":="
    ║   ║   │   │       │ ├○ $parent
    ║   ║   │   │       │ └─ifnull
    ║   ║   │   │       │   ├─atpos
    ║   ║   │   │       │   │ ├○ @pathUp
    ║   ║   │   │       │   │ └◙ IVal 0
    ║   ║   │   │       │   └◙ WVal NQPMu
    ║   ║   │   │       └─if  ««"istype($parent, QAST::Op) && $parent.op eq 'if' {\n"...
    ║   ║   │   │         ├─if  ««"&&"
    ║   ║   │   │         │ ├─call &istype  ««"$parent, QAST::Op"
    ║   ║   │   │         │ │ ├○ $parent
    ║   ║   │   │         │ │ └◙ WVal QAST::Op
    ║   ║   │   │         │ └─iseq_s  ««"eq"
    ║   ║   │   │         │   ├─callmethod op  ««".op"
    ║   ║   │   │         │   │ └○ $parent
    ║   ║   │   │         │   └◙ SVal "if"
    ║   ║   │   │         ├○ $parent
    ║   ║   │   │         └○ $node
    ║   ║   │   └─callmethod list  ««".list"
    ║   ║   │     └○ $node
    ║   ║   ├○ $ast
    ║   ║   └○ @path
    ║   ╟─call &removeChild  ««"@path[0], $MAINcall"
    ║   ║ ├─ifnull
    ║   ║ │ ├─atpos
    ║   ║ │ │ ├○ @path
    ║   ║ │ │ └◙ IVal 0
    ║   ║ │ └◙ WVal NQPMu
    ║   ║ └○ $MAINcall
    ║   ╙○ $ast
    ╟─bind
    ║ ├○ &findDef :decl(var)
    ║ └─:Block "findDef"  ««"{\n    if nqp::isstr($matcher) {\n        my $name "...
    ║   ╟○ $ast :decl(param)
    ║   ╟○ $matcher :decl(param)
    ║   ╟○ @pathUp :decl(param) :default(list &circumfix:<[ ]>)
    ║   ╟─if  ««"nqp::isstr($matcher) {\n        my $name := $matche"...
    ║   ║ ├─isstr  ««"nqp::isstr($matcher)"
    ║   ║ │ └○ $matcher
    ║   ║ └─:Block :blocktype(immediate)  ««"{\n        my $name := $matcher;\n        $matcher "...
    ║   ║   ╟○ $name :decl(var)
    ║   ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$name := $matcher"
    ║   ║   ║ ├○ $name
    ║   ║   ║ └○ $matcher
    ║   ║   ╙─bind  ««":="
    ║   ║     ├○ $matcher
    ║   ║     └─:Block  ««"{ $var.name eq $name && $var.decl }"
    ║   ║       ╟○ $var :decl(param)
    ║   ║       ╟○ @pathUp :decl(param)
    ║   ║       ╙─if  ««"&&"
    ║   ║         ├─iseq_s  ««"eq"
    ║   ║         │ ├─callmethod name  ««".name"
    ║   ║         │ │ └○ $var
    ║   ║         │ └○ $name
    ║   ║         └─callmethod decl  ««".decl"
    ║   ║           └○ $var
    ║   ╙─call &findPath  ««"\n        -> $node, @pathUp {\n            my $pare"...
    ║     ├─:Block  ««"{\n            my $parent := nqp::elems(@pathUp) > "...
    ║     │ ╟○ $node :decl(param)
    ║     │ ╟○ @pathUp :decl(param)
    ║     │ ╟○ $parent :decl(var)
    ║     │ ╟─bind :annotations({"var_initialized" => 1})  ««"$parent := nqp::elems(@pathUp) > 0 ?? @pathUp[0] !!"...
    ║     │ ║ ├○ $parent
    ║     │ ║ └─if  ««"?? @pathUp[0] !!"
    ║     │ ║   ├─isgt_n  ««">"
    ║     │ ║   │ ├─elems  ««"nqp::elems(@pathUp)"
    ║     │ ║   │ │ └○ @pathUp
    ║     │ ║   │ └◙ IVal 0
    ║     │ ║   ├─ifnull
    ║     │ ║   │ ├─atpos
    ║     │ ║   │ │ ├○ @pathUp
    ║     │ ║   │ │ └◙ IVal 0
    ║     │ ║   │ └◙ WVal NQPMu
    ║     │ ║   └─null  ««"nqp::null"
    ║     │ ╙─if  ««"nqp::isnull($parent) || istype($parent, QAST::CompU"...
    ║     │   ├─unless  ««"||"
    ║     │   │ ├─isnull  ««"nqp::isnull($parent)"
    ║     │   │ │ └○ $parent
    ║     │   │ └─call &istype  ««"$parent, QAST::CompUnit"
    ║     │   │   ├○ $parent
    ║     │   │   └◙ WVal QAST::CompUnit
    ║     │   ├─callmethod list  ««".list"
    ║     │   │ └○ $node
    ║     │   └─if  ««"istype($parent, QAST::Op) && istype($node, QAST::Va"...
    ║     │     ├─if  ««"&&"
    ║     │     │ ├─call &istype  ««"$parent, QAST::Op"
    ║     │     │ │ ├○ $parent
    ║     │     │ │ └◙ WVal QAST::Op
    ║     │     │ └─call &istype  ««"$node, QAST::Var"
    ║     │     │   ├○ $node
    ║     │     │   └◙ WVal QAST::Var
    ║     │     ├─if  ««"?? $parent\n                    !!"
    ║     │     │ ├─if  ««"&&"
    ║     │     │ │ ├─iseq_s  ««"eq"
    ║     │     │ │ │ ├─callmethod op  ««".op"
    ║     │     │ │ │ │ └○ $parent
    ║     │     │ │ │ └◙ SVal "bind"
    ║     │     │ │ └─call  ««"$node, @pathUp"
    ║     │     │ │   ├○ $matcher
    ║     │     │ │   ├○ $node
    ║     │     │ │   └○ @pathUp
    ║     │     │ ├○ $parent
    ║     │     │ └─null  ««"nqp::null"
    ║     │     └─if  ««"istype($parent, QAST::Block, QAST::Stmts, QAST::Stm"...
    ║     │       ├─call &istype  ««"$parent, QAST::Block, QAST::Stmts, QAST::Stmt, QAST"...
    ║     │       │ ├○ $parent
    ║     │       │ ├◙ WVal QAST::Block
    ║     │       │ ├◙ WVal QAST::Stmts
    ║     │       │ ├◙ WVal QAST::Stmt
    ║     │       │ └◙ WVal QAST::Op
    ║     │       ├─:Block :blocktype(immediate)  ««"{\n                my @next := qastChildren($node, "...
    ║     │       │ ╟○ @next :decl(var)
    ║     │       │ ╟─bind :annotations({"var_initialized" => 1})  ««"@next := qastChildren($node, QAST::Block, QAST::Stm"...
    ║     │       │ ║ ├○ @next
    ║     │       │ ║ └─call &qastChildren  ««"$node, QAST::Block, QAST::Stmts, QAST::Stmt, QAST::"...
    ║     │       │ ║   ├○ $node
    ║     │       │ ║   ├◙ WVal QAST::Block
    ║     │       │ ║   ├◙ WVal QAST::Stmts
    ║     │       │ ║   ├◙ WVal QAST::Stmt
    ║     │       │ ║   ├◙ WVal QAST::Var
    ║     │       │ ║   └◙ WVal QAST::Op
    ║     │       │ ╙○ @next
    ║     │       └◙ IVal 0
    ║     ├○ $ast
    ║     └○ @pathUp
    ╟─bind
    ║ ├○ &findDefs :decl(var)
    ║ └─:Block "findDefs"  ««"{\n    my @out := [];\n    my $current := 1;\n    w"...
    ║   ╟○ $ast :decl(param)
    ║   ╟○ $matcher :decl(param)
    ║   ╟○ @out :decl(var)
    ║   ╟○ $current :decl(var)
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"@out := []"
    ║   ║ ├○ @out
    ║   ║ └─list
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$current := 1"
    ║   ║ ├○ $current
    ║   ║ └◙ IVal 1
    ║   ╟─while  ««"$current {\n        $current := findDef($ast, -> $v"...
    ║   ║ ├○ $current
    ║   ║ ├─:Stmts  ««"{\n        $current := findDef($ast, -> $var, @path"...
    ║   ║ │ ├─bind  ««":="
    ║   ║ │ │ ├○ $current
    ║   ║ │ │ └─call &findDef  ««"$ast, -> $var, @pathUp {\n            my $takeit :="...
    ║   ║ │ │   ├○ $ast
    ║   ║ │ │   └─:Block  ««"{\n            my $takeit := 0;\n            if $ma"...
    ║   ║ │ │     ╟○ $var :decl(param)
    ║   ║ │ │     ╟○ @pathUp :decl(param)
    ║   ║ │ │     ╟○ $takeit :decl(var)
    ║   ║ │ │     ╟─bind :annotations({"var_initialized" => 1})  ««"$takeit := 0"
    ║   ║ │ │     ║ ├○ $takeit
    ║   ║ │ │     ║ └◙ IVal 0
    ║   ║ │ │     ╟─if  ««"$matcher($var, @pathUp) {\n                $takeit "...
    ║   ║ │ │     ║ ├─call  ««"$var, @pathUp"
    ║   ║ │ │     ║ │ ├○ $matcher
    ║   ║ │ │     ║ │ ├○ $var
    ║   ║ │ │     ║ │ └○ @pathUp
    ║   ║ │ │     ║ └─:Block :blocktype(immediate)  ««"{\n                $takeit := 1;\n                m"...
    ║   ║ │ │     ║   ╟○ $i :decl(var)
    ║   ║ │ │     ║   ╟─bind  ««":="
    ║   ║ │ │     ║   ║ ├○ $takeit
    ║   ║ │ │     ║   ║ └◙ IVal 1
    ║   ║ │ │     ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$i := nqp::iterator(@out)"
    ║   ║ │ │     ║   ║ ├○ $i
    ║   ║ │ │     ║   ║ └─iterator  ««"nqp::iterator(@out)"
    ║   ║ │ │     ║   ║   └○ @out
    ║   ║ │ │     ║   ╙─while  ««"$i && $takeit {\n                    $takeit := !(n"...
    ║   ║ │ │     ║     ├─if  ««"&&"
    ║   ║ │ │     ║     │ ├○ $i
    ║   ║ │ │     ║     │ └○ $takeit
    ║   ║ │ │     ║     ├─bind  ««":="
    ║   ║ │ │     ║     │ ├○ $takeit
    ║   ║ │ │     ║     │ └─falsey  ««"!"
    ║   ║ │ │     ║     │   └─eqaddr  ««"=:="
    ║   ║ │ │     ║     │     ├─ifnull
    ║   ║ │ │     ║     │     │ ├─atpos
    ║   ║ │ │     ║     │     │ │ ├─shift  ««"nqp::shift($i)"
    ║   ║ │ │     ║     │     │ │ │ └○ $i
    ║   ║ │ │     ║     │     │ │ └◙ IVal 0
    ║   ║ │ │     ║     │     │ └◙ WVal NQPMu
    ║   ║ │ │     ║     │     └○ $var
    ║   ║ │ │     ║     └◙ IVal 1 :named("nohandler")
    ║   ║ │ │     ╙○ $takeit
    ║   ║ │ └─unless  ««"nqp::isnull($current) {\n#            say(nqp::elem"...
    ║   ║ │   ├─isnull  ««"nqp::isnull($current)"
    ║   ║ │   │ └○ $current
    ║   ║ │   └─push  ««"$current"
    ║   ║ │     ├○ @out
    ║   ║ │     └○ $current
    ║   ║ └◙ IVal 1 :named("nohandler")
    ║   ╙○ @out
    ╟─bind
    ║ ├○ &findValueNodeInHash :decl(var)
    ║ └─:Block "findValueNodeInHash" :annotations({"compile_time_dummy" => (BOOTCode, invokable)})  ««"{\n    nqp::die('findValueNodeInHash expects a fn a"...
    ║   ╟○ $keyPredicate :decl(param)
    ║   ╟○ $valuePredicate :decl(param)
    ║   ╟○ $hash :decl(param) :default(WVal NO_VALUE)
    ║   ╟○ $found :decl(var)
    ║   ╙─lexotic RETURN
    ║     └─:Stmts  ««"\n    nqp::die('findValueNodeInHash expects a fn as"...
    ║       ├─unless  ««"nqp::die('findValueNodeInHash expects a fn as 1st a"...
    ║       │ ├─isinvokable  ««"nqp::isinvokable($keyPredicate)"
    ║       │ │ └○ $keyPredicate
    ║       │ └─die  ««"nqp::die('findValueNodeInHash expects a fn as 1st a"...
    ║       │   └─concat  ««"~"
    ║       │     ├◙ SVal "findValueNodeInHash expects a fn as 1st arg - got "
    ║       │     └─call &describe  ««"$keyPredicate"
    ║       │       └○ $keyPredicate
    ║       ├─unless  ««"nqp::die('findValueNodeInHash expects a fn as 2nd a"...
    ║       │ ├─isinvokable  ««"nqp::isinvokable($valuePredicate)"
    ║       │ │ └○ $valuePredicate
    ║       │ └─die  ««"nqp::die('findValueNodeInHash expects a fn as 2nd a"...
    ║       │   └─concat  ««"~"
    ║       │     ├◙ SVal "findValueNodeInHash expects a fn as 2nd arg - got "
    ║       │     └─call &describe  ««"$valuePredicate"
    ║       │       └○ $valuePredicate
    ║       ├─if  ««"$hash =:= NO_VALUE {\n        return -> $hash { fin"...
    ║       │ ├─eqaddr  ««"=:="
    ║       │ │ ├○ $hash
    ║       │ │ └◙ WVal NO_VALUE
    ║       │ ├─call RETURN
    ║       │ │ └─:Block  ««"{ findValueNodeInHash($keyPredicate, $valuePredicat"...
    ║       │ │   ╟○ $hash :decl(param)
    ║       │ │   ╙─call &findValueNodeInHash  ««"$keyPredicate, $valuePredicate, $hash"
    ║       │ │     ├○ $keyPredicate
    ║       │ │     ├○ $valuePredicate
    ║       │ │     └○ $hash
    ║       │ └─if  ««"!istype($hash, QAST::Node) {\n        nqp::die('fin"...
    ║       │   ├─falsey  ««"!"
    ║       │   │ └─call &istype  ««"$hash, QAST::Node"
    ║       │   │   ├○ $hash
    ║       │   │   └◙ WVal QAST::Node
    ║       │   └─die  ««"nqp::die('findValueNodeInHash expects a QAST::Node "...
    ║       │     └─concat  ««"~"
    ║       │       ├◙ SVal "findValueNodeInHash expects a QAST::Node as (optional) 3rd arg - got "
    ║       │       └─call &describe  ««"$hash"
    ║       │         └○ $hash
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$found := nqp::null"
    ║       │ ├○ $found
    ║       │ └─null  ««"nqp::null"
    ║       ├─if  ««"istype($hash, QAST::Op) && $hash.op eq 'hash' {\n  "...
    ║       │ ├─if  ««"&&"
    ║       │ │ ├─call &istype  ««"$hash, QAST::Op"
    ║       │ │ │ ├○ $hash
    ║       │ │ │ └◙ WVal QAST::Op
    ║       │ │ └─iseq_s  ««"eq"
    ║       │ │   ├─callmethod op  ««".op"
    ║       │ │   │ └○ $hash
    ║       │ │   └◙ SVal "hash"
    ║       │ └─:Block :blocktype(immediate)  ««"{\n        my $it := nqp::iterator($hash.list);\n  "...
    ║       │   ╟○ $it :decl(var)
    ║       │   ╟─bind :annotations({"var_initialized" => 1})  ««"$it := nqp::iterator($hash.list)"
    ║       │   ║ ├○ $it
    ║       │   ║ └─iterator  ««"nqp::iterator($hash.list)"
    ║       │   ║   └─callmethod list  ««".list"
    ║       │   ║     └○ $hash
    ║       │   ╙─while  ««"$it && !$found {\n            my $k := nqp::shift($"...
    ║       │     ├─if  ««"&&"
    ║       │     │ ├○ $it
    ║       │     │ └─falsey  ««"!"
    ║       │     │   └○ $found
    ║       │     ├─:Block :blocktype(immediate)  ««"{\n            my $k := nqp::shift($it);\n         "...
    ║       │     │ ╟○ $k :decl(var)
    ║       │     │ ╟─bind :annotations({"var_initialized" => 1})  ««"$k := nqp::shift($it)"
    ║       │     │ ║ ├○ $k
    ║       │     │ ║ └─shift  ««"nqp::shift($it)"
    ║       │     │ ║   └○ $it
    ║       │     │ ╙─if  ««"$it && $keyPredicate($k) {\n                my $v :"...
    ║       │     │   ├─if  ««"&&"
    ║       │     │   │ ├○ $it
    ║       │     │   │ └─call  ««"$k"
    ║       │     │   │   ├○ $keyPredicate
    ║       │     │   │   └○ $k
    ║       │     │   └─:Block :blocktype(immediate)  ««"{\n                my $v := nqp::shift($it);\n     "...
    ║       │     │     ╟○ $v :decl(var)
    ║       │     │     ╟─bind :annotations({"var_initialized" => 1})  ««"$v := nqp::shift($it)"
    ║       │     │     ║ ├○ $v
    ║       │     │     ║ └─shift  ««"nqp::shift($it)"
    ║       │     │     ║   └○ $it
    ║       │     │     ╙─if  ««"$valuePredicate($v) {\n                    $found :"...
    ║       │     │       ├─call  ««"$v"
    ║       │     │       │ ├○ $valuePredicate
    ║       │     │       │ └○ $v
    ║       │     │       └─bind  ««":="
    ║       │     │         ├○ $found
    ║       │     │         └○ $v
    ║       │     └◙ IVal 1 :named("nohandler")
    ║       └○ $found
    ╟○ SmartCompiler :decl(static) :default((SmartCompiler, Type object))
    ╟○ NQPActions :decl(static) :default((NQPActions, Type object))
    ╟○ $needsCompilation :decl(var)
    ╟○ NQPCompiler :decl(static) :default((NQPCompiler, Type object))
    ╟─bind
    ║ ├○ &MAIN :decl(var)
    ║ └─:Block "MAIN"  ««"{\n    @ARGS := flatten(@ARGS);\n\n    my $cwd := n"...
    ║   ╟○ @ARGS :decl(param) :slurpy(1)
    ║   ╟○ $cwd :decl(var)
    ║   ╟○ $sep :decl(var)
    ║   ╟○ $nqpc :decl(var)
    ║   ╟○ %opts :decl(var)
    ║   ╟─bind  ««":="
    ║   ║ ├○ @ARGS
    ║   ║ └─call &flatten  ««"@ARGS"
    ║   ║   └○ @ARGS
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$cwd := nqp::cwd()"
    ║   ║ ├○ $cwd
    ║   ║ └─cwd  ««"nqp::cwd()"
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$sep := nqp::x('-', 29)"
    ║   ║ ├○ $sep
    ║   ║ └─x  ««"nqp::x('-', 29)"
    ║   ║   ├◙ SVal "-"
    ║   ║   └◙ IVal 29
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$nqpc := NQPCompiler.new()"
    ║   ║ ├○ $nqpc
    ║   ║ └─callmethod new  ««""
    ║   ║   └◙ WVal NQPCompiler
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"%opts := hash()"
    ║   ║ ├○ %opts
    ║   ║ └─call &hash  ««""
    ║   ╟─shift  ««".shift"
    ║   ║ └○ @ARGS
    ║   ╟─if  ««"nqp::elems(@ARGS) == 0 {\n        #@ARGS.push('L/LG"...
    ║   ║ ├─iseq_n  ««"=="
    ║   ║ │ ├─elems  ««"nqp::elems(@ARGS)"
    ║   ║ │ │ └○ @ARGS
    ║   ║ │ └◙ IVal 0
    ║   ║ └─push  ««"'lib/L/runtime.nqp'"
    ║   ║   ├○ @ARGS
    ║   ║   └◙ SVal "lib/L/runtime.nqp"
    ║   ╟─callmethod addstage  ««"'write_bytecode', :before<mbc>"
    ║   ║ ├○ $nqpc
    ║   ║ ├◙ SVal "write_bytecode"
    ║   ║ └◙ SVal "mbc" :named("before")
    ║   ╟─callmethod log_level  ««"'INFO'"
    ║   ║ ├○ $nqpc
    ║   ║ └◙ SVal "INFO"
    ║   ╟─for  ««"@ARGS {\n        my $file := $_;\n        \n       "...
    ║   ║ ├○ @ARGS
    ║   ║ ├─:Block :annotations({"handlers" => {"CATCH" => QAST::Stmts}}) :blocktype(immediate)  ««"{\n        my $file := $_;\n        \n        my $r"...
    ║   ║ │ ╟○ $file :decl(var)
    ║   ║ │ ╟○ $result :decl(var)
    ║   ║ │ ╟○ $_ :decl(param)
    ║   ║ │ ╙─handle
    ║   ║ │   ├─:Stmts  ««"\n        my $file := $_;\n        \n        my $re"...
    ║   ║ │   │ ├─bind :annotations({"var_initialized" => 1})  ««"$file := $_"
    ║   ║ │   │ │ ├○ $file
    ║   ║ │   │ │ └○ $_
    ║   ║ │   │ ├─bind :annotations({"var_initialized" => 1})  ««"$result := $nqpc.compileFile($file, |%opts)"
    ║   ║ │   │ │ ├○ $result
    ║   ║ │   │ │ └─callmethod compileFile  ««"$file, |%opts"
    ║   ║ │   │ │   ├○ $nqpc
    ║   ║ │   │ │   ├○ $file
    ║   ║ │   │ │   └○ %opts :flat(1) :named(1)
    ║   ║ │   │ ├─if  ««"nqp::isnull($result) {\n            $nqpc.log(\"upt"...
    ║   ║ │   │ │ ├─isnull  ««"nqp::isnull($result)"
    ║   ║ │   │ │ │ └○ $result
    ║   ║ │   │ │ ├─callmethod log  ««"\"uptodate: $file\""
    ║   ║ │   │ │ │ ├○ $nqpc
    ║   ║ │   │ │ │ └─concat
    ║   ║ │   │ │ │   ├◙ SVal "uptodate: "
    ║   ║ │   │ │ │   └○ $file
    ║   ║ │   │ │ └─callmethod log  ««"\"compiled: $file ~> \" ~ describe($result)"
    ║   ║ │   │ │   ├○ $nqpc
    ║   ║ │   │ │   └─concat  ««"~"
    ║   ║ │   │ │     ├─concat
    ║   ║ │   │ │     │ ├─concat
    ║   ║ │   │ │     │ │ ├◙ SVal "compiled: "
    ║   ║ │   │ │     │ │ └○ $file
    ║   ║ │   │ │     │ └◙ SVal " ~> "
    ║   ║ │   │ │     └─call &describe  ««"$result"
    ║   ║ │   │ │       └○ $result
    ║   ║ │   │ └◙ WVal NQPMu
    ║   ║ │   ├► "CATCH" (str)
    ║   ║ │   └─:Stmts
    ║   ║ │     ├─call
    ║   ║ │     │ ├─:Block  ««"{\n            $nqpc.log(:level<ERROR>, \" FILE: $f"...
    ║   ║ │     │ │ ╟○ $_ :decl(param)
    ║   ║ │     │ │ ╟─bind
    ║   ║ │     │ │ ║ ├○ $! :decl(var)
    ║   ║ │     │ │ ║ └○ $_
    ║   ║ │     │ │ ╟─callmethod log  ««":level<ERROR>, \" FILE: $file\""
    ║   ║ │     │ │ ║ ├○ $nqpc
    ║   ║ │     │ │ ║ ├◙ SVal "ERROR" :named("level")
    ║   ║ │     │ │ ║ └─concat
    ║   ║ │     │ │ ║   ├◙ SVal " FILE: "
    ║   ║ │     │ │ ║   └○ $file
    ║   ║ │     │ │ ╟─callmethod log  ««":level<ERROR>, \"  CWD: $cwd\""
    ║   ║ │     │ │ ║ ├○ $nqpc
    ║   ║ │     │ │ ║ ├◙ SVal "ERROR" :named("level")
    ║   ║ │     │ │ ║ └─concat
    ║   ║ │     │ │ ║   ├◙ SVal "  CWD: "
    ║   ║ │     │ │ ║   └○ $cwd
    ║   ║ │     │ │ ╟─callmethod log  ««":level<ERROR>, ' ARGS: ', nqp::join(' ', @ARGS)"
    ║   ║ │     │ │ ║ ├○ $nqpc
    ║   ║ │     │ │ ║ ├◙ SVal "ERROR" :named("level")
    ║   ║ │     │ │ ║ ├◙ SVal " ARGS: "
    ║   ║ │     │ │ ║ └─join  ««"nqp::join(' ', @ARGS)"
    ║   ║ │     │ │ ║   ├◙ SVal " "
    ║   ║ │     │ │ ║   └○ @ARGS
    ║   ║ │     │ │ ╟─callmethod log  ««":level<ERROR>, ''"
    ║   ║ │     │ │ ║ ├○ $nqpc
    ║   ║ │     │ │ ║ ├◙ SVal "ERROR" :named("level")
    ║   ║ │     │ │ ║ └◙ SVal ""
    ║   ║ │     │ │ ╟─callmethod log  ««":level<ERROR>, ~$_"
    ║   ║ │     │ │ ║ ├○ $nqpc
    ║   ║ │     │ │ ║ ├◙ SVal "ERROR" :named("level")
    ║   ║ │     │ │ ║ └─stringify  ««"~"
    ║   ║ │     │ │ ║   └○ $_
    ║   ║ │     │ │ ╙─exit  ««"nqp::exit(1)"
    ║   ║ │     │ │   └◙ IVal 1
    ║   ║ │     │ └─exception
    ║   ║ │     ├─:VM
    ║   ║ │     └◙ WVal NQPMu
    ║   ║ └◙ IVal 1 :named("nohandler")
    ║   ╙─call &say  ««"$sep"
    ║     └○ $sep
    ╟─bind
    ║ ├○ local ctxsave :decl(var)
    ║ └○ contextual $*CTXSAVE
    ╟─unless
    ║ ├─isnull
    ║ │ └○ local ctxsave
    ║ └─if
    ║   ├─can
    ║   │ ├○ local ctxsave
    ║   │ └◙ SVal "ctxsave"
    ║   └─callmethod ctxsave
    ║     └○ local ctxsave
    ╟─:Block :blocktype(immediate)  ««"{}"
    ║ ╟○ $?PACKAGE :decl(static) :default((NO_VALUE, Type object))
    ║ ╟○ $?CLASS :decl(static) :default((NO_VALUE, Type object))
    ║ ╙◙ WVal NQPMu
    ╟─:Block :blocktype(immediate)  ««"{\n\n    # Where to search for user source files.\n"...
    ║ ╟○ $?PACKAGE :decl(static) :default((SmartCompiler, Type object))
    ║ ╟○ $?CLASS :decl(static) :default((SmartCompiler, Type object))
    ║ ╟─:Block "BUILD" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        # in this order (!):\n        self.addst"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ @clo :decl(var)
    ║ ║ ╟─callmethod addstage  ««"'ast_save',           :after<ast>"
    ║ ║ ║ ├─decont
    ║ ║ ║ │ └○ self
    ║ ║ ║ ├◙ SVal "ast_save"
    ║ ║ ║ └◙ SVal "ast" :named("after")
    ║ ║ ╟─callmethod addstage  ««"'ast_clean',          :before<ast_save>"
    ║ ║ ║ ├─decont
    ║ ║ ║ │ └○ self
    ║ ║ ║ ├◙ SVal "ast_clean"
    ║ ║ ║ └◙ SVal "ast_save" :named("before")
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"@clo := self.commandline_options()"
    ║ ║ ║ ├○ @clo
    ║ ║ ║ └─callmethod commandline_options  ««""
    ║ ║ ║   └─decont
    ║ ║ ║     └○ self
    ║ ║ ╟─push  ««"'parsetrace'"
    ║ ║ ║ ├○ @clo
    ║ ║ ║ └◙ SVal "parsetrace"
    ║ ║ ╟─push  ««"'setting=s'"
    ║ ║ ║ ├○ @clo
    ║ ║ ║ └◙ SVal "setting=s"
    ║ ║ ╟─push  ««"'setting-path=s'"
    ║ ║ ║ ├○ @clo
    ║ ║ ║ └◙ SVal "setting-path=s"
    ║ ║ ╟─push  ««"'module-path=s'"
    ║ ║ ║ ├○ @clo
    ║ ║ ║ └◙ SVal "module-path=s"
    ║ ║ ╟─push  ««"'no-regex-lib'"
    ║ ║ ║ ├○ @clo
    ║ ║ ║ └◙ SVal "no-regex-lib"
    ║ ║ ╟─push  ««"'stable-sc'"
    ║ ║ ║ ├○ @clo
    ║ ║ ║ └◙ SVal "stable-sc"
    ║ ║ ╟─push  ««"'optimize=s'"
    ║ ║ ║ ├○ @clo
    ║ ║ ║ └◙ SVal "optimize=s"
    ║ ║ ╟─bind  ««":="
    ║ ║ ║ ├○ attribute @!user_srcpaths :returns(VMNull)
    ║ ║ ║ │ ├─decont
    ║ ║ ║ │ │ └○ self
    ║ ║ ║ │ └◙ WVal SmartCompiler
    ║ ║ ║ └─list  ««"<. lib lib/L>"
    ║ ║ ║   ├◙ SVal "."
    ║ ║ ║   ├◙ SVal "lib"
    ║ ║ ║   └◙ SVal "lib/L"
    ║ ║ ╟─bind  ««":="
    ║ ║ ║ ├○ attribute $!log_level :returns(VMNull)
    ║ ║ ║ │ ├─decont
    ║ ║ ║ │ │ └○ self
    ║ ║ ║ │ └◙ WVal SmartCompiler
    ║ ║ ║ └◙ SVal "WARN"
    ║ ║ ╙─bind  ««":="
    ║ ║   ├○ attribute %!interactive_commands :returns(VMNull)
    ║ ║   │ ├─decont
    ║ ║   │ │ └○ self
    ║ ║   │ └◙ WVal SmartCompiler
    ║ ║   └─hash
    ║ ╟─:Block "user_progname" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        self.user-progname();\n    }"
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╙─callmethod user-progname  ««""
    ║ ║   └─decont
    ║ ║     └○ self
    ║ ╟─:Block "user_binname" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        $!user_binname := $v unless $v =:= NO_VA"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $v :decl(param) :default(WVal NO_VALUE)
    ║ ║ ╟─unless  ««"$!user_binname := $v unless $v =:= NO_VALUE"
    ║ ║ ║ ├─eqaddr  ««"=:="
    ║ ║ ║ │ ├○ $v
    ║ ║ ║ │ └◙ WVal NO_VALUE
    ║ ║ ║ └─bind  ««":="
    ║ ║ ║   ├○ attribute $!user_binname :returns(VMNull)
    ║ ║ ║   │ ├─decont
    ║ ║ ║   │ │ └○ self
    ║ ║ ║   │ └◙ WVal SmartCompiler
    ║ ║ ║   └○ $v
    ║ ║ ╙○ attribute $!user_binname :returns(VMNull)
    ║ ║   ├─decont
    ║ ║   │ └○ self
    ║ ║   └◙ WVal SmartCompiler
    ║ ╟─:Block "user_srcpaths" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        @!user_srcpaths;\n    }"
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╙○ attribute @!user_srcpaths :returns(VMNull)
    ║ ║   ├─decont
    ║ ║   │ └○ self
    ║ ║   └◙ WVal SmartCompiler
    ║ ╟─:Block "log_level" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        $!log_level := $level unless $level =:= "...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $level :decl(param) :default(WVal NO_VALUE)
    ║ ║ ╟─unless  ««"$!log_level := $level unless $level =:= NO_VALUE"
    ║ ║ ║ ├─eqaddr  ««"=:="
    ║ ║ ║ │ ├○ $level
    ║ ║ ║ │ └◙ WVal NO_VALUE
    ║ ║ ║ └─bind  ««":="
    ║ ║ ║   ├○ attribute $!log_level :returns(VMNull)
    ║ ║ ║   │ ├─decont
    ║ ║ ║   │ │ └○ self
    ║ ║ ║   │ └◙ WVal SmartCompiler
    ║ ║ ║   └○ $level
    ║ ║ ╙○ attribute $!log_level :returns(VMNull)
    ║ ║   ├─decont
    ║ ║   │ └○ self
    ║ ║   └◙ WVal SmartCompiler
    ║ ╟─:Block "log" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        if self.log_level eq 'INFO' \n          "...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $msg :decl(param)
    ║ ║ ╟○ @moreMsgPieces :decl(param) :slurpy(1)
    ║ ║ ╟○ $level :decl(param) :named("level") :default(SVal "INFO")
    ║ ║ ╙─if  ««"self.log_level eq 'INFO' \n            || self.log_"...
    ║ ║   ├─unless  ««"||"
    ║ ║   │ ├─unless  ««"||"
    ║ ║   │ │ ├─iseq_s  ««"eq"
    ║ ║   │ │ │ ├─callmethod log_level  ««".log_level"
    ║ ║   │ │ │ │ └─decont
    ║ ║   │ │ │ │   └○ self
    ║ ║   │ │ │ └◙ SVal "INFO"
    ║ ║   │ │ └─if  ««"&&"
    ║ ║   │ │   ├─iseq_s  ««"eq"
    ║ ║   │ │   │ ├─callmethod log_level  ««".log_level"
    ║ ║   │ │   │ │ └─decont
    ║ ║   │ │   │ │   └○ self
    ║ ║   │ │   │ └◙ SVal "WARN"
    ║ ║   │ │   └─isne_s  ««"ne"
    ║ ║   │ │     ├○ $level
    ║ ║   │ │     └◙ SVal "INFO"
    ║ ║   │ └─if  ««"&&"
    ║ ║   │   ├─iseq_s  ««"eq"
    ║ ║   │   │ ├─callmethod log_level  ««".log_level"
    ║ ║   │   │ │ └─decont
    ║ ║   │   │ │   └○ self
    ║ ║   │   │ └◙ SVal "ERROR"
    ║ ║   │   └─iseq_s  ««"eq"
    ║ ║   │     ├○ $level
    ║ ║   │     └◙ SVal "ERROR"
    ║ ║   └─:Block :blocktype(immediate)  ««"{\n            my str $out := '# [' ~ self.compiler"...
    ║ ║     ╟○ $out :decl(var) :returns(str)
    ║ ║     ╟─bind :annotations({"var_initialized" => 1})  ««"str $out := '# [' ~ self.compiler_progname ~ \"|$le"...
    ║ ║     ║ ├○ $out
    ║ ║     ║ └─concat  ««"~"
    ║ ║     ║   ├─concat  ««"~"
    ║ ║     ║   │ ├─concat  ««"~"
    ║ ║     ║   │ │ ├◙ SVal "# ["
    ║ ║     ║   │ │ └─callmethod compiler_progname  ««".compiler_progname"
    ║ ║     ║   │ │   └─decont
    ║ ║     ║   │ │     └○ self
    ║ ║     ║   │ └─concat
    ║ ║     ║   │   ├─concat
    ║ ║     ║   │   │ ├◙ SVal "|"
    ║ ║     ║   │   │ └○ $level
    ║ ║     ║   │   └◙ SVal "] "
    ║ ║     ║   └○ $msg
    ║ ║     ╟─for  ««"@moreMsgPieces {\n                $out := $out ~ $_"...
    ║ ║     ║ ├○ @moreMsgPieces
    ║ ║     ║ ├─:Block :blocktype(immediate)  ««"{\n                $out := $out ~ $_;\n            }"
    ║ ║     ║ │ ╟○ $_ :decl(param)
    ║ ║     ║ │ ╙─bind  ««":="
    ║ ║     ║ │   ├○ $out :returns(str)
    ║ ║     ║ │   └─concat  ««"~"
    ║ ║     ║ │     ├○ $out :returns(str)
    ║ ║     ║ │     └○ $_
    ║ ║     ║ └◙ IVal 1 :named("nohandler")
    ║ ║     ╙─call &say  ««"$out"
    ║ ║       └○ $out :returns(str)
    ║ ╟─:Block "backend" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        nqp::getattr(self, HLL::Compiler, '$!bac"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╙─getattr  ««"nqp::getattr(self, HLL::Compiler, '$!backend')"
    ║ ║   ├─decont
    ║ ║   │ └○ self
    ║ ║   ├◙ WVal HLL::Compiler
    ║ ║   └◙ SVal "$!backend"
    ║ ╟─:Block "version_string" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        self.language ~ ' v' ~ self.config<versi"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╙─concat  ««"~"
    ║ ║   ├─concat  ««"~"
    ║ ║   │ ├─callmethod language  ««".language"
    ║ ║   │ │ └─decont
    ║ ║   │ │   └○ self
    ║ ║   │ └◙ SVal " v"
    ║ ║   └─ifnull
    ║ ║     ├─atkey
    ║ ║     │ ├─callmethod config  ««".config"
    ║ ║     │ │ └─decont
    ║ ║     │ │   └○ self
    ║ ║     │ └◙ SVal "version"
    ║ ║     └◙ WVal NQPMu
    ║ ╟─:Block "find_file" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        my $path;\n        my $file_name := nqp:"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $module_name :decl(param)
    ║ ║ ╟○ @search_paths :decl(param)
    ║ ║ ╟○ $ext :decl(param) :named("ext")
    ║ ║ ╟─bind  ««"$path"
    ║ ║ ║ ├○ $path :decl(var)
    ║ ║ ║ └◙ WVal NQPMu
    ║ ║ ╟○ $file_name :decl(var)
    ║ ║ ╟○ $path
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"$file_name := nqp::join('/', nqp::split('::', $modu"...
    ║ ║ ║ ├○ $file_name
    ║ ║ ║ └─concat  ««"~"
    ║ ║ ║   ├─join  ««"nqp::join('/', nqp::split('::', $module_name))"
    ║ ║ ║   │ ├◙ SVal "/"
    ║ ║ ║   │ └─split  ««"nqp::split('::', $module_name)"
    ║ ║ ║   │   ├◙ SVal "::"
    ║ ║ ║   │   └○ $module_name
    ║ ║ ║   └─concat
    ║ ║ ║     ├◙ SVal "."
    ║ ║ ║     └○ $ext
    ║ ║ ╟─for  ««"@search_paths {\n            $path := \"$_/$file_na"...
    ║ ║ ║ ├○ @search_paths
    ║ ║ ║ └─:Block :blocktype(immediate)  ««"{\n            $path := \"$_/$file_name\";\n       "...
    ║ ║ ║   ╟○ $_ :decl(param)
    ║ ║ ║   ╟─bind  ««":="
    ║ ║ ║   ║ ├○ $path
    ║ ║ ║   ║ └─concat
    ║ ║ ║   ║   ├─concat
    ║ ║ ║   ║   │ ├○ $_
    ║ ║ ║   ║   │ └◙ SVal "/"
    ║ ║ ║   ║   └○ $file_name
    ║ ║ ║   ╟─if  ««"last if nqp::stat($path, nqp::const::STAT_EXISTS)\n"...
    ║ ║ ║   ║ ├─stat  ««"nqp::stat($path, nqp::const::STAT_EXISTS)"
    ║ ║ ║   ║ │ ├○ $path
    ║ ║ ║   ║ │ └─const STAT_EXISTS
    ║ ║ ║   ║ └─control last
    ║ ║ ║   ╙─bind  ««":="
    ║ ║ ║     ├○ $path
    ║ ║ ║     └─null  ««"nqp::null"
    ║ ║ ╙○ $path
    ║ ╟─:Block "find_src" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        self.find_file($module_name, @!user_srcp"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $module_name :decl(param) :returns(str)
    ║ ║ ╟○ $ext :decl(param) :named("ext")
    ║ ║ ╙─callmethod find_file  ««"$module_name, @!user_srcpaths, :$ext"
    ║ ║   ├─decont
    ║ ║   │ └○ self
    ║ ║   ├○ $module_name :returns(str)
    ║ ║   ├○ attribute @!user_srcpaths :returns(VMNull)
    ║ ║   │ ├─decont
    ║ ║   │ │ └○ self
    ║ ║   │ └◙ WVal SmartCompiler
    ║ ║   └○ $ext :named("ext")
    ║ ╟─:Block "find_bytecode" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n            my $loader := nqp::getcurhllsym('Mod"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $module_name :decl(param)
    ║ ║ ╟○ $ext :decl(param) :named("ext")
    ║ ║ ╟○ $with-nqplib :decl(param) :named("with-nqplib") :default(WVal NQPMu)
    ║ ║ ╟○ $loader :decl(var)
    ║ ║ ╟○ @module_paths :decl(var)
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"$loader := nqp::getcurhllsym('ModuleLoader')"
    ║ ║ ║ ├○ $loader
    ║ ║ ║ └─getcurhllsym  ««"nqp::getcurhllsym('ModuleLoader')"
    ║ ║ ║   └◙ SVal "ModuleLoader"
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"@module_paths := $loader.search_path('module-path')"
    ║ ║ ║ ├○ @module_paths
    ║ ║ ║ └─callmethod search_path  ««"'module-path'"
    ║ ║ ║   ├○ $loader
    ║ ║ ║   └◙ SVal "module-path"
    ║ ║ ╟─if  ««"$with-nqplib {\n                @module_paths.unshi"...
    ║ ║ ║ ├○ $with-nqplib
    ║ ║ ║ └─unshift  ««"nqp::backendconfig()<prefix> ~ '/languages/nqp/lib'"
    ║ ║ ║   ├○ @module_paths
    ║ ║ ║   └─concat  ««"~"
    ║ ║ ║     ├─ifnull
    ║ ║ ║     │ ├─atkey
    ║ ║ ║     │ │ ├─backendconfig  ««"nqp::backendconfig()"
    ║ ║ ║     │ │ └◙ SVal "prefix"
    ║ ║ ║     │ └◙ WVal NQPMu
    ║ ║ ║     └◙ SVal "/languages/nqp/lib"
    ║ ║ ╙─callmethod find_file  ««"$module_name, @module_paths, :$ext"
    ║ ║   ├─decont
    ║ ║   │ └○ self
    ║ ║   ├○ $module_name
    ║ ║   ├○ @module_paths
    ║ ║   └○ $ext :named("ext")
    ║ ╟─:Block "compileDependency" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        my $out;\n        my $src_path := self.f"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $module_name :decl(param) :returns(str)
    ║ ║ ╟○ @on_behalf :decl(param)
    ║ ║ ╟─bind  ««"$out"
    ║ ║ ║ ├○ $out :decl(var)
    ║ ║ ║ └◙ WVal NQPMu
    ║ ║ ╟○ $src_path :decl(var)
    ║ ║ ╙─lexotic RETURN
    ║ ║   └─:Stmts  ««"\n        my $out;\n        my $src_path := self.fi"...
    ║ ║     ├○ $out
    ║ ║     ├─bind :annotations({"var_initialized" => 1})  ««"$src_path := self.find_src($module_name, :ext<nqp>)"
    ║ ║     │ ├○ $src_path
    ║ ║     │ └─callmethod find_src  ««"$module_name, :ext<nqp>"
    ║ ║     │   ├─decont
    ║ ║     │   │ └○ self
    ║ ║     │   ├○ $module_name :returns(str)
    ║ ║     │   └◙ SVal "nqp" :named("ext")
    ║ ║     └─if  ««"$src_path {\n            my $bc_path := self.find_b"...
    ║ ║       ├○ $src_path
    ║ ║       ├─:Block :blocktype(immediate)  ««"{\n            my $bc_path := self.find_bytecode($m"...
    ║ ║       │ ╟○ $bc_path :decl(var)
    ║ ║       │ ╟○ $clone :decl(var)
    ║ ║       │ ╟─bind :annotations({"var_initialized" => 1})  ««"$bc_path := self.find_bytecode($module_name, :ext<m"...
    ║ ║       │ ║ ├○ $bc_path
    ║ ║       │ ║ └─callmethod find_bytecode  ««"$module_name, :ext<moarvm>"
    ║ ║       │ ║   ├─decont
    ║ ║       │ ║   │ └○ self
    ║ ║       │ ║   ├○ $module_name :returns(str)
    ║ ║       │ ║   └◙ SVal "moarvm" :named("ext")
    ║ ║       │ ╟─if  ««"$bc_path {\n                my $src_time := nqp::st"...
    ║ ║       │ ║ ├○ $bc_path
    ║ ║       │ ║ └─:Block :blocktype(immediate)  ««"{\n                my $src_time := nqp::stat($src_p"...
    ║ ║       │ ║   ╟○ $src_time :decl(var)
    ║ ║       │ ║   ╟○ $bc_time :decl(var)
    ║ ║       │ ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$src_time := nqp::stat($src_path, nqp::const::STAT_"...
    ║ ║       │ ║   ║ ├○ $src_time
    ║ ║       │ ║   ║ └─stat  ««"nqp::stat($src_path, nqp::const::STAT_MODIFYTIME)"
    ║ ║       │ ║   ║   ├○ $src_path
    ║ ║       │ ║   ║   └─const STAT_MODIFYTIME
    ║ ║       │ ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$bc_time  := nqp::stat($bc_path,  nqp::const::STAT_"...
    ║ ║       │ ║   ║ ├○ $bc_time
    ║ ║       │ ║   ║ └─stat  ««"nqp::stat($bc_path,  nqp::const::STAT_MODIFYTIME)"
    ║ ║       │ ║   ║   ├○ $bc_path
    ║ ║       │ ║   ║   └─const STAT_MODIFYTIME
    ║ ║       │ ║   ╙─if  ««"$src_time < $bc_time {\n                    return "...
    ║ ║       │ ║     ├─islt_n  ««"<"
    ║ ║       │ ║     │ ├○ $src_time
    ║ ║       │ ║     │ └○ $bc_time
    ║ ║       │ ║     └─call RETURN
    ║ ║       │ ║       └○ $bc_path
    ║ ║       │ ╟─bind :annotations({"var_initialized" => 1})  ««"$clone := nqp::clone(self)"
    ║ ║       │ ║ ├○ $clone
    ║ ║       │ ║ └─clone  ««"nqp::clone(self)"
    ║ ║       │ ║   └─decont
    ║ ║       │ ║     └○ self
    ║ ║       │ ╙─call RETURN
    ║ ║       │   └─callmethod compileFile  ««"$src_path, :target<mbc>"
    ║ ║       │     ├○ $clone
    ║ ║       │     ├○ $src_path
    ║ ║       │     └◙ SVal "mbc" :named("target")
    ║ ║       └─call RETURN
    ║ ║         └─callmethod find_bytecode  ««"$module_name, :ext<moarvm>, :with-nqplib"
    ║ ║           ├─decont
    ║ ║           │ └○ self
    ║ ║           ├○ $module_name :returns(str)
    ║ ║           ├◙ SVal "moarvm" :named("ext")
    ║ ║           └◙ IVal 1 :named("with-nqplib")
    ║ ╟─:Block "interactive_command" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        if $code =:= NO_VALUE {\n            %!i"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $name :decl(param) :returns(str)
    ║ ║ ╟○ $code :decl(param) :default(WVal NO_VALUE)
    ║ ║ ╙─if  ««"$code =:= NO_VALUE {\n            %!interactive_com"...
    ║ ║   ├─eqaddr  ««"=:="
    ║ ║   │ ├○ $code
    ║ ║   │ └◙ WVal NO_VALUE
    ║ ║   ├─ifnull
    ║ ║   │ ├─atkey
    ║ ║   │ │ ├○ attribute %!interactive_commands :returns(VMNull)
    ║ ║   │ │ │ ├─decont
    ║ ║   │ │ │ │ └○ self
    ║ ║   │ │ │ └◙ WVal SmartCompiler
    ║ ║   │ │ └○ $name :returns(str)
    ║ ║   │ └◙ WVal NQPMu
    ║ ║   └─:Block :blocktype(immediate)  ««"{\n            my &code := $code;   # check if it's"...
    ║ ║     ╟○ &code :decl(var)
    ║ ║     ╟─bind :annotations({"var_initialized" => 1})  ««"&code := $code"
    ║ ║     ║ ├○ &code
    ║ ║     ║ └○ $code
    ║ ║     ╙─bindkey  ««":="
    ║ ║       ├○ attribute %!interactive_commands :returns(VMNull)
    ║ ║       │ ├─decont
    ║ ║       │ │ └○ self
    ║ ║       │ └◙ WVal SmartCompiler
    ║ ║       ├○ $name :returns(str)
    ║ ║       └○ &code
    ║ ╟─:Block "readline" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        nqp::printfh($out, $prompt);\n        my"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $in :decl(param)
    ║ ║ ╟○ $out :decl(param)
    ║ ║ ╟○ $prompt :decl(param)
    ║ ║ ╟○ $line :decl(var)
    ║ ║ ╟○ $cmd :decl(var)
    ║ ║ ╟─printfh  ««"nqp::printfh($out, $prompt)"
    ║ ║ ║ ├○ $out
    ║ ║ ║ └○ $prompt
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"$line := trim(nqp::readlinefh($in))"
    ║ ║ ║ ├○ $line
    ║ ║ ║ └─call &trim  ««"nqp::readlinefh($in)"
    ║ ║ ║   └─readlinefh  ««"nqp::readlinefh($in)"
    ║ ║ ║     └○ $in
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"$cmd := self.interactive_command($line)"
    ║ ║ ║ ├○ $cmd
    ║ ║ ║ └─callmethod interactive_command  ««"$line"
    ║ ║ ║   ├─decont
    ║ ║ ║   │ └○ self
    ║ ║ ║   └○ $line
    ║ ║ ╙─if  ««"$cmd {\n            $cmd(:$in, :$out);\n           "...
    ║ ║   ├○ $cmd
    ║ ║   ├─:Stmts  ««"{\n            $cmd(:$in, :$out);\n            '';\"...
    ║ ║   │ ├─call  ««":$in, :$out"
    ║ ║   │ │ ├○ $cmd
    ║ ║   │ │ ├○ $in :named("in")
    ║ ║   │ │ └○ $out :named("out")
    ║ ║   │ └◙ SVal ""
    ║ ║   └○ $line
    ║ ╟─:Block "autoprint" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        #say('$*AUTOPRINTPOS: ' ~ $*AUTOPRINTPOS"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $value :decl(param)
    ║ ║ ╟○ $stdout :decl(param) :default(WVal NQPMu)
    ║ ║ ╙─sayfh  ««"nqp::sayfh($stdout // nqp::getstdout(), $value)"
    ║ ║   ├─defor  ««"//"
    ║ ║   │ ├○ $stdout
    ║ ║   │ └─getstdout  ««"nqp::getstdout()"
    ║ ║   └○ $value
    ║ ╟─:Block "collect_stats" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        my %results := {};\n        my sub doit("...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $node :decl(param)
    ║ ║ ╟○ %results :decl(var)
    ║ ║ ╟─bind
    ║ ║ ║ ├○ &doit :decl(var)
    ║ ║ ║ └─:Block "doit"  ««"{\n            nqp::die(\"collect_stats expects a Q"...
    ║ ║ ║   ╟○ $node :decl(param)
    ║ ║ ║   ╟○ $HOWname :decl(var)
    ║ ║ ║   ╟─unless  ««"nqp::die(\"collect_stats expects a QAST::Node - got"...
    ║ ║ ║   ║ ├─call &istype  ««"$node, QAST::Node"
    ║ ║ ║   ║ │ ├○ $node
    ║ ║ ║   ║ │ └◙ WVal QAST::Node
    ║ ║ ║   ║ └─die  ««"nqp::die(\"collect_stats expects a QAST::Node - got"...
    ║ ║ ║   ║   └─concat  ««"~"
    ║ ║ ║   ║     ├◙ SVal "collect_stats expects a QAST::Node - got "
    ║ ║ ║   ║     └─call &describe  ««"$node"
    ║ ║ ║   ║       └○ $node
    ║ ║ ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$HOWname := howName($node)"
    ║ ║ ║   ║ ├○ $HOWname
    ║ ║ ║   ║ └─call &howName  ««"$node"
    ║ ║ ║   ║   └○ $node
    ║ ║ ║   ╟─postinc  ««"++"
    ║ ║ ║   ║ └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║   ├○ %results
    ║ ║ ║   ║   └◙ SVal "Node"
    ║ ║ ║   ╟─if  ««"istype($node, QAST::Block) {\n                %resu"...
    ║ ║ ║   ║ ├─call &istype  ««"$node, QAST::Block"
    ║ ║ ║   ║ │ ├○ $node
    ║ ║ ║   ║ │ └◙ WVal QAST::Block
    ║ ║ ║   ║ ├─postinc  ««"++"
    ║ ║ ║   ║ │ └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║ │   ├○ %results
    ║ ║ ║   ║ │   └◙ SVal "Block"
    ║ ║ ║   ║ └─if  ««"istype($node, QAST::Stmt, QAST::Stmts) {\n         "...
    ║ ║ ║   ║   ├─call &istype  ««"$node, QAST::Stmt, QAST::Stmts"
    ║ ║ ║   ║   │ ├○ $node
    ║ ║ ║   ║   │ ├◙ WVal QAST::Stmt
    ║ ║ ║   ║   │ └◙ WVal QAST::Stmts
    ║ ║ ║   ║   ├─postinc  ««"++"
    ║ ║ ║   ║   │ └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║   │   ├○ %results
    ║ ║ ║   ║   │   └◙ SVal "Stmt(s)"
    ║ ║ ║   ║   └─if  ««"istype($node, QAST::Op) {\n                my $op :"...
    ║ ║ ║   ║     ├─call &istype  ««"$node, QAST::Op"
    ║ ║ ║   ║     │ ├○ $node
    ║ ║ ║   ║     │ └◙ WVal QAST::Op
    ║ ║ ║   ║     ├─:Block :blocktype(immediate)  ««"{\n                my $op := $node.op;\n    #      "...
    ║ ║ ║   ║     │ ╟○ $op :decl(var)
    ║ ║ ║   ║     │ ╟─bind :annotations({"var_initialized" => 1})  ««"$op := $node.op"
    ║ ║ ║   ║     │ ║ ├○ $op
    ║ ║ ║   ║     │ ║ └─callmethod op  ««".op"
    ║ ║ ║   ║     │ ║   └○ $node
    ║ ║ ║   ║     │ ╟─postinc  ««"++"
    ║ ║ ║   ║     │ ║ └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║     │ ║   ├○ %results
    ║ ║ ║   ║     │ ║   └◙ SVal "op"
    ║ ║ ║   ║     │ ╟─if  ««"%results<list>++        if  $op eq 'list'"
    ║ ║ ║   ║     │ ║ ├─iseq_s  ««"eq"
    ║ ║ ║   ║     │ ║ │ ├○ $op
    ║ ║ ║   ║     │ ║ │ └◙ SVal "list"
    ║ ║ ║   ║     │ ║ └─postinc  ««"++"
    ║ ║ ║   ║     │ ║   └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║     │ ║     ├○ %results
    ║ ║ ║   ║     │ ║     └◙ SVal "list"
    ║ ║ ║   ║     │ ╟─if  ««"%results<hash>++        if  $op eq 'hash'"
    ║ ║ ║   ║     │ ║ ├─iseq_s  ««"eq"
    ║ ║ ║   ║     │ ║ │ ├○ $op
    ║ ║ ║   ║     │ ║ │ └◙ SVal "hash"
    ║ ║ ║   ║     │ ║ └─postinc  ««"++"
    ║ ║ ║   ║     │ ║   └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║     │ ║     ├○ %results
    ║ ║ ║   ║     │ ║     └◙ SVal "hash"
    ║ ║ ║   ║     │ ╟─if  ««"%results<bind>++        if  $op eq 'bind'"
    ║ ║ ║   ║     │ ║ ├─iseq_s  ««"eq"
    ║ ║ ║   ║     │ ║ │ ├○ $op
    ║ ║ ║   ║     │ ║ │ └◙ SVal "bind"
    ║ ║ ║   ║     │ ║ └─postinc  ««"++"
    ║ ║ ║   ║     │ ║   └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║     │ ║     ├○ %results
    ║ ║ ║   ║     │ ║     └◙ SVal "bind"
    ║ ║ ║   ║     │ ╟─if  ««"%results<call>++        if  $op eq 'call'"
    ║ ║ ║   ║     │ ║ ├─iseq_s  ««"eq"
    ║ ║ ║   ║     │ ║ │ ├○ $op
    ║ ║ ║   ║     │ ║ │ └◙ SVal "call"
    ║ ║ ║   ║     │ ║ └─postinc  ««"++"
    ║ ║ ║   ║     │ ║   └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║     │ ║     ├○ %results
    ║ ║ ║   ║     │ ║     └◙ SVal "call"
    ║ ║ ║   ║     │ ╟─if  ««"%results<callstatic>++  if  $op eq 'callstatic'"
    ║ ║ ║   ║     │ ║ ├─iseq_s  ««"eq"
    ║ ║ ║   ║     │ ║ │ ├○ $op
    ║ ║ ║   ║     │ ║ │ └◙ SVal "callstatic"
    ║ ║ ║   ║     │ ║ └─postinc  ««"++"
    ║ ║ ║   ║     │ ║   └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║     │ ║     ├○ %results
    ║ ║ ║   ║     │ ║     └◙ SVal "callstatic"
    ║ ║ ║   ║     │ ╟─if  ««"%results<callmethod>++  if  $op eq 'callmethod'"
    ║ ║ ║   ║     │ ║ ├─iseq_s  ««"eq"
    ║ ║ ║   ║     │ ║ │ ├○ $op
    ║ ║ ║   ║     │ ║ │ └◙ SVal "callmethod"
    ║ ║ ║   ║     │ ║ └─postinc  ««"++"
    ║ ║ ║   ║     │ ║   └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║     │ ║     ├○ %results
    ║ ║ ║   ║     │ ║     └◙ SVal "callmethod"
    ║ ║ ║   ║     │ ╙─if  ««"%results<takeclosure>++ if  $op eq 'takeclosure'"
    ║ ║ ║   ║     │   ├─iseq_s  ««"eq"
    ║ ║ ║   ║     │   │ ├○ $op
    ║ ║ ║   ║     │   │ └◙ SVal "takeclosure"
    ║ ║ ║   ║     │   └─postinc  ««"++"
    ║ ║ ║   ║     │     └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║     │       ├○ %results
    ║ ║ ║   ║     │       └◙ SVal "takeclosure"
    ║ ║ ║   ║     └─if  ««"istype($node, QAST::Var) {\n                %result"...
    ║ ║ ║   ║       ├─call &istype  ««"$node, QAST::Var"
    ║ ║ ║   ║       │ ├○ $node
    ║ ║ ║   ║       │ └◙ WVal QAST::Var
    ║ ║ ║   ║       ├─postinc  ««"++"
    ║ ║ ║   ║       │ └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║       │   ├○ %results
    ║ ║ ║   ║       │   └◙ SVal "Var"
    ║ ║ ║   ║       └─if  ««"istype($node, QAST::IVal) {\n                %resul"...
    ║ ║ ║   ║         ├─call &istype  ««"$node, QAST::IVal"
    ║ ║ ║   ║         │ ├○ $node
    ║ ║ ║   ║         │ └◙ WVal QAST::IVal
    ║ ║ ║   ║         ├─postinc  ««"++"
    ║ ║ ║   ║         │ └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║         │   ├○ %results
    ║ ║ ║   ║         │   └◙ SVal "IVal"
    ║ ║ ║   ║         └─if  ««"istype($node, QAST::NVal) {\n                %resul"...
    ║ ║ ║   ║           ├─call &istype  ««"$node, QAST::NVal"
    ║ ║ ║   ║           │ ├○ $node
    ║ ║ ║   ║           │ └◙ WVal QAST::NVal
    ║ ║ ║   ║           ├─postinc  ««"++"
    ║ ║ ║   ║           │ └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║           │   ├○ %results
    ║ ║ ║   ║           │   └◙ SVal "NVal"
    ║ ║ ║   ║           └─if  ««"istype($node, QAST::SVal) {\n                %resul"...
    ║ ║ ║   ║             ├─call &istype  ««"$node, QAST::SVal"
    ║ ║ ║   ║             │ ├○ $node
    ║ ║ ║   ║             │ └◙ WVal QAST::SVal
    ║ ║ ║   ║             └─:Stmts  ««"{\n                %results<SVal>++;\n             "...
    ║ ║ ║   ║               ├─postinc  ««"++"
    ║ ║ ║   ║               │ └○┬VarWithFallback associative :fallback(WVal NQPMu)
    ║ ║ ║   ║               │   ├○ %results
    ║ ║ ║   ║               │   └◙ SVal "SVal"
    ║ ║ ║   ║               └─bindkey  ««":="
    ║ ║ ║   ║                 ├○ %results
    ║ ║ ║   ║                 ├◙ SVal "SValChars"
    ║ ║ ║   ║                 └─add_n  ««"+"
    ║ ║ ║   ║                   ├─ifnull
    ║ ║ ║   ║                   │ ├─atkey
    ║ ║ ║   ║                   │ │ ├○ %results
    ║ ║ ║   ║                   │ │ └◙ SVal "SValChars"
    ║ ║ ║   ║                   │ └◙ WVal NQPMu
    ║ ║ ║   ║                   └─chars  ««"nqp::chars($node.value)"
    ║ ║ ║   ║                     └─callmethod value  ««".value"
    ║ ║ ║   ║                       └○ $node
    ║ ║ ║   ╙─for  ««"$node.list {\n                doit($_);\n            }"
    ║ ║ ║     ├─callmethod list  ««".list"
    ║ ║ ║     │ └○ $node
    ║ ║ ║     ├─:Block :blocktype(immediate)  ««"{\n                doit($_);\n            }"
    ║ ║ ║     │ ╟○ $_ :decl(param)
    ║ ║ ║     │ ╙─call &doit  ««"$_"
    ║ ║ ║     │   └○ $_
    ║ ║ ║     └◙ IVal 1 :named("nohandler")
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"%results := {}"
    ║ ║ ║ ├○ %results
    ║ ║ ║ └─hash
    ║ ║ ╟○ &doit
    ║ ║ ╟─call &doit  ««"$node"
    ║ ║ ║ └○ $node
    ║ ║ ╟─bindkey  ««":="
    ║ ║ ║ ├○ %results
    ║ ║ ║ ├◙ SVal "callish"
    ║ ║ ║ └─add_n  ««"+"
    ║ ║ ║   ├─add_n  ««"+"
    ║ ║ ║   │ ├─ifnull
    ║ ║ ║   │ │ ├─atkey
    ║ ║ ║   │ │ │ ├○ %results
    ║ ║ ║   │ │ │ └◙ SVal "call"
    ║ ║ ║   │ │ └◙ WVal NQPMu
    ║ ║ ║   │ └─ifnull
    ║ ║ ║   │   ├─atkey
    ║ ║ ║   │   │ ├○ %results
    ║ ║ ║   │   │ └◙ SVal "callstatic"
    ║ ║ ║   │   └◙ WVal NQPMu
    ║ ║ ║   └─ifnull
    ║ ║ ║     ├─atkey
    ║ ║ ║     │ ├○ %results
    ║ ║ ║     │ └◙ SVal "callmethod"
    ║ ║ ║     └◙ WVal NQPMu
    ║ ║ ╟─bindkey  ««":="
    ║ ║ ║ ├○ %results
    ║ ║ ║ ├◙ SVal "val"
    ║ ║ ║ └─add_n  ««"+"
    ║ ║ ║   ├─add_n  ««"+"
    ║ ║ ║   │ ├─ifnull
    ║ ║ ║   │ │ ├─atkey
    ║ ║ ║   │ │ │ ├○ %results
    ║ ║ ║   │ │ │ └◙ SVal "IVal"
    ║ ║ ║   │ │ └◙ WVal NQPMu
    ║ ║ ║   │ └─ifnull
    ║ ║ ║   │   ├─atkey
    ║ ║ ║   │   │ ├○ %results
    ║ ║ ║   │   │ └◙ SVal "NVal"
    ║ ║ ║   │   └◙ WVal NQPMu
    ║ ║ ║   └─ifnull
    ║ ║ ║     ├─atkey
    ║ ║ ║     │ ├○ %results
    ║ ║ ║     │ └◙ SVal "SVal"
    ║ ║ ║     └◙ WVal NQPMu
    ║ ║ ╙○ %results
    ║ ╟─:Block "ast" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        my $ast := $source.ast();\n        self."...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $source :decl(param)
    ║ ║ ╟○ %adverbs :decl(param) :named(1) :slurpy(1)
    ║ ║ ╟○ $ast :decl(var)
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"$ast := $source.ast()"
    ║ ║ ║ ├○ $ast
    ║ ║ ║ └─callmethod ast  ««""
    ║ ║ ║   └○ $source
    ║ ║ ╟─unless  ««"self.panic(\"Unable to obtain AST from \" ~ howName"...
    ║ ║ ║ ├─callmethod ACCEPTS  ««"~~"
    ║ ║ ║ │ ├◙ WVal QAST::Node
    ║ ║ ║ │ └○ $ast
    ║ ║ ║ └─callmethod panic  ««"\"Unable to obtain AST from \" ~ howName($source)"
    ║ ║ ║   ├─decont
    ║ ║ ║   │ └○ self
    ║ ║ ║   └─concat  ««"~"
    ║ ║ ║     ├◙ SVal "Unable to obtain AST from "
    ║ ║ ║     └─call &howName  ««"$source"
    ║ ║ ║       └○ $source
    ║ ║ ╟─callmethod mixin  ««"$ast, StrByDump"
    ║ ║ ║ ├─how  ««".HOW"
    ║ ║ ║ │ └○ $ast
    ║ ║ ║ ├○ $ast
    ║ ║ ║ └◙ WVal StrByDump
    ║ ║ ╟─callmethod log  ««"'ast: ', self.user-progname, ' done.'"
    ║ ║ ║ ├─decont
    ║ ║ ║ │ └○ self
    ║ ║ ║ ├◙ SVal "ast: "
    ║ ║ ║ ├─callmethod user-progname  ««".user-progname"
    ║ ║ ║ │ └─decont
    ║ ║ ║ │   └○ self
    ║ ║ ║ └◙ SVal " done."
    ║ ║ ╙○ $ast
    ║ ╟─:Block "ast_clean" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        self.log('ast_clean: ', self.user-progna"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $ast :decl(param)
    ║ ║ ╟○ %adverbs :decl(param) :named(1) :slurpy(1)
    ║ ║ ╟─callmethod log  ««"'ast_clean: ', self.user-progname, '...'"
    ║ ║ ║ ├─decont
    ║ ║ ║ │ └○ self
    ║ ║ ║ ├◙ SVal "ast_clean: "
    ║ ║ ║ ├─callmethod user-progname  ««".user-progname"
    ║ ║ ║ │ └─decont
    ║ ║ ║ │   └○ self
    ║ ║ ║ └◙ SVal "..."
    ║ ║ ╟─bind  ««":="
    ║ ║ ║ ├○ $ast
    ║ ║ ║ └─call &fix_var_attrs  ««"$ast"
    ║ ║ ║   └○ $ast
    ║ ║ ╟─bind  ««":="
    ║ ║ ║ ├○ $ast
    ║ ║ ║ └─call &drop_takeclosure  ««"$ast"
    ║ ║ ║   └○ $ast
    ║ ║ ╟─bind  ««":="
    ║ ║ ║ ├○ $ast
    ║ ║ ║ └─call &drop_Stmts  ««"$ast"
    ║ ║ ║   └○ $ast
    ║ ║ ╟─callmethod log  ««"'ast_clean: ', self.user-progname, ' / drop_Stmts d"...
    ║ ║ ║ ├─decont
    ║ ║ ║ │ └○ self
    ║ ║ ║ ├◙ SVal "ast_clean: "
    ║ ║ ║ ├─callmethod user-progname  ««".user-progname"
    ║ ║ ║ │ └─decont
    ║ ║ ║ │   └○ self
    ║ ║ ║ └◙ SVal " / drop_Stmts done."
    ║ ║ ╟─bind  ««":="
    ║ ║ ║ ├○ $ast
    ║ ║ ║ └─call &drop_bogusVars  ««"$ast"
    ║ ║ ║   └○ $ast
    ║ ║ ╟─bind  ««":="
    ║ ║ ║ ├○ $ast
    ║ ║ ║ └─call &remove_bogusOpNames  ««"$ast"
    ║ ║ ║   └○ $ast
    ║ ║ ╟─bind  ««":="
    ║ ║ ║ ├○ $ast
    ║ ║ ║ └─call &replace_assoc_and_pos_scoped  ««"$ast"
    ║ ║ ║   └○ $ast
    ║ ║ ╟─bind  ««":="
    ║ ║ ║ ├○ $ast
    ║ ║ ║ └─call &inline_simple_methods  ««"$ast"
    ║ ║ ║   └○ $ast
    ║ ║ ╙○ $ast
    ║ ╟─:Block "inline_subs" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        my @inlinecandidates := [];\n        Tre"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $ast :decl(param)
    ║ ║ ╟○ %adverbs :decl(param) :named(1) :slurpy(1)
    ║ ║ ╟○ @inlinecandidates :decl(var)
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"@inlinecandidates := []"
    ║ ║ ║ ├○ @inlinecandidates
    ║ ║ ║ └─list
    ║ ║ ╟─callmethod dfs-up  ««"\n            -> $n, @a {\n                TreeWalk"...
    ║ ║ ║ ├◙ WVal TreeWalk
    ║ ║ ║ ├─:Block  ««"{\n                TreeWalkDo.recurse(:take(istype("...
    ║ ║ ║ │ ╟○ $n :decl(param)
    ║ ║ ║ │ ╟○ @a :decl(param)
    ║ ║ ║ │ ╙─callmethod recurse  ««":take(istype($n, QAST::Op) && ($n.op eq 'bind')\n  "...
    ║ ║ ║ │   ├◙ WVal TreeWalkDo
    ║ ║ ║ │   └─if :named("take")  ««"&&"
    ║ ║ ║ │     ├─if  ««"&&"
    ║ ║ ║ │     │ ├─if  ««"&&"
    ║ ║ ║ │     │ │ ├─if  ««"&&"
    ║ ║ ║ │     │ │ │ ├─if  ««"&&"
    ║ ║ ║ │     │ │ │ │ ├─call &istype  ««"$n, QAST::Op"
    ║ ║ ║ │     │ │ │ │ │ ├○ $n
    ║ ║ ║ │     │ │ │ │ │ └◙ WVal QAST::Op
    ║ ║ ║ │     │ │ │ │ └─iseq_s  ««"eq"
    ║ ║ ║ │     │ │ │ │   ├─callmethod op  ««".op"
    ║ ║ ║ │     │ │ │ │   │ └○ $n
    ║ ║ ║ │     │ │ │ │   └◙ SVal "bind"
    ║ ║ ║ │     │ │ │ └─call &istype  ««"$n[0], QAST::Var"
    ║ ║ ║ │     │ │ │   ├─ifnull
    ║ ║ ║ │     │ │ │   │ ├─atpos
    ║ ║ ║ │     │ │ │   │ │ ├○ $n
    ║ ║ ║ │     │ │ │   │ │ └◙ IVal 0
    ║ ║ ║ │     │ │ │   │ └◙ WVal NQPMu
    ║ ║ ║ │     │ │ │   └◙ WVal QAST::Var
    ║ ║ ║ │     │ │ └─iseq_n  ««"=="
    ║ ║ ║ │     │ │   ├─index  ««"nqp::index($n[0].name, '&')"
    ║ ║ ║ │     │ │   │ ├─callmethod name  ««".name"
    ║ ║ ║ │     │ │   │ │ └─ifnull
    ║ ║ ║ │     │ │   │ │   ├─atpos
    ║ ║ ║ │     │ │   │ │   │ ├○ $n
    ║ ║ ║ │     │ │   │ │   │ └◙ IVal 0
    ║ ║ ║ │     │ │   │ │   └◙ WVal NQPMu
    ║ ║ ║ │     │ │   │ └◙ SVal "&"
    ║ ║ ║ │     │ │   └◙ IVal 0
    ║ ║ ║ │     │ └─unless  ««"||"
    ║ ║ ║ │     │   ├─iseq_s  ««"eq"
    ║ ║ ║ │     │   │ ├─callmethod decl  ««".decl"
    ║ ║ ║ │     │   │ │ └─ifnull
    ║ ║ ║ │     │   │ │   ├─atpos
    ║ ║ ║ │     │   │ │   │ ├○ $n
    ║ ║ ║ │     │   │ │   │ └◙ IVal 0
    ║ ║ ║ │     │   │ │   └◙ WVal NQPMu
    ║ ║ ║ │     │   │ └◙ SVal "var"
    ║ ║ ║ │     │   └─iseq_s  ««"eq"
    ║ ║ ║ │     │     ├─callmethod decl  ««".decl"
    ║ ║ ║ │     │     │ └─ifnull
    ║ ║ ║ │     │     │   ├─atpos
    ║ ║ ║ │     │     │   │ ├○ $n
    ║ ║ ║ │     │     │   │ └◙ IVal 0
    ║ ║ ║ │     │     │   └◙ WVal NQPMu
    ║ ║ ║ │     │     └◙ SVal "static"
    ║ ║ ║ │     └─call &istype  ««"$n[1], QAST::Block"
    ║ ║ ║ │       ├─ifnull
    ║ ║ ║ │       │ ├─atpos
    ║ ║ ║ │       │ │ ├○ $n
    ║ ║ ║ │       │ │ └◙ IVal 1
    ║ ║ ║ │       │ └◙ WVal NQPMu
    ║ ║ ║ │       └◙ WVal QAST::Block
    ║ ║ ║ ├─:Block  ««"{\n                my $name := $n[0].name;\n       "...
    ║ ║ ║ │ ╟○ $n :decl(param)
    ║ ║ ║ │ ╟○ @a :decl(param)
    ║ ║ ║ │ ╟○ $name :decl(var)
    ║ ║ ║ │ ╟○ %subDesc :decl(var)
    ║ ║ ║ │ ╟─bind :annotations({"var_initialized" => 1})  ««"$name := $n[0].name"
    ║ ║ ║ │ ║ ├○ $name
    ║ ║ ║ │ ║ └─callmethod name  ««".name"
    ║ ║ ║ │ ║   └─ifnull
    ║ ║ ║ │ ║     ├─atpos
    ║ ║ ║ │ ║     │ ├○ $n
    ║ ║ ║ │ ║     │ └◙ IVal 0
    ║ ║ ║ │ ║     └◙ WVal NQPMu
    ║ ║ ║ │ ╟─bind :annotations({"var_initialized" => 1})  ««"%subDesc := collect_params_and_body($n[1], :$name)"
    ║ ║ ║ │ ║ ├○ %subDesc
    ║ ║ ║ │ ║ └─call &collect_params_and_body  ««"$n[1], :$name"
    ║ ║ ║ │ ║   ├─ifnull
    ║ ║ ║ │ ║   │ ├─atpos
    ║ ║ ║ │ ║   │ │ ├○ $n
    ║ ║ ║ │ ║   │ │ └◙ IVal 1
    ║ ║ ║ │ ║   │ └◙ WVal NQPMu
    ║ ║ ║ │ ║   └○ $name :named("name")
    ║ ║ ║ │ ╙─unless  ««"%subDesc<locals> || %subDesc<slurpy> || %subDesc<na"...
    ║ ║ ║ │   ├─unless  ««"||"
    ║ ║ ║ │   │ ├─unless  ««"||"
    ║ ║ ║ │   │ │ ├─unless  ««"||"
    ║ ║ ║ │   │ │ │ ├─unless  ««"||"
    ║ ║ ║ │   │ │ │ │ ├─unless  ««"||"
    ║ ║ ║ │   │ │ │ │ │ ├─ifnull
    ║ ║ ║ │   │ │ │ │ │ │ ├─atkey
    ║ ║ ║ │   │ │ │ │ │ │ │ ├○ %subDesc
    ║ ║ ║ │   │ │ │ │ │ │ │ └◙ SVal "locals"
    ║ ║ ║ │   │ │ │ │ │ │ └◙ WVal NQPMu
    ║ ║ ║ │   │ │ │ │ │ └─ifnull
    ║ ║ ║ │   │ │ │ │ │   ├─atkey
    ║ ║ ║ │   │ │ │ │ │   │ ├○ %subDesc
    ║ ║ ║ │   │ │ │ │ │   │ └◙ SVal "slurpy"
    ║ ║ ║ │   │ │ │ │ │   └◙ WVal NQPMu
    ║ ║ ║ │   │ │ │ │ └─ifnull
    ║ ║ ║ │   │ │ │ │   ├─atkey
    ║ ║ ║ │   │ │ │ │   │ ├○ %subDesc
    ║ ║ ║ │   │ │ │ │   │ └◙ SVal "named"
    ║ ║ ║ │   │ │ │ │   └◙ WVal NQPMu
    ║ ║ ║ │   │ │ │ └─ifnull
    ║ ║ ║ │   │ │ │   ├─atkey
    ║ ║ ║ │   │ │ │   │ ├○ %subDesc
    ║ ║ ║ │   │ │ │   │ └◙ SVal "optional"
    ║ ║ ║ │   │ │ │   └◙ WVal NQPMu
    ║ ║ ║ │   │ │ └─ifnull
    ║ ║ ║ │   │ │   ├─atkey
    ║ ║ ║ │   │ │   │ ├○ %subDesc
    ║ ║ ║ │   │ │   │ └◙ SVal "recursive"
    ║ ║ ║ │   │ │   └◙ WVal NQPMu
    ║ ║ ║ │   │ └─call &istype  ««"%subDesc<body>, QAST::Block, QAST::Stmts, QAST::Stmt"
    ║ ║ ║ │   │   ├─ifnull
    ║ ║ ║ │   │   │ ├─atkey
    ║ ║ ║ │   │   │ │ ├○ %subDesc
    ║ ║ ║ │   │   │ │ └◙ SVal "body"
    ║ ║ ║ │   │   │ └◙ WVal NQPMu
    ║ ║ ║ │   │   ├◙ WVal QAST::Block
    ║ ║ ║ │   │   ├◙ WVal QAST::Stmts
    ║ ║ ║ │   │   └◙ WVal QAST::Stmt
    ║ ║ ║ │   └─push  ««"$n"
    ║ ║ ║ │     ├○ @inlinecandidates
    ║ ║ ║ │     └○ $n
    ║ ║ ║ └○ $ast
    ║ ║ ╟─for  ««"self.log('inline_subs: ', 'candidate ', $_[0].name)"...
    ║ ║ ║ ├○ @inlinecandidates
    ║ ║ ║ └─:Block :blocktype(immediate)
    ║ ║ ║   ╟○ $_ :decl(param)
    ║ ║ ║   ╙─callmethod log  ««"'inline_subs: ', 'candidate ', $_[0].name"
    ║ ║ ║     ├─decont
    ║ ║ ║     │ └○ self
    ║ ║ ║     ├◙ SVal "inline_subs: "
    ║ ║ ║     ├◙ SVal "candidate "
    ║ ║ ║     └─callmethod name  ««".name"
    ║ ║ ║       └─ifnull
    ║ ║ ║         ├─atpos
    ║ ║ ║         │ ├○ $_
    ║ ║ ║         │ └◙ IVal 0
    ║ ║ ║         └◙ WVal NQPMu
    ║ ║ ╟─bind  ««":="
    ║ ║ ║ ├○ $ast
    ║ ║ ║ └─call &inline_simple_subs  ««"$ast, @inlinecandidates"
    ║ ║ ║   ├○ $ast
    ║ ║ ║   └○ @inlinecandidates
    ║ ║ ╙○ $ast
    ║ ╟─:Block "ast_stats" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        my %stats := self.collect_stats($ast);\n"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $ast :decl(param)
    ║ ║ ╟○ %adverbs :decl(param) :named(1) :slurpy(1)
    ║ ║ ╟○ %stats :decl(var)
    ║ ║ ╟○ @statskeyDefs :decl(var)
    ║ ║ ╟○ @statskeys :decl(var)
    ║ ║ ╟─bind
    ║ ║ ║ ├○ &svalPred :decl(var)
    ║ ║ ║ └─:Block "svalPred"  ««"{\n            -> $node { istype($node, QAST::SVal)"...
    ║ ║ ║   ╟○ $value :decl(param) :default(WVal NO_VALUE)
    ║ ║ ║   ╙─:Block  ««"{ istype($node, QAST::SVal) && ($value =:= NO_VALUE"...
    ║ ║ ║     ╟○ $node :decl(param)
    ║ ║ ║     ╙─if  ««"&&"
    ║ ║ ║       ├─call &istype  ««"$node, QAST::SVal"
    ║ ║ ║       │ ├○ $node
    ║ ║ ║       │ └◙ WVal QAST::SVal
    ║ ║ ║       └─unless  ««"||"
    ║ ║ ║         ├─eqaddr  ««"=:="
    ║ ║ ║         │ ├○ $value
    ║ ║ ║         │ └◙ WVal NO_VALUE
    ║ ║ ║         └─iseq_s  ««"eq"
    ║ ║ ║           ├─callmethod value  ««".value"
    ║ ║ ║           │ └○ $node
    ║ ║ ║           └○ $value
    ║ ║ ╟─bind
    ║ ║ ║ ├○ &ivalPred :decl(var)
    ║ ║ ║ └─:Block "ivalPred"  ««"{\n            -> $node { istype($node, QAST::IVal)"...
    ║ ║ ║   ╟○ $value :decl(param) :default(WVal NO_VALUE)
    ║ ║ ║   ╙─:Block  ««"{ istype($node, QAST::IVal) && ($value =:= NO_VALUE"...
    ║ ║ ║     ╟○ $node :decl(param)
    ║ ║ ║     ╙─if  ««"&&"
    ║ ║ ║       ├─call &istype  ««"$node, QAST::IVal"
    ║ ║ ║       │ ├○ $node
    ║ ║ ║       │ └◙ WVal QAST::IVal
    ║ ║ ║       └─unless  ««"||"
    ║ ║ ║         ├─eqaddr  ««"=:="
    ║ ║ ║         │ ├○ $value
    ║ ║ ║         │ └◙ WVal NO_VALUE
    ║ ║ ║         └─iseq_n  ««"=="
    ║ ║ ║           ├─callmethod value  ««".value"
    ║ ║ ║           │ └○ $node
    ║ ║ ║           └○ $value
    ║ ║ ╟─bind
    ║ ║ ║ ├○ &opPred :decl(var)
    ║ ║ ║ └─:Block "opPred"  ««"{\n            -> $node { istype($node, QAST::Op) &"...
    ║ ║ ║   ╟○ $op :decl(param) :default(WVal NO_VALUE)
    ║ ║ ║   ╙─:Block  ««"{ istype($node, QAST::Op) && ($op =:= NO_VALUE || $"...
    ║ ║ ║     ╟○ $node :decl(param)
    ║ ║ ║     ╙─if  ««"&&"
    ║ ║ ║       ├─call &istype  ««"$node, QAST::Op"
    ║ ║ ║       │ ├○ $node
    ║ ║ ║       │ └◙ WVal QAST::Op
    ║ ║ ║       └─unless  ««"||"
    ║ ║ ║         ├─eqaddr  ««"=:="
    ║ ║ ║         │ ├○ $op
    ║ ║ ║         │ └◙ WVal NO_VALUE
    ║ ║ ║         └─iseq_s  ««"eq"
    ║ ║ ║           ├─callmethod op  ««".op"
    ║ ║ ║           │ └○ $node
    ║ ║ ║           └○ $op
    ║ ║ ╟○ $findStatsHash :decl(var)
    ║ ║ ╟○ $infoHashDef :decl(var)
    ║ ║ ╟○ $infoHash :decl(var)
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"%stats := self.collect_stats($ast)"
    ║ ║ ║ ├○ %stats
    ║ ║ ║ └─callmethod collect_stats  ««"$ast"
    ║ ║ ║   ├─decont
    ║ ║ ║   │ └○ self
    ║ ║ ║   └○ $ast
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"@statskeyDefs := findDefs($ast, -> $var, @pathUp {\"...
    ║ ║ ║ ├○ @statskeyDefs
    ║ ║ ║ └─call &findDefs  ««"$ast, -> $var, @pathUp {\n            nqp::index($v"...
    ║ ║ ║   ├○ $ast
    ║ ║ ║   └─:Block  ««"{\n            nqp::index($var.name, 'STATS_') > -1"...
    ║ ║ ║     ╟○ $var :decl(param)
    ║ ║ ║     ╟○ @pathUp :decl(param)
    ║ ║ ║     ╙─isgt_n  ««">"
    ║ ║ ║       ├─index  ««"nqp::index($var.name, 'STATS_')"
    ║ ║ ║       │ ├─callmethod name  ««".name"
    ║ ║ ║       │ │ └○ $var
    ║ ║ ║       │ └◙ SVal "STATS_"
    ║ ║ ║       └◙ IVal -1
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"@statskeys := []"
    ║ ║ ║ ├○ @statskeys
    ║ ║ ║ └─list
    ║ ║ ╟─for  ««"@statskeyDefs {\n            my $v := $_[1][0];\n  "...
    ║ ║ ║ ├○ @statskeyDefs
    ║ ║ ║ ├─:Block :blocktype(immediate)  ««"{\n            my $v := $_[1][0];\n            if i"...
    ║ ║ ║ │ ╟○ $v :decl(var)
    ║ ║ ║ │ ╟○ $_ :decl(param)
    ║ ║ ║ │ ╟─bind :annotations({"var_initialized" => 1})  ««"$v := $_[1][0]"
    ║ ║ ║ │ ║ ├○ $v
    ║ ║ ║ │ ║ └─ifnull
    ║ ║ ║ │ ║   ├─atpos
    ║ ║ ║ │ ║   │ ├─ifnull
    ║ ║ ║ │ ║   │ │ ├─atpos
    ║ ║ ║ │ ║   │ │ │ ├○ $_
    ║ ║ ║ │ ║   │ │ │ └◙ IVal 1
    ║ ║ ║ │ ║   │ │ └◙ WVal NQPMu
    ║ ║ ║ │ ║   │ └◙ IVal 0
    ║ ║ ║ │ ║   └◙ WVal NQPMu
    ║ ║ ║ │ ╙─if  ««"istype($v, QAST::SVal, QAST::IVal, QAST::NVal) {\n "...
    ║ ║ ║ │   ├─call &istype  ««"$v, QAST::SVal, QAST::IVal, QAST::NVal"
    ║ ║ ║ │   │ ├○ $v
    ║ ║ ║ │   │ ├◙ WVal QAST::SVal
    ║ ║ ║ │   │ ├◙ WVal QAST::IVal
    ║ ║ ║ │   │ └◙ WVal QAST::NVal
    ║ ║ ║ │   └─push  ««"$v.value"
    ║ ║ ║ │     ├○ @statskeys
    ║ ║ ║ │     └─callmethod value  ««".value"
    ║ ║ ║ │       └○ $v
    ║ ║ ║ └◙ IVal 1 :named("nohandler")
    ║ ║ ╟○ &svalPred
    ║ ║ ╟○ &ivalPred
    ║ ║ ╟○ &opPred
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"$findStatsHash := findValueNodeInHash(svalPred('sta"...
    ║ ║ ║ ├○ $findStatsHash
    ║ ║ ║ └─call &findValueNodeInHash  ««"svalPred('stats'), opPred('hash')"
    ║ ║ ║   ├─call &svalPred  ««"'stats'"
    ║ ║ ║   │ └◙ SVal "stats"
    ║ ║ ║   └─call &opPred  ««"'hash'"
    ║ ║ ║     └◙ SVal "hash"
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"$infoHashDef := findDef($ast, -> $var, @pathUp {\n "...
    ║ ║ ║ ├○ $infoHashDef
    ║ ║ ║ └─call &findDef  ««"$ast, -> $var, @pathUp {\n            if $var.name "...
    ║ ║ ║   ├○ $ast
    ║ ║ ║   └─:Block  ««"{\n            if $var.name eq '%info' {\n         "...
    ║ ║ ║     ╟○ $var :decl(param)
    ║ ║ ║     ╟○ @pathUp :decl(param)
    ║ ║ ║     ╙─if  ««"$var.name eq '%info' {\n                $findStatsH"...
    ║ ║ ║       ├─iseq_s  ««"eq"
    ║ ║ ║       │ ├─callmethod name  ««".name"
    ║ ║ ║       │ │ └○ $var
    ║ ║ ║       │ └◙ SVal "%info"
    ║ ║ ║       └─call  ««"@pathUp[0][1]"
    ║ ║ ║         ├○ $findStatsHash
    ║ ║ ║         └─ifnull
    ║ ║ ║           ├─atpos
    ║ ║ ║           │ ├─ifnull
    ║ ║ ║           │ │ ├─atpos
    ║ ║ ║           │ │ │ ├○ @pathUp
    ║ ║ ║           │ │ │ └◙ IVal 0
    ║ ║ ║           │ │ └◙ WVal NQPMu
    ║ ║ ║           │ └◙ IVal 1
    ║ ║ ║           └◙ WVal NQPMu
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"$infoHash := $findStatsHash($infoHashDef[1])"
    ║ ║ ║ ├○ $infoHash
    ║ ║ ║ └─call  ««"$infoHashDef[1]"
    ║ ║ ║   ├○ $findStatsHash
    ║ ║ ║   └─ifnull
    ║ ║ ║     ├─atpos
    ║ ║ ║     │ ├○ $infoHashDef
    ║ ║ ║     │ └◙ IVal 1
    ║ ║ ║     └◙ WVal NQPMu
    ║ ║ ╟─if  ««"istype($infoHash, QAST::Op) && ($infoHash.op eq 'ha"...
    ║ ║ ║ ├─if  ««"&&"
    ║ ║ ║ │ ├─call &istype  ««"$infoHash, QAST::Op"
    ║ ║ ║ │ │ ├○ $infoHash
    ║ ║ ║ │ │ └◙ WVal QAST::Op
    ║ ║ ║ │ └─iseq_s  ««"eq"
    ║ ║ ║ │   ├─callmethod op  ««".op"
    ║ ║ ║ │   │ └○ $infoHash
    ║ ║ ║ │   └◙ SVal "hash"
    ║ ║ ║ ├─:Block :blocktype(immediate)  ««"{\n            my $findStatNode := -> $statKey {\n "...
    ║ ║ ║ │ ╟○ $findStatNode :decl(var)
    ║ ║ ║ │ ╟─bind :annotations({"var_initialized" => 1})  ««"$findStatNode := -> $statKey {\n                fin"...
    ║ ║ ║ │ ║ ├○ $findStatNode
    ║ ║ ║ │ ║ └─:Block  ««"{\n                findValueNodeInHash(svalPred($st"...
    ║ ║ ║ │ ║   ╟○ $statKey :decl(param)
    ║ ║ ║ │ ║   ╙─call &findValueNodeInHash  ««"svalPred($statKey), ivalPred(), $infoHash"
    ║ ║ ║ │ ║     ├─call &svalPred  ««"$statKey"
    ║ ║ ║ │ ║     │ └○ $statKey
    ║ ║ ║ │ ║     ├─call &ivalPred  ««""
    ║ ║ ║ │ ║     └○ $infoHash
    ║ ║ ║ │ ╟─for  ««"@statskeys {\n                my $node := $findStat"...
    ║ ║ ║ │ ║ ├○ @statskeys
    ║ ║ ║ │ ║ ├─:Block :blocktype(immediate)  ««"{\n                my $node := $findStatNode($_);\n"...
    ║ ║ ║ │ ║ │ ╟○ $node :decl(var)
    ║ ║ ║ │ ║ │ ╟○ $_ :decl(param)
    ║ ║ ║ │ ║ │ ╟─bind :annotations({"var_initialized" => 1})  ««"$node := $findStatNode($_)"
    ║ ║ ║ │ ║ │ ║ ├○ $node
    ║ ║ ║ │ ║ │ ║ └─call  ««"$_"
    ║ ║ ║ │ ║ │ ║   ├○ $findStatNode
    ║ ║ ║ │ ║ │ ║   └○ $_
    ║ ║ ║ │ ║ │ ╙─if  ««"$node && nqp::existskey(%stats, $_) {\n            "...
    ║ ║ ║ │ ║ │   ├─if  ««"&&"
    ║ ║ ║ │ ║ │   │ ├○ $node
    ║ ║ ║ │ ║ │   │ └─existskey  ««"nqp::existskey(%stats, $_)"
    ║ ║ ║ │ ║ │   │   ├○ %stats
    ║ ║ ║ │ ║ │   │   └○ $_
    ║ ║ ║ │ ║ │   └─callmethod value  ««"%stats{$_}"
    ║ ║ ║ │ ║ │     ├○ $node
    ║ ║ ║ │ ║ │     └─ifnull
    ║ ║ ║ │ ║ │       ├─atkey
    ║ ║ ║ │ ║ │       │ ├○ %stats
    ║ ║ ║ │ ║ │       │ └○ $_
    ║ ║ ║ │ ║ │       └◙ WVal NQPMu
    ║ ║ ║ │ ║ └◙ IVal 1 :named("nohandler")
    ║ ║ ║ │ ╙─callmethod log  ««"'ast_stats: ', dump($infoHashDef, :oneLine)"
    ║ ║ ║ │   ├─decont
    ║ ║ ║ │   │ └○ self
    ║ ║ ║ │   ├◙ SVal "ast_stats: "
    ║ ║ ║ │   └─call &dump  ««"$infoHashDef, :oneLine"
    ║ ║ ║ │     ├○ $infoHashDef
    ║ ║ ║ │     └◙ IVal 1 :named("oneLine")
    ║ ║ ║ └─:Stmts  ««"{\n            self.log('ast_stats WARNING: no %inf"...
    ║ ║ ║   ├─callmethod log  ««"'ast_stats WARNING: no %info hash found in AST of '"...
    ║ ║ ║   │ ├─decont
    ║ ║ ║   │ │ └○ self
    ║ ║ ║   │ ├◙ SVal "ast_stats WARNING: no %info hash found in AST of "
    ║ ║ ║   │ └─callmethod user-progname  ««".user-progname"
    ║ ║ ║   │   └─decont
    ║ ║ ║   │     └○ self
    ║ ║ ║   ├─callmethod log  ««"'ast_stats WARNING: ...dunno how to insert actual s"...
    ║ ║ ║   │ ├─decont
    ║ ║ ║   │ │ └○ self
    ║ ║ ║   │ └◙ SVal "ast_stats WARNING: ...dunno how to insert actual stats - which are:"
    ║ ║ ║   └─for  ««"%stats {\n                self.log('    ', nqp::ite"...
    ║ ║ ║     ├○ %stats
    ║ ║ ║     ├─:Block :blocktype(immediate)  ««"{\n                self.log('    ', nqp::iterkey_s("...
    ║ ║ ║     │ ╟○ $_ :decl(param)
    ║ ║ ║     │ ╙─callmethod log  ««"'    ', nqp::iterkey_s($_), ' = ', nqp::iterval($_)"
    ║ ║ ║     │   ├─decont
    ║ ║ ║     │   │ └○ self
    ║ ║ ║     │   ├◙ SVal "    "
    ║ ║ ║     │   ├─iterkey_s  ««"nqp::iterkey_s($_)"
    ║ ║ ║     │   │ └○ $_
    ║ ║ ║     │   ├◙ SVal " = "
    ║ ║ ║     │   └─iterval  ««"nqp::iterval($_)"
    ║ ║ ║     │     └○ $_
    ║ ║ ║     └◙ IVal 1 :named("nohandler")
    ║ ║ ╙○ $ast
    ║ ╟─:Block "ast_save" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        my $qastfileName := self.user-progname ~"...
    ║ ║ ╟○ self :decl(param) :returns(SmartCompiler)
    ║ ║ ╟○ $ast :decl(param)
    ║ ║ ╟○ %adverbs :decl(param) :named(1) :slurpy(1)
    ║ ║ ╟○ $qastfileName :decl(var)
    ║ ║ ╙─lexotic RETURN
    ║ ║   └─:Stmts  ««"\n        my $qastfileName := self.user-progname ~ "...
    ║ ║     ├─bind :annotations({"var_initialized" => 1})  ««"$qastfileName := self.user-progname ~ '.qast'"
    ║ ║     │ ├○ $qastfileName
    ║ ║     │ └─concat  ««"~"
    ║ ║     │   ├─callmethod user-progname  ««".user-progname"
    ║ ║     │   │ └─decont
    ║ ║     │   │   └○ self
    ║ ║     │   └◙ SVal ".qast"
    ║ ║     ├─if  ««"return $ast\n            if %adverbs<output> eq $qa"...
    ║ ║     │ ├─iseq_s  ««"eq"
    ║ ║     │ │ ├─ifnull
    ║ ║     │ │ │ ├─atkey
    ║ ║     │ │ │ │ ├○ %adverbs
    ║ ║     │ │ │ │ └◙ SVal "output"
    ║ ║     │ │ │ └◙ WVal NQPMu
    ║ ║     │ │ └○ $qastfileName
    ║ ║     │ └─call RETURN
    ║ ║     │   └○ $ast
    ║ ║     ├─call &spew  ««"$qastfileName, ~$ast"
    ║ ║     │ ├○ $qastfileName
    ║ ║     │ └─stringify  ««"~"
    ║ ║     │   └○ $ast
    ║ ║     ├─callmethod log  ««"'ast_save: QAST dump written to ', $qastfileName"
    ║ ║     │ ├─decont
    ║ ║     │ │ └○ self
    ║ ║     │ ├◙ SVal "ast_save: QAST dump written to "
    ║ ║     │ └○ $qastfileName
    ║ ║     └○ $ast
    ║ ╙─:Block "write_bytecode" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        #self.log('write_bytecode: adverbs=' ~ d"...
    ║   ╟○ self :decl(param) :returns(SmartCompiler)
    ║   ╟○ $mast :decl(param)
    ║   ╟○ %adverbs :decl(param) :named(1) :slurpy(1)
    ║   ╟─if  ««"%adverbs<target> eq 'mbc' && %adverbs<output> {\n  "...
    ║   ║ ├─if  ««"&&"
    ║   ║ │ ├─iseq_s  ««"eq"
    ║   ║ │ │ ├─ifnull
    ║   ║ │ │ │ ├─atkey
    ║   ║ │ │ │ │ ├○ %adverbs
    ║   ║ │ │ │ │ └◙ SVal "target"
    ║   ║ │ │ │ └◙ WVal NQPMu
    ║   ║ │ │ └◙ SVal "mbc"
    ║   ║ │ └─ifnull
    ║   ║ │   ├─atkey
    ║   ║ │   │ ├○ %adverbs
    ║   ║ │   │ └◙ SVal "output"
    ║   ║ │   └◙ WVal NQPMu
    ║   ║ ├─callmethod log  ««"'write_bytecode: omitted because of'\n             "...
    ║   ║ │ ├─decont
    ║   ║ │ │ └○ self
    ║   ║ │ └─concat  ««"~"
    ║   ║ │   ├─concat  ««"~"
    ║   ║ │   │ ├─concat  ««"~"
    ║   ║ │   │ │ ├─concat  ««"~"
    ║   ║ │   │ │ │ ├─concat  ««"~"
    ║   ║ │   │ │ │ │ ├─concat  ««"~"
    ║   ║ │   │ │ │ │ │ ├◙ SVal "write_bytecode: omitted because of"
    ║   ║ │   │ │ │ │ │ └◙ SVal " :target(\""
    ║   ║ │   │ │ │ │ └─ifnull
    ║   ║ │   │ │ │ │   ├─atkey
    ║   ║ │   │ │ │ │   │ ├○ %adverbs
    ║   ║ │   │ │ │ │   │ └◙ SVal "target"
    ║   ║ │   │ │ │ │   └◙ WVal NQPMu
    ║   ║ │   │ │ │ └◙ SVal "\")"
    ║   ║ │   │ │ └◙ SVal " and :output(\""
    ║   ║ │   │ └─ifnull
    ║   ║ │   │   ├─atkey
    ║   ║ │   │   │ ├○ %adverbs
    ║   ║ │   │   │ └◙ SVal "output"
    ║   ║ │   │   └◙ WVal NQPMu
    ║   ║ │   └◙ SVal "\")"
    ║   ║ └─:Block :blocktype(immediate)  ««"{\n            my $assmbler := nqp::getcomp('MAST')"...
    ║   ║   ╟○ $assmbler :decl(var)
    ║   ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$assmbler := nqp::getcomp('MAST')"
    ║   ║   ║ ├○ $assmbler
    ║   ║   ║ └─getcomp  ««"nqp::getcomp('MAST')"
    ║   ║   ║   └◙ SVal "MAST"
    ║   ║   ╟─callmethod assemble_to_file  ««"$mast, self.user_binname"
    ║   ║   ║ ├○ $assmbler
    ║   ║   ║ ├○ $mast
    ║   ║   ║ └─callmethod user_binname  ««".user_binname"
    ║   ║   ║   └─decont
    ║   ║   ║     └○ self
    ║   ║   ╙─callmethod log  ««"'write_bytecode: ' ~ describe($mast) ~ ' ~> ' ~ sel"...
    ║   ║     ├─decont
    ║   ║     │ └○ self
    ║   ║     └─concat  ««"~"
    ║   ║       ├─concat  ««"~"
    ║   ║       │ ├─concat  ««"~"
    ║   ║       │ │ ├◙ SVal "write_bytecode: "
    ║   ║       │ │ └─call &describe  ««"$mast"
    ║   ║       │ │   └○ $mast
    ║   ║       │ └◙ SVal " ~> "
    ║   ║       └─callmethod user_binname  ««".user_binname"
    ║   ║         └─decont
    ║   ║           └○ self
    ║   ╙○ $mast
    ╟─:Block :blocktype(immediate)  ««"{\n    \n    method statement_control:sym<use>($/) "...
    ║ ╟○ $?PACKAGE :decl(static) :default((NQPActions, Type object))
    ║ ╟○ $?CLASS :decl(static) :default((NQPActions, Type object))
    ║ ╙─:Block "statement_control:sym<use>" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        my $out;\n\n        my @expPathUp := [];"...
    ║   ╟○ self :decl(param) :returns(NQPActions)
    ║   ╟○ $/ :decl(param)
    ║   ╟─bind  ««"$out"
    ║   ║ ├○ $out :decl(var)
    ║   ║ └◙ WVal NQPMu
    ║   ╟○ @expPathUp :decl(var)
    ║   ╟○ $export :decl(var)
    ║   ╟○ $out
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"@expPathUp := []"
    ║   ║ ├○ @expPathUp
    ║   ║ └─list
    ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$export := findPath(-> $node, @pathUp {\n          "...
    ║   ║ ├○ $export
    ║   ║ └─call &findPath  ««"-> $node, @pathUp {\n            istype($node, QAST"...
    ║   ║   ├─:Block  ««"{\n            istype($node, QAST::Var) && ($node.n"...
    ║   ║   │ ╟○ $node :decl(param)
    ║   ║   │ ╟○ @pathUp :decl(param)
    ║   ║   │ ╙─unless  ««"||"
    ║   ║   │   ├─if  ««"&&"
    ║   ║   │   │ ├─if  ««"&&"
    ║   ║   │   │ │ ├─call &istype  ««"$node, QAST::Var"
    ║   ║   │   │ │ │ ├○ $node
    ║   ║   │   │ │ │ └◙ WVal QAST::Var
    ║   ║   │   │ │ └─iseq_s  ««"eq"
    ║   ║   │   │ │   ├─callmethod name  ««".name"
    ║   ║   │   │ │   │ └○ $node
    ║   ║   │   │ │   └◙ SVal "EXPORT"
    ║   ║   │   │ └─iseq_s  ««"eq"
    ║   ║   │   │   ├─callmethod decl  ««".decl"
    ║   ║   │   │   │ └○ $node
    ║   ║   │   │   └◙ SVal "static"
    ║   ║   │   └─callmethod list  ««".list"
    ║   ║   │     └○ $node
    ║   ║   ├○┬VarWithFallback contextual $*UNIT :fallback((ifnull) ((VarWithFallback associative :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$UNIT")) ((die_s) (SVal "Contextual $*UNIT not found")))
    ║   ║   └○ @expPathUp
    ║   ╟─if  ««"$export {\n            my $deps := findPath(-> $nod"...
    ║   ║ ├○ $export
    ║   ║ └─:Block :blocktype(immediate)  ««"{\n            my $deps := findPath(-> $node, @path"...
    ║   ║   ╟○ $deps :decl(var)
    ║   ║   ╟○ $depOut :decl(var)
    ║   ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$deps := findPath(-> $node, @pathUp {\n            "...
    ║   ║   ║ ├○ $deps
    ║   ║   ║ └─call &findPath  ««"-> $node, @pathUp {\n                if (+@pathUp >"...
    ║   ║   ║   ├─:Block  ««"{\n                if (+@pathUp > 1) && @pathUp[1] "...
    ║   ║   ║   │ ╟○ $node :decl(param)
    ║   ║   ║   │ ╟○ @pathUp :decl(param)
    ║   ║   ║   │ ╙─if  ««"(+@pathUp > 1) && @pathUp[1] =:= @expPathUp[0] {\n "...
    ║   ║   ║   │   ├─if  ««"&&"
    ║   ║   ║   │   │ ├─isgt_n  ««">"
    ║   ║   ║   │   │ │ ├─numify  ««"+"
    ║   ║   ║   │   │ │ │ └○ @pathUp
    ║   ║   ║   │   │ │ └◙ IVal 1
    ║   ║   ║   │   │ └─eqaddr  ««"=:="
    ║   ║   ║   │   │   ├─ifnull
    ║   ║   ║   │   │   │ ├─atpos
    ║   ║   ║   │   │   │ │ ├○ @pathUp
    ║   ║   ║   │   │   │ │ └◙ IVal 1
    ║   ║   ║   │   │   │ └◙ WVal NQPMu
    ║   ║   ║   │   │   └─ifnull
    ║   ║   ║   │   │     ├─atpos
    ║   ║   ║   │   │     │ ├○ @expPathUp
    ║   ║   ║   │   │     │ └◙ IVal 0
    ║   ║   ║   │   │     └◙ WVal NQPMu
    ║   ║   ║   │   ├─:Block :blocktype(immediate)  ««"{\n                    my $parent := @pathUp[0];\n "...
    ║   ║   ║   │   │ ╟○ $parent :decl(var)
    ║   ║   ║   │   │ ╟○ $brother :decl(var)
    ║   ║   ║   │   │ ╟─bind :annotations({"var_initialized" => 1})  ««"$parent := @pathUp[0]"
    ║   ║   ║   │   │ ║ ├○ $parent
    ║   ║   ║   │   │ ║ └─ifnull
    ║   ║   ║   │   │ ║   ├─atpos
    ║   ║   ║   │   │ ║   │ ├○ @pathUp
    ║   ║   ║   │   │ ║   │ └◙ IVal 0
    ║   ║   ║   │   │ ║   └◙ WVal NQPMu
    ║   ║   ║   │   │ ╟─bind :annotations({"var_initialized" => 1})  ««"$brother := $parent[0]"
    ║   ║   ║   │   │ ║ ├○ $brother
    ║   ║   ║   │   │ ║ └─ifnull
    ║   ║   ║   │   │ ║   ├─atpos
    ║   ║   ║   │   │ ║   │ ├○ $parent
    ║   ║   ║   │   │ ║   │ └◙ IVal 0
    ║   ║   ║   │   │ ║   └◙ WVal NQPMu
    ║   ║   ║   │   │ ╙─unless  ««"||"
    ║   ║   ║   │   │   ├─if  ««"&&"
    ║   ║   ║   │   │   │ ├─if  ««"&&"
    ║   ║   ║   │   │   │ │ ├─if  ««"&&"
    ║   ║   ║   │   │   │ │ │ ├─if  ««"&&"
    ║   ║   ║   │   │   │ │ │ │ ├─if  ««"&&"
    ║   ║   ║   │   │   │ │ │ │ │ ├─call &istype  ««"$node, QAST::Op"
    ║   ║   ║   │   │   │ │ │ │ │ │ ├○ $node
    ║   ║   ║   │   │   │ │ │ │ │ │ └◙ WVal QAST::Op
    ║   ║   ║   │   │   │ │ │ │ │ └─iseq_s  ««"eq"
    ║   ║   ║   │   │   │ │ │ │ │   ├─callmethod op  ««".op"
    ║   ║   ║   │   │   │ │ │ │ │   │ └○ $node
    ║   ║   ║   │   │   │ │ │ │ │   └◙ SVal "list"
    ║   ║   ║   │   │   │ │ │ │ └─call &istype  ««"$parent, QAST::Op"
    ║   ║   ║   │   │   │ │ │ │   ├○ $parent
    ║   ║   ║   │   │   │ │ │ │   └◙ WVal QAST::Op
    ║   ║   ║   │   │   │ │ │ └─iseq_s  ««"eq"
    ║   ║   ║   │   │   │ │ │   ├─callmethod op  ««".op"
    ║   ║   ║   │   │   │ │ │   │ └○ $parent
    ║   ║   ║   │   │   │ │ │   └◙ SVal "bind"
    ║   ║   ║   │   │   │ │ └─call &istype  ««"$brother, QAST::Var"
    ║   ║   ║   │   │   │ │   ├○ $brother
    ║   ║   ║   │   │   │ │   └◙ WVal QAST::Var
    ║   ║   ║   │   │   │ └─iseq_s  ««"eq"
    ║   ║   ║   │   │   │   ├─callmethod name  ««".name"
    ║   ║   ║   │   │   │   │ └○ $brother
    ║   ║   ║   │   │   │   └◙ SVal "@?DEPENDENCIES"
    ║   ║   ║   │   │   └─callmethod list  ««".list"
    ║   ║   ║   │   │     └○ $node
    ║   ║   ║   │   └─callmethod list  ««".list"
    ║   ║   ║   │     └○ $node
    ║   ║   ║   └○┬VarWithFallback contextual $*UNIT :fallback((ifnull) ((VarWithFallback associative :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$UNIT")) ((die_s) (SVal "Contextual $*UNIT not found")))
    ║   ║   ╟─unless  ««"$deps {\n                $deps := QAST::Op.new(:op<"...
    ║   ║   ║ ├○ $deps
    ║   ║   ║ └─:Block :blocktype(immediate)  ««"{\n                $deps := QAST::Op.new(:op<list>)"...
    ║   ║   ║   ╟○ $depsBinding :decl(var)
    ║   ║   ║   ╟─bind  ««":="
    ║   ║   ║   ║ ├○ $deps
    ║   ║   ║   ║ └─callmethod new  ««":op<list>"
    ║   ║   ║   ║   ├◙ WVal QAST::Op
    ║   ║   ║   ║   └◙ SVal "list" :named("op")
    ║   ║   ║   ╟─bind :annotations({"var_initialized" => 1})  ««"$depsBinding := QAST::Op.new(:op<bind>,\n          "...
    ║   ║   ║   ║ ├○ $depsBinding
    ║   ║   ║   ║ └─callmethod new  ««":op<bind>,\n                    QAST::Var.new(\n   "...
    ║   ║   ║   ║   ├◙ WVal QAST::Op
    ║   ║   ║   ║   ├◙ SVal "bind" :named("op")
    ║   ║   ║   ║   ├─callmethod new  ««"\n                        :name('@?DEPENDENCIES'),\"...
    ║   ║   ║   ║   │ ├◙ WVal QAST::Var
    ║   ║   ║   ║   │ ├◙ SVal "@?DEPENDENCIES" :named("name")
    ║   ║   ║   ║   │ ├◙ SVal "lexical" :named("scope")
    ║   ║   ║   ║   │ └◙ SVal "static" :named("decl")
    ║   ║   ║   ║   └○ $deps
    ║   ║   ║   ╙─push  ««"$depsBinding"
    ║   ║   ║     ├─ifnull
    ║   ║   ║     │ ├─atpos
    ║   ║   ║     │ │ ├○ @expPathUp
    ║   ║   ║     │ │ └◙ IVal 0
    ║   ║   ║     │ └◙ WVal NQPMu
    ║   ║   ║     └○ $depsBinding
    ║   ║   ╟─push  ««"QAST::SVal.new(:value($/<name>), :node($/))"
    ║   ║   ║ ├○ $deps
    ║   ║   ║ └─callmethod new  ««":value($/<name>), :node($/)"
    ║   ║   ║   ├◙ WVal QAST::SVal
    ║   ║   ║   ├─ifnull :named("value")
    ║   ║   ║   │ ├─atkey
    ║   ║   ║   │ │ ├○ $/
    ║   ║   ║   │ │ └◙ SVal "name"
    ║   ║   ║   │ └◙ WVal NQPMu
    ║   ║   ║   └○ $/ :named("node")
    ║   ║   ╟─callmethod log  ««"$*COMPILER.user_progname, ' dependency: \"' ~ $/<na"...
    ║   ║   ║ ├○┬VarWithFallback contextual $*COMPILER :fallback((ifnull) ((VarWithFallback associative :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$COMPILER")) ((die_s) (SVal "Contextual $*COMPILER not found")))
    ║   ║   ║ ├─callmethod user_progname  ««".user_progname"
    ║   ║   ║ │ └○┬VarWithFallback contextual $*COMPILER :fallback((ifnull) ((VarWithFallback associative :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$COMPILER")) ((die_s) (SVal "Contextual $*COMPILER not found")))
    ║   ║   ║ └─concat  ««"~"
    ║   ║   ║   ├─concat  ««"~"
    ║   ║   ║   │ ├◙ SVal " dependency: \""
    ║   ║   ║   │ └─ifnull
    ║   ║   ║   │   ├─atkey
    ║   ║   ║   │   │ ├○ $/
    ║   ║   ║   │   │ └◙ SVal "name"
    ║   ║   ║   │   └◙ WVal NQPMu
    ║   ║   ║   └◙ SVal "\""
    ║   ║   ╙─bind :annotations({"var_initialized" => 1})  ««"$depOut := $*COMPILER.compileDependency(~$/<name>, [])"
    ║   ║     ├○ $depOut
    ║   ║     └─callmethod compileDependency  ««"~$/<name>, []"
    ║   ║       ├○┬VarWithFallback contextual $*COMPILER :fallback((ifnull) ((VarWithFallback associative :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$COMPILER")) ((die_s) (SVal "Contextual $*COMPILER not found")))
    ║   ║       ├─stringify  ««"~"
    ║   ║       │ └─ifnull
    ║   ║       │   ├─atkey
    ║   ║       │   │ ├○ $/
    ║   ║       │   │ └◙ SVal "name"
    ║   ║       │   └◙ WVal NQPMu
    ║   ║       └─list
    ║   ╟─bind  ««":="
    ║   ║ ├○ $out
    ║   ║ └─call &super  ««"self, 'statement_control:sym<use>', $/"
    ║   ║   ├─decont
    ║   ║   │ └○ self
    ║   ║   ├◙ SVal "statement_control:sym<use>"
    ║   ║   └○ $/
    ║   ╟─callmethod node  ««"$/"
    ║   ║ ├○ $out
    ║   ║ └○ $/
    ║   ╟─callmethod annotate  ««"'use', ~$/<name>"
    ║   ║ ├○ $out
    ║   ║ ├◙ SVal "use"
    ║   ║ └─stringify  ««"~"
    ║   ║   └─ifnull
    ║   ║     ├─atkey
    ║   ║     │ ├○ $/
    ║   ║     │ └◙ SVal "name"
    ║   ║     └◙ WVal NQPMu
    ║   ╙─callmethod make  ««"make "
    ║     ├○ $/
    ║     └○ $out
    ╟─bind :annotations({"var_initialized" => 1})  ««"$needsCompilation := 0"
    ║ ├○ $needsCompilation
    ║ └◙ IVal 0
    ╟─:Block :blocktype(immediate)  ««"{\n\n    method BUILD() {\n        self.language('n"...
    ║ ╟○ $?PACKAGE :decl(static) :default((NQPCompiler, Type object))
    ║ ╟○ $?CLASS :decl(static) :default((NQPCompiler, Type object))
    ║ ╟─:Block "BUILD" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        self.language('nqp');\n        self.pars"...
    ║ ║ ╟○ self :decl(param) :returns(NQPCompiler)
    ║ ║ ╙─lexotic RETURN
    ║ ║   └─:Stmts  ««"\n        self.language('nqp');\n        self.parse"...
    ║ ║     ├─callmethod language  ««"'nqp'"
    ║ ║     │ ├─decont
    ║ ║     │ │ └○ self
    ║ ║     │ └◙ SVal "nqp"
    ║ ║     ├─callmethod parsegrammar  ««"NQP::Grammar"
    ║ ║     │ ├─decont
    ║ ║     │ │ └○ self
    ║ ║     │ └◙ WVal NQP::Grammar
    ║ ║     ├─callmethod parseactions  ««"NQPActions"
    ║ ║     │ ├─decont
    ║ ║     │ │ └○ self
    ║ ║     │ └◙ WVal NQPActions
    ║ ║     └─call RETURN
    ║ ║       └─decont
    ║ ║         └○ self
    ║ ╟─:Block "parse" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        self.log('parse: ', self.user-progname, "...
    ║ ║ ╟○ self :decl(param) :returns(NQPCompiler)
    ║ ║ ╟○ $source :decl(param)
    ║ ║ ╟○ %adverbs :decl(param) :named(1) :slurpy(1)
    ║ ║ ╟○ $*COMPILER :decl(var)
    ║ ║ ╟○ $out :decl(var)
    ║ ║ ╟─callmethod log  ««"'parse: ', self.user-progname, '...'"
    ║ ║ ║ ├─decont
    ║ ║ ║ │ └○ self
    ║ ║ ║ ├◙ SVal "parse: "
    ║ ║ ║ ├─callmethod user-progname  ««".user-progname"
    ║ ║ ║ │ └─decont
    ║ ║ ║ │   └○ self
    ║ ║ ║ └◙ SVal "..."
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"$*COMPILER := self"
    ║ ║ ║ ├○┬VarWithFallback contextual $*COMPILER :fallback((ifnull) ((VarWithFallback associative :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$COMPILER")) ((die_s) (SVal "Contextual $*COMPILER not found")))
    ║ ║ ║ └─decont
    ║ ║ ║   └○ self
    ║ ║ ╟─bind :annotations({"var_initialized" => 1})  ««"$out := super(self, 'parse', $source, |%adverbs)"
    ║ ║ ║ ├○ $out
    ║ ║ ║ └─call &super  ««"self, 'parse', $source, |%adverbs"
    ║ ║ ║   ├─decont
    ║ ║ ║   │ └○ self
    ║ ║ ║   ├◙ SVal "parse"
    ║ ║ ║   ├○ $source
    ║ ║ ║   └○ %adverbs :flat(1) :named(1)
    ║ ║ ╟─callmethod log  ««"'parse: ', self.user-progname, ' done.'"
    ║ ║ ║ ├─decont
    ║ ║ ║ │ └○ self
    ║ ║ ║ ├◙ SVal "parse: "
    ║ ║ ║ ├─callmethod user-progname  ««".user-progname"
    ║ ║ ║ │ └─decont
    ║ ║ ║ │   └○ self
    ║ ║ ║ └◙ SVal " done."
    ║ ║ ╙○ $out
    ║ ╟─:Block "compiler_progname" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{ 'nqpc' }"
    ║ ║ ╟○ self :decl(param) :returns(NQPCompiler)
    ║ ║ ╟○ $value :decl(param) :default(WVal NO_VALUE)
    ║ ║ ╙◙ SVal "nqpc"
    ║ ╟─:Block "handle-exception" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        nqp::rethrow($error);\n    }"
    ║ ║ ╟○ self :decl(param) :returns(NQPCompiler)
    ║ ║ ╟○ $error :decl(param)
    ║ ║ ╙─rethrow  ««"nqp::rethrow($error)"
    ║ ║   └○ $error
    ║ ╙─:Block "compileFile" :annotations({"compile_time_dummy" => (BOOTCode, invokable), "code_obj" => (NQPRoutine, invokable)}) :blocktype(declaration_static)  ««"{\n        # replace all backslashes with slashes\n"...
    ║   ╟○ self :decl(param) :returns(NQPCompiler)
    ║   ╟○ $src_path :decl(param)
    ║   ╟○ $target :decl(param) :named("target") :default(SVal "mbc")
    ║   ╟○ $stagestats :decl(param) :named("stagestats") :default(WVal NQPMu)
    ║   ╟○ %adverbs :decl(param) :named(1) :slurpy(1)
    ║   ╟○ $cwd :decl(var)
    ║   ╟○ $l :decl(var)
    ║   ╟○ $x :decl(var)
    ║   ╟○ $src_ext :decl(var)
    ║   ╟○ $i :decl(var)
    ║   ╟○ $src_name :decl(var)
    ║   ╟○ $src_dir :decl(var)
    ║   ╟○ $src_lib :decl(var)
    ║   ╟○ $vm_ext :decl(var)
    ║   ╟○ $vm_dir :decl(var)
    ║   ╟─bind  ««"$vm_path"
    ║   ║ ├○ $vm_path :decl(var)
    ║   ║ └◙ WVal NQPMu
    ║   ╟○ $ast_path :decl(var)
    ║   ╙─lexotic RETURN
    ║     └─:Stmts  ««"\n        # replace all backslashes with slashes\n "...
    ║       ├─bind  ««":="
    ║       │ ├○ $src_path
    ║       │ └─join  ««"nqp::join('/', nqp::split('\\\\', $src_path))"
    ║       │   ├◙ SVal "/"
    ║       │   └─split  ««"nqp::split('\\\\', $src_path)"
    ║       │     ├◙ SVal "\\"
    ║       │     └○ $src_path
    ║       ├─if  ««"!nqp::filereadable($src_path) {\n            #self."...
    ║       │ ├─falsey  ««"!"
    ║       │ │ └─filereadable  ««"nqp::filereadable($src_path)"
    ║       │ │   └○ $src_path
    ║       │ └◙ WVal NQPMu
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$cwd := nqp::join('/', nqp::split('\\\\', nqp::cwd))"
    ║       │ ├○ $cwd
    ║       │ └─join  ««"nqp::join('/', nqp::split('\\\\', nqp::cwd))"
    ║       │   ├◙ SVal "/"
    ║       │   └─split  ««"nqp::split('\\\\', nqp::cwd)"
    ║       │     ├◙ SVal "\\"
    ║       │     └─cwd  ««"nqp::cwd"
    ║       ├─if  ««"nqp::index($src_path, $cwd) == 0 {\n            $sr"...
    ║       │ ├─iseq_n  ««"=="
    ║       │ │ ├─index  ««"nqp::index($src_path, $cwd)"
    ║       │ │ │ ├○ $src_path
    ║       │ │ │ └○ $cwd
    ║       │ │ └◙ IVal 0
    ║       │ └─bind  ««":="
    ║       │   ├○ $src_path
    ║       │   └─substr  ««"nqp::substr($src_path, nqp::chars($cwd) + 1)"
    ║       │     ├○ $src_path
    ║       │     └─add_n  ««"+"
    ║       │       ├─chars  ««"nqp::chars($cwd)"
    ║       │       │ └○ $cwd
    ║       │       └◙ IVal 1
    ║       ├─if  ««"nqp::index($src_path, './') == 0 {\n            $sr"...
    ║       │ ├─iseq_n  ««"=="
    ║       │ │ ├─index  ««"nqp::index($src_path, './')"
    ║       │ │ │ ├○ $src_path
    ║       │ │ │ └◙ SVal "./"
    ║       │ │ └◙ IVal 0
    ║       │ └─bind  ««":="
    ║       │   ├○ $src_path
    ║       │   └─substr  ««"nqp::substr($src_path, 2)"
    ║       │     ├○ $src_path
    ║       │     └◙ IVal 2
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$l := nqp::chars($src_path)"
    ║       │ ├○ $l
    ║       │ └─chars  ««"nqp::chars($src_path)"
    ║       │   └○ $src_path
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$x := nqp::rindex($src_path, '.')"
    ║       │ ├○ $x
    ║       │ └─rindex  ««"nqp::rindex($src_path, '.')"
    ║       │   ├○ $src_path
    ║       │   └◙ SVal "."
    ║       ├─if  ««"$x <= 0 {    # yes, also files like \".gitignore\","...
    ║       │ ├─isle_n  ««"<="
    ║       │ │ ├○ $x
    ║       │ │ └◙ IVal 0
    ║       │ └─callmethod panic  ««"\"invalid source file (no extension): $src_path\""
    ║       │   ├─decont
    ║       │   │ └○ self
    ║       │   └─concat
    ║       │     ├◙ SVal "invalid source file (no extension): "
    ║       │     └○ $src_path
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$src_ext := nqp::substr($src_path, $x + 1)"
    ║       │ ├○ $src_ext
    ║       │ └─substr  ««"nqp::substr($src_path, $x + 1)"
    ║       │   ├○ $src_path
    ║       │   └─add_n  ««"+"
    ║       │     ├○ $x
    ║       │     └◙ IVal 1
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$i := nqp::rindex($src_path, '/')"
    ║       │ ├○ $i
    ║       │ └─rindex  ««"nqp::rindex($src_path, '/')"
    ║       │   ├○ $src_path
    ║       │   └◙ SVal "/"
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$src_name := nqp::substr($src_path, $i + 1, $x - $i"...
    ║       │ ├○ $src_name
    ║       │ └─substr  ««"nqp::substr($src_path, $i + 1, $x - $i - 1)"
    ║       │   ├○ $src_path
    ║       │   ├─add_n  ««"+"
    ║       │   │ ├○ $i
    ║       │   │ └◙ IVal 1
    ║       │   └─sub_n  ««"-"
    ║       │     ├─sub_n  ««"-"
    ║       │     │ ├○ $x
    ║       │     │ └○ $i
    ║       │     └◙ IVal 1
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$src_dir := nqp::substr($src_path, 0, max(0, $i))"
    ║       │ ├○ $src_dir
    ║       │ └─substr  ««"nqp::substr($src_path, 0, max(0, $i))"
    ║       │   ├○ $src_path
    ║       │   ├◙ IVal 0
    ║       │   └─call &max  ««"0, $i"
    ║       │     ├◙ IVal 0
    ║       │     └○ $i
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$src_lib := ''"
    ║       │ ├○ $src_lib
    ║       │ └◙ SVal ""
    ║       ├─for  ««"self.user_srcpaths {\n            if nqp::index($sr"...
    ║       │ ├─callmethod user_srcpaths  ««".user_srcpaths"
    ║       │ │ └─decont
    ║       │ │   └○ self
    ║       │ └─:Block :blocktype(immediate)  ««"{\n            if nqp::index($src_dir, $_) == 0 {\n"...
    ║       │   ╟○ $_ :decl(param)
    ║       │   ╙─if  ««"nqp::index($src_dir, $_) == 0 {\n                $s"...
    ║       │     ├─iseq_n  ««"=="
    ║       │     │ ├─index  ««"nqp::index($src_dir, $_)"
    ║       │     │ │ ├○ $src_dir
    ║       │     │ │ └○ $_
    ║       │     │ └◙ IVal 0
    ║       │     └─:Stmts  ««"{\n                $src_lib := nqp::substr($src_dir"...
    ║       │       ├─bind  ««":="
    ║       │       │ ├○ $src_lib
    ║       │       │ └─substr  ««"nqp::substr($src_dir, nqp::chars($_) + 1)"
    ║       │       │   ├○ $src_dir
    ║       │       │   └─add_n  ««"+"
    ║       │       │     ├─chars  ««"nqp::chars($_)"
    ║       │       │     │ └○ $_
    ║       │       │     └◙ IVal 1
    ║       │       ├─bind  ««":="
    ║       │       │ ├○ $src_dir
    ║       │       │ └○ $_
    ║       │       └─control last
    ║       ├─unless  ««"$src_dir {\n            $src_dir := '.';\n        }"
    ║       │ ├○ $src_dir
    ║       │ └─bind  ««":="
    ║       │   ├○ $src_dir
    ║       │   └◙ SVal "."
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$vm_ext  := 'moarvm'"
    ║       │ ├○ $vm_ext
    ║       │ └◙ SVal "moarvm"
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$vm_dir  := 'blib'"
    ║       │ ├○ $vm_dir
    ║       │ └◙ SVal "blib"
    ║       ├○ $vm_path
    ║       ├─if  ««"$src_lib {\n            $src_path := \"$src_dir/$sr"...
    ║       │ ├○ $src_lib
    ║       │ ├─:Stmts  ««"{\n            $src_path := \"$src_dir/$src_lib/$sr"...
    ║       │ │ ├─bind  ««":="
    ║       │ │ │ ├○ $src_path
    ║       │ │ │ └─concat
    ║       │ │ │   ├─concat
    ║       │ │ │   │ ├─concat
    ║       │ │ │   │ │ ├─concat
    ║       │ │ │   │ │ │ ├─concat
    ║       │ │ │   │ │ │ │ ├─concat
    ║       │ │ │   │ │ │ │ │ ├○ $src_dir
    ║       │ │ │   │ │ │ │ │ └◙ SVal "/"
    ║       │ │ │   │ │ │ │ └○ $src_lib
    ║       │ │ │   │ │ │ └◙ SVal "/"
    ║       │ │ │   │ │ └○ $src_name
    ║       │ │ │   │ └◙ SVal "."
    ║       │ │ │   └○ $src_ext
    ║       │ │ └─bind  ««":="
    ║       │ │   ├○ $vm_path
    ║       │ │   └─concat
    ║       │ │     ├─concat
    ║       │ │     │ ├─concat
    ║       │ │     │ │ ├─concat
    ║       │ │     │ │ │ ├─concat
    ║       │ │     │ │ │ │ ├─concat
    ║       │ │     │ │ │ │ │ ├○ $vm_dir
    ║       │ │     │ │ │ │ │ └◙ SVal "/"
    ║       │ │     │ │ │ │ └○ $src_lib
    ║       │ │     │ │ │ └◙ SVal "/"
    ║       │ │     │ │ └○ $src_name
    ║       │ │     │ └◙ SVal "."
    ║       │ │     └○ $vm_ext
    ║       │ └─:Stmts  ««"{\n            $src_path := \"$src_dir/$src_name.$s"...
    ║       │   ├─bind  ««":="
    ║       │   │ ├○ $src_path
    ║       │   │ └─concat
    ║       │   │   ├─concat
    ║       │   │   │ ├─concat
    ║       │   │   │ │ ├─concat
    ║       │   │   │ │ │ ├○ $src_dir
    ║       │   │   │ │ │ └◙ SVal "/"
    ║       │   │   │ │ └○ $src_name
    ║       │   │   │ └◙ SVal "."
    ║       │   │   └○ $src_ext
    ║       │   └─bind  ««":="
    ║       │     ├○ $vm_path
    ║       │     └─concat
    ║       │       ├─concat
    ║       │       │ ├─concat
    ║       │       │ │ ├─concat
    ║       │       │ │ │ ├○ $vm_dir
    ║       │       │ │ │ └◙ SVal "/"
    ║       │       │ │ └○ $src_name
    ║       │       │ └◙ SVal "."
    ║       │       └○ $vm_ext
    ║       ├─callmethod user_binname  ««"$vm_path"
    ║       │ ├─decont
    ║       │ │ └○ self
    ║       │ └○ $vm_path
    ║       ├─bind :annotations({"var_initialized" => 1})  ««"$ast_path := \"$src_path.qast\""
    ║       │ ├○ $ast_path
    ║       │ └─concat
    ║       │   ├○ $src_path
    ║       │   └◙ SVal ".qast"
    ║       ├─bind  ««":="
    ║       │ ├○ $needsCompilation
    ║       │ └◙ IVal 1
    ║       └─if  ««"!$needsCompilation {\n            return nqp::null;"...
    ║         ├─falsey  ««"!"
    ║         │ └○ $needsCompilation
    ║         ├─call RETURN
    ║         │ └─null  ««"nqp::null"
    ║         └─:Block :blocktype(immediate)  ««"{\n            my @opts := [\n                #'--m"...
    ║           ╟○ @opts :decl(var)
    ║           ╟○ @args :decl(var)
    ║           ╟○ $*USER_FILE :decl(var)
    ║           ╟─bind  ««"$result"
    ║           ║ ├○ $result :decl(var)
    ║           ║ └◙ WVal NQPMu
    ║           ╟─bind  ««"$error"
    ║           ║ ├○ $error :decl(var)
    ║           ║ └◙ WVal NQPMu
    ║           ╟○ $msg :decl(var)
    ║           ╟○ $msglc :decl(var)
    ║           ╟─bind  ««"$from"
    ║           ║ ├○ $from :decl(var)
    ║           ║ └◙ WVal NQPMu
    ║           ╟─bind  ««"$to"
    ║           ║ ├○ $to :decl(var)
    ║           ║ └◙ WVal NQPMu
    ║           ╟─bind :annotations({"var_initialized" => 1})  ««"@opts := [\n                #'--module-path=L',\n  "...
    ║           ║ ├○ @opts
    ║           ║ └─list
    ║           ╟─if  ««"@opts.push(\"--target=$target\") if $target"
    ║           ║ ├○ $target
    ║           ║ └─push  ««"\"--target=$target\""
    ║           ║   ├○ @opts
    ║           ║   └─concat
    ║           ║     ├◙ SVal "--target="
    ║           ║     └○ $target
    ║           ╟─if  ««"$target eq 'mbc' {\n                if nqp::stat($v"...
    ║           ║ ├─iseq_s  ««"eq"
    ║           ║ │ ├○ $target
    ║           ║ │ └◙ SVal "mbc"
    ║           ║ ├─:Stmts  ««"{\n                if nqp::stat($vm_path, nqp::cons"...
    ║           ║ │ ├─if  ««"nqp::stat($vm_path, nqp::const::STAT_EXISTS) && !nq"...
    ║           ║ │ │ ├─if  ««"&&"
    ║           ║ │ │ │ ├─stat  ««"nqp::stat($vm_path, nqp::const::STAT_EXISTS)"
    ║           ║ │ │ │ │ ├○ $vm_path
    ║           ║ │ │ │ │ └─const STAT_EXISTS
    ║           ║ │ │ │ └─falsey  ««"!"
    ║           ║ │ │ │   └─filewritable  ««"nqp::filewritable($vm_path)"
    ║           ║ │ │ │     └○ $vm_path
    ║           ║ │ │ └─die  ««"nqp::die(\"cannot write to file: $vm_path\")"
    ║           ║ │ │   └─concat
    ║           ║ │ │     ├◙ SVal "cannot write to file: "
    ║           ║ │ │     └○ $vm_path
    ║           ║ │ └─push  ««"'--output=' ~ $vm_path"
    ║           ║ │   ├○ @opts
    ║           ║ │   └─concat  ««"~"
    ║           ║ │     ├◙ SVal "--output="
    ║           ║ │     └○ $vm_path
    ║           ║ └─if  ««"$target eq 'ast' || $target eq 'ast_clean' || $targ"...
    ║           ║   ├─unless  ««"||"
    ║           ║   │ ├─unless  ««"||"
    ║           ║   │ │ ├─iseq_s  ««"eq"
    ║           ║   │ │ │ ├○ $target
    ║           ║   │ │ │ └◙ SVal "ast"
    ║           ║   │ │ └─iseq_s  ««"eq"
    ║           ║   │ │   ├○ $target
    ║           ║   │ │   └◙ SVal "ast_clean"
    ║           ║   │ └─iseq_s  ««"eq"
    ║           ║   │   ├○ $target
    ║           ║   │   └◙ SVal "ast_save"
    ║           ║   └─push  ««"'--output=' ~ $ast_path"
    ║           ║     ├○ @opts
    ║           ║     └─concat  ««"~"
    ║           ║       ├◙ SVal "--output="
    ║           ║       └○ $ast_path
    ║           ╟─bind :annotations({"var_initialized" => 1})  ««"@args := nqp::clone(@opts)"
    ║           ║ ├○ @args
    ║           ║ └─clone  ««"nqp::clone(@opts)"
    ║           ║   └○ @opts
    ║           ╟─unshift  ««"'nqpc'"
    ║           ║ ├○ @args
    ║           ║ └◙ SVal "nqpc"
    ║           ╟─push  ««"$src_path"
    ║           ║ ├○ @args
    ║           ║ └○ $src_path
    ║           ╟─callmethod log  ««"'$ ', nqp::join(' ', @args)"
    ║           ║ ├─decont
    ║           ║ │ └○ self
    ║           ║ ├◙ SVal "$ "
    ║           ║ └─join  ««"nqp::join(' ', @args)"
    ║           ║   ├◙ SVal " "
    ║           ║   └○ @args
    ║           ╟─bind :annotations({"var_initialized" => 1})  ««"$*USER_FILE := $src_path"
    ║           ║ ├○┬VarWithFallback contextual $*USER_FILE :fallback((ifnull) ((VarWithFallback associative :fallback(WVal NQPMu)) ((who) (WVal GLOBALish)) (SVal "$USER_FILE")) ((die_s) (SVal "Contextual $*USER_FILE not found")))
    ║           ║ └○ $src_path
    ║           ╟○ $result
    ║           ╟○ $error
    ║           ╟─handle
    ║           ║ ├─handle
    ║           ║ │ ├─:Stmts  ««"\n                $result := self.command_line(@arg"...
    ║           ║ │ │ ├─bind  ««":="
    ║           ║ │ │ │ ├○ $result
    ║           ║ │ │ │ └─callmethod command_line  ««"@args, \n                    :encoding('utf8'), \n "...
    ║           ║ │ │ │   ├─decont
    ║           ║ │ │ │   │ └○ self
    ║           ║ │ │ │   ├○ @args
    ║           ║ │ │ │   ├◙ SVal "utf8" :named("encoding")
    ║           ║ │ │ │   ├◙ SVal "ascii iso-8859-1" :named("transcode")
    ║           ║ │ │ │   └○ $stagestats :named("stagestats")
    ║           ║ │ │ └◙ WVal NQPMu
    ║           ║ │ ├► "CATCH" (str)
    ║           ║ │ └─:Stmts
    ║           ║ │   ├─call
    ║           ║ │   │ ├─:Block  ««"{\n                    $error := $_;\n             "...
    ║           ║ │   │ │ ╟○ $_ :decl(param)
    ║           ║ │   │ │ ╟─bind
    ║           ║ │   │ │ ║ ├○ $! :decl(var)
    ║           ║ │   │ │ ║ └○ $_
    ║           ║ │   │ │ ╙─bind  ««":="
    ║           ║ │   │ │   ├○ $error
    ║           ║ │   │ │   └○ $_
    ║           ║ │   │ └─exception
    ║           ║ │   ├─:VM
    ║           ║ │   └◙ WVal NQPMu
    ║           ║ ├► "CATCH" (str)
    ║           ║ └─:Stmts
    ║           ║   ├─:VM
    ║           ║   └◙ WVal NQPMu
    ║           ╟─unless  ««"$error {\n                if nqp::isnull($result) {"...
    ║           ║ ├○ $error
    ║           ║ └─:Stmts  ««"{\n                if nqp::isnull($result) {   # re"...
    ║           ║   ├─if  ««"nqp::isnull($result) {   # returning non-null means"...
    ║           ║   │ ├─isnull  ««"nqp::isnull($result)"
    ║           ║   │ │ └○ $result
    ║           ║   │ └─if  ««"$target eq 'mbc' {\n                        $result"...
    ║           ║   │   ├─iseq_s  ««"eq"
    ║           ║   │   │ ├○ $target
    ║           ║   │   │ └◙ SVal "mbc"
    ║           ║   │   ├─bind  ««":="
    ║           ║   │   │ ├○ $result
    ║           ║   │   │ └○ $vm_path
    ║           ║   │   └─die  ««"nqp::die(\"??? - successfully compiled $src_path to"...
    ║           ║   │     └─concat
    ║           ║   │       ├─concat
    ║           ║   │       │ ├─concat
    ║           ║   │       │ │ ├─concat
    ║           ║   │       │ │ │ ├◙ SVal "??? - successfully compiled "
    ║           ║   │       │ │ │ └○ $src_path
    ║           ║   │       │ │ └◙ SVal " to target "
    ║           ║   │       │ └○ $target
    ║           ║   │       └◙ SVal " - but got null result...!?"
    ║           ║   └─call RETURN
    ║           ║     └○ $result
    ║           ╟─bind :annotations({"var_initialized" => 1})  ««"$msg := nqp::getmessage($error)"
    ║           ║ ├○ $msg
    ║           ║ └─getmessage  ««"nqp::getmessage($error)"
    ║           ║   └○ $error
    ║           ╟─bind :annotations({"var_initialized" => 1})  ««"$msglc := nqp::lc($msg)"
    ║           ║ ├○ $msglc
    ║           ║ └─lc  ««"nqp::lc($msg)"
    ║           ║   └○ $msg
    ║           ╟○ $from
    ║           ╟○ $to
    ║           ╟─if  ««"nqp::index($msglc, 'no such file') > -1 {\n        "...
    ║           ║ ├─isgt_n  ««">"
    ║           ║ │ ├─index  ««"nqp::index($msglc, 'no such file')"
    ║           ║ │ │ ├○ $msglc
    ║           ║ │ │ └◙ SVal "no such file"
    ║           ║ │ └◙ IVal -1
    ║           ║ ├─:Block :blocktype(immediate)  ««"{\n                $from := nqp::index($msglc, '\\'"...
    ║           ║ │ ╟○ $file :decl(var)
    ║           ║ │ ╟─bind  ««":="
    ║           ║ │ ║ ├○ $from
    ║           ║ │ ║ └─add_n  ««"+"
    ║           ║ │ ║   ├─index  ««"nqp::index($msglc, '\\'')"
    ║           ║ │ ║   │ ├○ $msglc
    ║           ║ │ ║   │ └◙ SVal "'"
    ║           ║ │ ║   └◙ IVal 1
    ║           ║ │ ╟─bind  ««":="
    ║           ║ │ ║ ├○ $to
    ║           ║ │ ║ └─index  ««"nqp::index($msglc, '\\'', $from)"
    ║           ║ │ ║   ├○ $msglc
    ║           ║ │ ║   ├◙ SVal "'"
    ║           ║ │ ║   └○ $from
    ║           ║ │ ╟─bind :annotations({"var_initialized" => 1})  ««"$file := nqp::substr($msg, $from, $to - $from)"
    ║           ║ │ ║ ├○ $file
    ║           ║ │ ║ └─substr  ««"nqp::substr($msg, $from, $to - $from)"
    ║           ║ │ ║   ├○ $msg
    ║           ║ │ ║   ├○ $from
    ║           ║ │ ║   └─sub_n  ««"-"
    ║           ║ │ ║     ├○ $to
    ║           ║ │ ║     └○ $from
    ║           ║ │ ╙─call &say  ««"'Error: missing module \"', $file ~ '\" (original e"...
    ║           ║ │   ├◙ SVal "Error: missing module \""
    ║           ║ │   └─concat  ««"~"
    ║           ║ │     ├─concat  ««"~"
    ║           ║ │     │ ├─concat  ««"~"
    ║           ║ │     │ │ ├○ $file
    ║           ║ │     │ │ └◙ SVal "\" (original error: \""
    ║           ║ │     │ └─escape  ««"nqp::escape($msg)"
    ║           ║ │     │   └○ $msg
    ║           ║ │     └◙ SVal "\")"
    ║           ║ └─if  ««"nqp::index($msglc, 'unable to write bytecode') > -1"...
    ║           ║   ├─isgt_n  ««">"
    ║           ║   │ ├─index  ««"nqp::index($msglc, 'unable to write bytecode')"
    ║           ║   │ │ ├○ $msglc
    ║           ║   │ │ └◙ SVal "unable to write bytecode"
    ║           ║   │ └◙ IVal -1
    ║           ║   ├─:Block :blocktype(immediate)  ««"{\n                $from := nqp::index($msglc, '\\'"...
    ║           ║   │ ╟○ $file :decl(var)
    ║           ║   │ ╟○ $line :decl(var)
    ║           ║   │ ╟─bind  ««":="
    ║           ║   │ ║ ├○ $from
    ║           ║   │ ║ └─add_n  ««"+"
    ║           ║   │ ║   ├─index  ««"nqp::index($msglc, '\\'')"
    ║           ║   │ ║   │ ├○ $msglc
    ║           ║   │ ║   │ └◙ SVal "'"
    ║           ║   │ ║   └◙ IVal 1
    ║           ║   │ ╟─bind  ««":="
    ║           ║   │ ║ ├○ $to
    ║           ║   │ ║ └─index  ««"nqp::index($msglc, '\\'', $from)"
    ║           ║   │ ║   ├○ $msglc
    ║           ║   │ ║   ├◙ SVal "'"
    ║           ║   │ ║   └○ $from
    ║           ║   │ ╟─bind :annotations({"var_initialized" => 1})  ««"$file := nqp::substr($msg, $from, $to - $from)"
    ║           ║   │ ║ ├○ $file
    ║           ║   │ ║ └─substr  ««"nqp::substr($msg, $from, $to - $from)"
    ║           ║   │ ║   ├○ $msg
    ║           ║   │ ║   ├○ $from
    ║           ║   │ ║   └─sub_n  ««"-"
    ║           ║   │ ║     ├○ $to
    ║           ║   │ ║     └○ $from
    ║           ║   │ ╟─bind :annotations({"var_initialized" => 1})  ««"$line := 1"
    ║           ║   │ ║ ├○ $line
    ║           ║   │ ║ └◙ IVal 1
    ║           ║   │ ╙─bind  ««":="
    ║           ║   │   ├○ $msg
    ║           ║   │   └─join  ««"nqp::join('', [\n                          'Error: "...
    ║           ║   │     ├◙ SVal ""
    ║           ║   │     └─list  ««","
    ║           ║   │       ├◙ SVal "Error: "
    ║           ║   │       ├○ $msg
    ║           ║   │       ├◙ SVal "\n"
    ║           ║   │       ├◙ SVal "  at "
    ║           ║   │       ├○ $src_path
    ║           ║   │       ├◙ SVal ":"
    ║           ║   │       ├─stringify  ««"~"
    ║           ║   │       │ └○ $line
    ║           ║   │       └◙ SVal "\n"
    ║           ║   └─if  ««"nqp::index($msglc, 'confused') > -1 {\n            "...
    ║           ║     ├─isgt_n  ««">"
    ║           ║     │ ├─index  ««"nqp::index($msglc, 'confused')"
    ║           ║     │ │ ├○ $msglc
    ║           ║     │ │ └◙ SVal "confused"
    ║           ║     │ └◙ IVal -1
    ║           ║     ├─:Block :blocktype(immediate)  ««"{\n                $from := nqp::index($msglc, 'at "...
    ║           ║     │ ╟○ $line :decl(var)
    ║           ║     │ ╟─bind  ««":="
    ║           ║     │ ║ ├○ $from
    ║           ║     │ ║ └─add_n  ««"+"
    ║           ║     │ ║   ├─index  ««"nqp::index($msglc, 'at line')"
    ║           ║     │ ║   │ ├○ $msglc
    ║           ║     │ ║   │ └◙ SVal "at line"
    ║           ║     │ ║   └◙ IVal 1
    ║           ║     │ ╟─bind  ««":="
    ║           ║     │ ║ ├○ $from
    ║           ║     │ ║ └─findcclass  ««"nqp::findcclass(nqp::const::CCLASS_NUMERIC, $msglc,"...
    ║           ║     │ ║   ├─const CCLASS_NUMERIC
    ║           ║     │ ║   ├○ $msglc
    ║           ║     │ ║   ├○ $from
    ║           ║     │ ║   └─sub_n  ««"-"
    ║           ║     │ ║     ├─chars  ««"nqp::chars($msglc)"
    ║           ║     │ ║     │ └○ $msglc
    ║           ║     │ ║     └○ $from
    ║           ║     │ ╟─bind  ««":="
    ║           ║     │ ║ ├○ $to
    ║           ║     │ ║ └─findnotcclass  ««"nqp::findnotcclass(nqp::const::CCLASS_NUMERIC, $msg"...
    ║           ║     │ ║   ├─const CCLASS_NUMERIC
    ║           ║     │ ║   ├○ $msglc
    ║           ║     │ ║   ├○ $from
    ║           ║     │ ║   └─sub_n  ««"-"
    ║           ║     │ ║     ├─chars  ««"nqp::chars($msglc)"
    ║           ║     │ ║     │ └○ $msglc
    ║           ║     │ ║     └○ $from
    ║           ║     │ ╟─bind :annotations({"var_initialized" => 1})  ««"$line := nqp::substr($msg, $from, $to - $from)"
    ║           ║     │ ║ ├○ $line
    ║           ║     │ ║ └─substr  ««"nqp::substr($msg, $from, $to - $from)"
    ║           ║     │ ║   ├○ $msg
    ║           ║     │ ║   ├○ $from
    ║           ║     │ ║   └─sub_n  ««"-"
    ║           ║     │ ║     ├○ $to
    ║           ║     │ ║     └○ $from
    ║           ║     │ ╟─bind  ««":="
    ║           ║     │ ║ ├○ $line
    ║           ║     │ ║ └─call &max  ««"1, $line - 1"
    ║           ║     │ ║   ├◙ IVal 1
    ║           ║     │ ║   └─sub_n  ««"-"
    ║           ║     │ ║     ├○ $line
    ║           ║     │ ║     └◙ IVal 1
    ║           ║     │ ╟─bind  ««":="
    ║           ║     │ ║ ├○ $msg
    ║           ║     │ ║ └─concat  ««"~"
    ║           ║     │ ║   ├─concat  ««"~"
    ║           ║     │ ║   │ ├─substr  ««"nqp::substr($msg, 0, $from)"
    ║           ║     │ ║   │ │ ├○ $msg
    ║           ║     │ ║   │ │ ├◙ IVal 0
    ║           ║     │ ║   │ │ └○ $from
    ║           ║     │ ║   │ └○ $line
    ║           ║     │ ║   └─substr  ««"nqp::substr($msg, $to)"
    ║           ║     │ ║     ├○ $msg
    ║           ║     │ ║     └○ $to
    ║           ║     │ ╙─bind  ««":="
    ║           ║     │   ├○ $msg
    ║           ║     │   └─join  ««"nqp::join('', [\n                          'Error: "...
    ║           ║     │     ├◙ SVal ""
    ║           ║     │     └─list  ««","
    ║           ║     │       ├◙ SVal "Error: "
    ║           ║     │       ├○ $msg
    ║           ║     │       ├◙ SVal "\n"
    ║           ║     │       ├◙ SVal "  at "
    ║           ║     │       ├○ $src_path
    ║           ║     │       ├◙ SVal ":"
    ║           ║     │       ├─stringify  ««"~"
    ║           ║     │       │ └○ $line
    ║           ║     │       └◙ SVal "\n"
    ║           ║     └─if  ««"nqp::index($msglc, 'assignment (\"=\") not supporte"...
    ║           ║       ├─isgt_n  ««">"
    ║           ║       │ ├─index  ««"nqp::index($msglc, 'assignment (\"=\") not supporte"...
    ║           ║       │ │ ├○ $msglc
    ║           ║       │ │ └◙ SVal "assignment (\"=\") not supported "
    ║           ║       │ └◙ IVal -1
    ║           ║       ├─:Block :blocktype(immediate)  ««"{\n                $from := nqp::index($msglc, 'at "...
    ║           ║       │ ╟○ $line :decl(var)
    ║           ║       │ ╟○ @lines :decl(var)
    ║           ║       │ ╟○ $i :decl(var)
    ║           ║       │ ╟○ $n :decl(var)
    ║           ║       │ ╟─bind  ««"$column"
    ║           ║       │ ║ ├○ $column :decl(var)
    ║           ║       │ ║ └◙ WVal NQPMu
    ║           ║       │ ╟─bind  ««":="
    ║           ║       │ ║ ├○ $from
    ║           ║       │ ║ └─add_n  ««"+"
    ║           ║       │ ║   ├─index  ««"nqp::index($msglc, 'at line')"
    ║           ║       │ ║   │ ├○ $msglc
    ║           ║       │ ║   │ └◙ SVal "at line"
    ║           ║       │ ║   └◙ IVal 1
    ║           ║       │ ╟─bind  ««":="
    ║           ║       │ ║ ├○ $from
    ║           ║       │ ║ └─findcclass  ««"nqp::findcclass(nqp::const::CCLASS_NUMERIC, $msglc,"...
    ║           ║       │ ║   ├─const CCLASS_NUMERIC
    ║           ║       │ ║   ├○ $msglc
    ║           ║       │ ║   ├○ $from
    ║           ║       │ ║   └─sub_n  ««"-"
    ║           ║       │ ║     ├─chars  ««"nqp::chars($msglc)"
    ║           ║       │ ║     │ └○ $msglc
    ║           ║       │ ║     └○ $from
    ║           ║       │ ╟─bind  ««":="
    ║           ║       │ ║ ├○ $to
    ║           ║       │ ║ └─findnotcclass  ««"nqp::findnotcclass(nqp::const::CCLASS_NUMERIC, $msg"...
    ║           ║       │ ║   ├─const CCLASS_NUMERIC
    ║           ║       │ ║   ├○ $msglc
    ║           ║       │ ║   ├○ $from
    ║           ║       │ ║   └─sub_n  ««"-"
    ║           ║       │ ║     ├─chars  ««"nqp::chars($msglc)"
    ║           ║       │ ║     │ └○ $msglc
    ║           ║       │ ║     └○ $from
    ║           ║       │ ╟─bind :annotations({"var_initialized" => 1})  ««"$line := nqp::substr($msg, $from, $to - $from)"
    ║           ║       │ ║ ├○ $line
    ║           ║       │ ║ └─substr  ««"nqp::substr($msg, $from, $to - $from)"
    ║           ║       │ ║   ├○ $msg
    ║           ║       │ ║   ├○ $from
    ║           ║       │ ║   └─sub_n  ««"-"
    ║           ║       │ ║     ├○ $to
    ║           ║       │ ║     └○ $from
    ║           ║       │ ╟─bind  ««":="
    ║           ║       │ ║ ├○ $line
    ║           ║       │ ║ └─call &max  ««"1, $line - 1"
    ║           ║       │ ║   ├◙ IVal 1
    ║           ║       │ ║   └─sub_n  ««"-"
    ║           ║       │ ║     ├○ $line
    ║           ║       │ ║     └◙ IVal 1
    ║           ║       │ ╟─bind :annotations({"var_initialized" => 1})  ««"@lines := linesFrom($src_path, $line, 2)"
    ║           ║       │ ║ ├○ @lines
    ║           ║       │ ║ └─call &linesFrom  ««"$src_path, $line, 2"
    ║           ║       │ ║   ├○ $src_path
    ║           ║       │ ║   ├○ $line
    ║           ║       │ ║   └◙ IVal 2
    ║           ║       │ ╟─bind :annotations({"var_initialized" => 1})  ««"$i := 0"
    ║           ║       │ ║ ├○ $i
    ║           ║       │ ║ └◙ IVal 0
    ║           ║       │ ╟─bind :annotations({"var_initialized" => 1})  ««"$n := nqp::elems(@lines)"
    ║           ║       │ ║ ├○ $n
    ║           ║       │ ║ └─elems  ««"nqp::elems(@lines)"
    ║           ║       │ ║   └○ @lines
    ║           ║       │ ╟○ $column
    ║           ║       │ ╟─while  ««"$i < $n {\n                    my $line := @lines[$"...
    ║           ║       │ ║ ├─islt_n  ««"<"
    ║           ║       │ ║ │ ├○ $i
    ║           ║       │ ║ │ └○ $n
    ║           ║       │ ║ ├─:Block :blocktype(immediate)  ««"{\n                    my $line := @lines[$i];\n   "...
    ║           ║       │ ║ │ ╟○ $line :decl(var)
    ║           ║       │ ║ │ ╟○ $at :decl(var)
    ║           ║       │ ║ │ ╟─bind :annotations({"var_initialized" => 1})  ««"$line := @lines[$i]"
    ║           ║       │ ║ │ ║ ├○ $line
    ║           ║       │ ║ │ ║ └─ifnull
    ║           ║       │ ║ │ ║   ├─atpos
    ║           ║       │ ║ │ ║   │ ├○ @lines
    ║           ║       │ ║ │ ║   │ └○ $i
    ║           ║       │ ║ │ ║   └◙ WVal NQPMu
    ║           ║       │ ║ │ ╟─bind :annotations({"var_initialized" => 1})  ««"$at := nqp::index($line, '=')"
    ║           ║       │ ║ │ ║ ├○ $at
    ║           ║       │ ║ │ ║ └─index  ««"nqp::index($line, '=')"
    ║           ║       │ ║ │ ║   ├○ $line
    ║           ║       │ ║ │ ║   └◙ SVal "="
    ║           ║       │ ║ │ ╙─if  ««"$at > -1 {\n                        $column := $at "...
    ║           ║       │ ║ │   ├─isgt_n  ««">"
    ║           ║       │ ║ │   │ ├○ $at
    ║           ║       │ ║ │   │ └◙ IVal -1
    ║           ║       │ ║ │   ├─:Stmts  ««"{\n                        $column := $at + 1;\n   "...
    ║           ║       │ ║ │   │ ├─bind  ««":="
    ║           ║       │ ║ │   │ │ ├○ $column
    ║           ║       │ ║ │   │ │ └─add_n  ««"+"
    ║           ║       │ ║ │   │ │   ├○ $at
    ║           ║       │ ║ │   │ │   └◙ IVal 1
    ║           ║       │ ║ │   │ └─bind  ««":="
    ║           ║       │ ║ │   │   ├○ $i
    ║           ║       │ ║ │   │   └○ $n
    ║           ║       │ ║ │   └─:Stmts  ««"{\n                        $i++;\n                 "...
    ║           ║       │ ║ │     ├─postinc  ««"++"
    ║           ║       │ ║ │     │ └○ $i
    ║           ║       │ ║ │     └─postinc  ««"++"
    ║           ║       │ ║ │       └○ $line
    ║           ║       │ ║ └◙ IVal 1 :named("nohandler")
    ║           ║       │ ╟─bind  ««":="
    ║           ║       │ ║ ├○ $msg
    ║           ║       │ ║ └─concat  ««"~"
    ║           ║       │ ║   ├─concat  ««"~"
    ║           ║       │ ║   │ ├─substr  ««"nqp::substr($msg, 0, $from)"
    ║           ║       │ ║   │ │ ├○ $msg
    ║           ║       │ ║   │ │ ├◙ IVal 0
    ║           ║       │ ║   │ │ └○ $from
    ║           ║       │ ║   │ └○ $line
    ║           ║       │ ║   └─substr  ««"nqp::substr($msg, $to)"
    ║           ║       │ ║     ├○ $msg
    ║           ║       │ ║     └○ $to
    ║           ║       │ ╙─bind  ««":="
    ║           ║       │   ├○ $msg
    ║           ║       │   └─join  ««"nqp::join('', [\n                          'Error: "...
    ║           ║       │     ├◙ SVal ""
    ║           ║       │     └─list  ««","
    ║           ║       │       ├◙ SVal "Error: "
    ║           ║       │       ├○ $msg
    ║           ║       │       ├◙ SVal "\n"
    ║           ║       │       ├◙ SVal "   at "
    ║           ║       │       ├○ $src_path
    ║           ║       │       ├◙ SVal ":"
    ║           ║       │       ├─stringify  ««"~"
    ║           ║       │       │ └○ $line
    ║           ║       │       ├─if  ««"?? ':' ~ $column !!"
    ║           ║       │       │ ├○ $column
    ║           ║       │       │ ├─concat  ««"~"
    ║           ║       │       │ │ ├◙ SVal ":"
    ║           ║       │       │ │ └○ $column
    ║           ║       │       │ └◙ SVal ""
    ║           ║       │       └◙ SVal "\n"
    ║           ║       └─if  ««"0 {\n                my $line := 1;\n              "...
    ║           ║         ├◙ IVal 0
    ║           ║         ├─:Block :blocktype(immediate)  ««"{\n                my $line := 1;\n                "...
    ║           ║         │ ╟○ $line :decl(var)
    ║           ║         │ ╟─bind  ««"$column"
    ║           ║         │ ║ ├○ $column :decl(var)
    ║           ║         │ ║ └◙ WVal NQPMu
    ║           ║         │ ╟─bind :annotations({"var_initialized" => 1})  ««"$line := 1"
    ║           ║         │ ║ ├○ $line
    ║           ║         │ ║ └◙ IVal 1
    ║           ║         │ ╟○ $column
    ║           ║         │ ╙─bind  ««":="
    ║           ║         │   ├○ $msg
    ║           ║         │   └─join  ««"nqp::join('', [\n                          'ERROR: "...
    ║           ║         │     ├◙ SVal ""
    ║           ║         │     └─list  ««","
    ║           ║         │       ├◙ SVal "ERROR: "
    ║           ║         │       ├○ $msg
    ║           ║         │       ├◙ SVal "\n"
    ║           ║         │       ├◙ SVal "   at "
    ║           ║         │       ├○ $src_path
    ║           ║         │       ├◙ SVal ":"
    ║           ║         │       ├─stringify  ««"~"
    ║           ║         │       │ └○ $line
    ║           ║         │       ├─if  ««"?? ':' ~ $column !!"
    ║           ║         │       │ ├○ $column
    ║           ║         │       │ ├─concat  ««"~"
    ║           ║         │       │ │ ├◙ SVal ":"
    ║           ║         │       │ │ └○ $column
    ║           ║         │       │ └◙ SVal ""
    ║           ║         │       └◙ SVal "\n"
    ║           ║         └─bind  ««":="
    ║           ║           ├○ $msg
    ║           ║           └─concat  ««"~"
    ║           ║             ├○ $msg
    ║           ║             └─join  ««"nqp::join(\"\\n\", nqp::backtracestrings($error))"
    ║           ║               ├◙ SVal "\n"
    ║           ║               └─backtracestrings  ««"nqp::backtracestrings($error)"
    ║           ║                 └○ $error
    ║           ╟─flushfh  ««"nqp::flushfh(nqp::getstdout())"
    ║           ║ └─getstdout  ««"nqp::getstdout()"
    ║           ╙─die  ««"nqp::die($msg)"
    ║             └○ $msg
    ╙─if
      ├○ @ARGS
      └─call &MAIN
        └○ @ARGS :flat(1)